<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"zeinsshiri.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>


    <meta name="description" content="在何处付出，便在何处收获">
<meta property="og:type" content="website">
<meta property="og:title" content="Zeins&#39;s Blog">
<meta property="og:url" content="https://zeinsshiri.github.io/page/8/">
<meta property="og:site_name" content="Zeins&#39;s Blog">
<meta property="og:description" content="在何处付出，便在何处收获">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zeins_XvJin_Shiri">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zeinsshiri.github.io/page/8/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/8/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Zeins's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/rss2.xml" title="Zeins's Blog" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Zeins's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">笔记直接导入的，排版稍差，得有时间再处理</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zeins_XvJin_Shiri"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Zeins_XvJin_Shiri</p>
  <div class="site-description" itemprop="description">在何处付出，便在何处收获</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">134</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zeinsshiri/" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zeinsshiri&#x2F;" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:Rennai10000@outlook.com" title="E-Mail → mailto:Rennai10000@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Zeins_x_Shiri" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Zeins_x_Shiri" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="rss fa-fw"></i>RSS</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeinsshiri.github.io/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zeins_XvJin_Shiri">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeins's Blog">
      <meta itemprop="description" content="在何处付出，便在何处收获">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeins's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/" class="post-title-link" itemprop="url">编程范式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-07 17:18:48" itemprop="dateCreated datePublished" datetime="2024-02-07T17:18:48+08:00">2024-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-08 16:47:40" itemprop="dateModified" datetime="2024-02-08T16:47:40+08:00">2024-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">编程范式</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>125</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>面向过程：程序执行就是一组函数顺序执行。为了降低系统复杂度，函数继续切分为子函数</p>
<p>面向对象：程序执行就是一系列数据在对象之间传递（对象包含了数据和操作数据的函数）</p>
<p>函数式编程：</p>
<p>面向过程<br>面向对象Object Oriented Programming：</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3051466608%7D" title="函数式编程">函数式编程</a></p>

      
    </div>

    
    
    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeinsshiri.github.io/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zeins_XvJin_Shiri">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeins's Blog">
      <meta itemprop="description" content="在何处付出，便在何处收获">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeins's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">编程语言</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-07 17:18:48" itemprop="dateCreated datePublished" datetime="2024-02-07T17:18:48+08:00">2024-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-08 16:43:43" itemprop="dateModified" datetime="2024-02-08T16:43:43+08:00">2024-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>204</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>计算机硬件系统提供了最基础的元结构，并允许通过编程建模的方式达到各种输出的目的；并且具有层次性，</p>
<p>由于复杂模型的需求，在编程语法以及用户自定义数据结构及算法层面又定义了更高层次的元结构；</p>
<p>故编程&#x3D;抽象出模型目的性+设计元结构+搭建模型</p>
<p>进行后两步工作的使用的主要工具就是编程语言</p>
<p>？：计算机硬件（编程语言工具）怎么让人可以自由搭建模型的；怎么让用户可以自定义元结构的</p>
<p><a href="%E6%B1%87%E7%BC%96%EF%BC%9F%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/%E6%B1%87%E7%BC%96%EF%BC%9F%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4.md" title="汇编？机器指令">汇编？机器指令</a></p>
<p><a href="C/C.md" title="C">C</a></p>
<p><a href="C++/C++.md" title="C++">C++</a></p>
<p><a href="python/python.md" title="python">python</a></p>
<p><a href="%E6%96%B0%E9%A1%B5%E9%9D%A2/%E6%96%B0%E9%A1%B5%E9%9D%A2.md" title="新页面">新页面</a></p>
<p><img src="/image/image_jcrgVll1JN.png"></p>

      
    </div>

    
    
    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeinsshiri.github.io/2024/02/07/%E8%BD%AF%E4%BB%B6/AWTK/%E7%95%8C%E9%9D%A2%E6%8F%8F%E8%BF%B0/%E7%95%8C%E9%9D%A2%E6%8F%8F%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zeins_XvJin_Shiri">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeins's Blog">
      <meta itemprop="description" content="在何处付出，便在何处收获">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeins's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/07/%E8%BD%AF%E4%BB%B6/AWTK/%E7%95%8C%E9%9D%A2%E6%8F%8F%E8%BF%B0/%E7%95%8C%E9%9D%A2%E6%8F%8F%E8%BF%B0/" class="post-title-link" itemprop="url">界面描述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-07 17:18:48" itemprop="dateCreated datePublished" datetime="2024-02-07T17:18:48+08:00">2024-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-08 16:29:18" itemprop="dateModified" datetime="2024-02-08T16:29:18+08:00">2024-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BD%AF%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">软件</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><p><img src="/image/image_abCHHaqk4d.png"></p>
<p>浅色为可复用部分；开发完成后编译打包下载<br>定制控件：手写XML<br>一般情况：AWTK Designer</p>
<h1 id="入口main"><a href="#入口main" class="headerlink" title="入口main"></a>入口main</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;awtk.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">BEGIN_C_DECLS </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> AWTK_WEB </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;assets.inc&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/*AWTK_WEB*/</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../res/assets.inc&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*AWTK_WEB*/</span> </span></span><br><span class="line">END_C_DECLS</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">ret_t</span> <span class="title function_">application_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">ret_t</span> <span class="title function_">application_exit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;awtk_main.inc&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>1）接口兼容<br>BEGIN_C_DECLS和END_C_DECLS宏:C++因为有函数重载特性导致在C&#x2F;C++混合编程时接口不兼容；需要告诉C++编译器使用C调用标准；extern “C”{}编译器会将包含在{}中代码按C调用约定进行处理，以便与其他使用C语言编写的代码进行兼容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* C++ needs to know that types and declarations are C, not C++.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  __cplusplus</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __BEGIN_DECLS  extern <span class="string">&quot;C&quot;</span> &#123;</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __END_DECLS  &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __BEGIN_DECLS</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __END_DECLS</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个语法糖，如果是在c++中，则__BEGIN_DECLS和__END_DECLS表示 extern &quot;C&quot; &#123;&#125;，在C中，则表示无意义</span></span><br></pre></td></tr></table></figure>

<p>2）资源载入<br>#ifdef和#else指令判断是否为AWTK_WEB环境，如果是，则使用#include “assets.inc”引入资源文件；如果不是，则使用#include “..&#x2F;res&#x2F;assets.inc”引入资源文件<br>3）声明外部的应用初始化和退出函数<br>extern关键字声明了两个函数：application_init和application_exit（应用初始化和退出析构函数）</p>
<h1 id="应用初始化"><a href="#应用初始化" class="headerlink" title="应用初始化"></a>应用初始化</h1><p>&#x20;application_init 和 application_exit，这两 个函数分别在进入 awtk 事件循环的前后执行，它们在 application.c 中实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">...... </span><br><span class="line"><span class="comment">/* 当程序初始化完成时调用，全局只触发一次。有初始化需求可以自己在此处添加 */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">ret_t</span> <span class="title function_">application_on_launch</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> RET_OK; </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="comment">/* 当程序退出时调用，全局只触发一次。如有初始化的数据需要释放，在此函数内释放 */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">ret_t</span> <span class="title function_">application_on_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> RET_OK; </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="comment">/* 初始化程序 */</span> </span><br><span class="line"> <span class="type">ret_t</span> <span class="title function_">application_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">   custom_widgets_register(); </span><br><span class="line">   application_on_launch();</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(APP_SYSTEM_BAR) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="comment">/* 如果存在指定的系统栏，则打开指定的顶部系统栏 */</span> </span><br><span class="line">   navigator_to(APP_SYSTEM_BAR); </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(APP_BOTTOM_SYSTEM_BAR) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="comment">/* 如果存在指定的系统栏，则打开指定的底部系统栏 */</span> </span><br><span class="line">   navigator_to(APP_BOTTOM_SYSTEM_BAR); </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="comment">/* 打开设定的主界面窗口 */</span> </span><br><span class="line">   <span class="keyword">return</span> navigator_to(APP_START_PAGE); </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="comment">/* 退出程序 */</span> </span><br><span class="line"><span class="type">ret_t</span> <span class="title function_">application_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">   application_on_exit();</span><br><span class="line">   log_debug(<span class="string">&quot;application_exit\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> RET_OK; </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="窗口初始化"><a href="#窗口初始化" class="headerlink" title="窗口初始化"></a>窗口初始化</h1><p>在 AWTK 中，通常会为每个窗口配置一个 c 文件，例如 home_page.c，并在该文件中进 行窗口初始化，用户可以按需在初始化函数中添加内容，对该窗口的操作也在这个文件中实 现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ret_t</span> <span class="title function_">home_page_init</span><span class="params">(<span class="type">widget_t</span>* win, <span class="type">void</span>* ctx)</span> &#123;</span><br><span class="line">    (<span class="type">void</span>)ctx; </span><br><span class="line">    return_value_if_fail(win != <span class="literal">NULL</span>, RET_BAD_PARAMS);</span><br><span class="line">     <span class="comment">/* 遍历 win 窗口的子控件，visit_init_child 是遍历时的回调函数 */</span> </span><br><span class="line">     widget_foreach(win, visit_init_child, win);</span><br><span class="line">     <span class="keyword">return</span> RET_OK; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>打开并初始化窗口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ret_t</span> <span class="title function_">application_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"> <span class="comment">/* 调用 AWTK 原生 API 打开 home_page 窗口 */</span> </span><br><span class="line">    <span class="type">widget_t</span>* win = window_open(<span class="string">&quot;home_page&quot;</span>);</span><br><span class="line">     <span class="comment">/* 初始化 home_page 窗口 */</span> </span><br><span class="line">    home_page_init(win, <span class="literal">NULL</span>); </span><br><span class="line">    <span class="keyword">return</span> RET_OK;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeinsshiri.github.io/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&%E7%AE%97%E6%B3%95/DP%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/DP%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zeins_XvJin_Shiri">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeins's Blog">
      <meta itemprop="description" content="在何处付出，便在何处收获">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeins's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&%E7%AE%97%E6%B3%95/DP%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/DP%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">DP最优化问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-07 17:18:48" itemprop="dateCreated datePublished" datetime="2024-02-07T17:18:48+08:00">2024-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-08 16:33:30" itemprop="dateModified" datetime="2024-02-08T16:33:30+08:00">2024-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构&算法</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><strong>原问题的最优解是从子问题的最优解构建得来</strong>（<strong>由最优子结构递推出全局最优解</strong>）</p>
<p><img src="/image/image_0es9OO7gl5.png"></p>
<p>阶数高时；到i阶最小代价$f(i)&#x3D;min[f(i-1),f(i-2)]+cost(x);x\in{1,2}$等于到前两阶的最小代价其中小的那一个+跳一次的成本；<strong>最优子结构</strong>构成的递推式导出全局最优解；本质上还是dp问题<br>dp策略：<br>1）当前状态由前2个状态决定；声明两个变量存储状态<br>2）变量存进初状态<br>3）根据状态转移方程，迭代地进行递推</p>
<p><img src="/image/image_eDlj7mUi7j.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 爬楼梯最小代价：动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairsDP</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;cost)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = cost.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> cost[n];</span><br><span class="line">    <span class="comment">// 初始化 dp 表，用于存储子问题的解</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 初始状态：预设最小子问题的解</span></span><br><span class="line">    dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">2</span>] = cost[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 状态转移：从较小子问题逐步求解较大子问题</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>]) + cost[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 爬楼梯最小代价：空间优化后的动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairsDPComp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;cost)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = cost.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> cost[n];</span><br><span class="line">    <span class="type">int</span> a = cost[<span class="number">1</span>], b = cost[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = b;</span><br><span class="line">        b = <span class="built_in">min</span>(a, tmp) + cost[i];</span><br><span class="line">        a = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>与<a href="../%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2-%E8%AE%B0%E5%BF%86%E6%90%9C%E7%B4%A2%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2-%E8%AE%B0%E5%BF%86%E6%90%9C%E7%B4%A2%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98.md" title="暴力搜索/记忆搜索最优化问题">暴力搜索&#x2F;记忆搜索最优化问题</a>相同问题的dp策略解法：<br>求$[0,0]→[i,j]$的最小路径和<br>1）状态转移方程：<br>$f(i,j)&#x3D;min{f(i-1,j),f(i,j-1)}+grid(i,j);i,j&gt;0$$f(0,j)&#x3D;f(0,j-1)+grid(0,j)$$f(i,0)&#x3D;f(i-1,0)+grid(i,0)$<br>2初始状态：f(0,0)&#x3D;1</p>
<p><img src="/image/image_ixQIyrTz99.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 最小路径和：动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minPathSumDP</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = grid.<span class="built_in">size</span>(), m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 状态转移：首行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 状态转移：首列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 状态转移：其余行列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>空间优化：哪些要预存储，哪些可以用到再算O(1)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 最小路径和：空间优化后的动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minPathSumDPComp</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = grid.<span class="built_in">size</span>(), m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="comment">// 状态转移：首行</span></span><br><span class="line">    dp[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">        dp[j] = dp[j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 状态转移：其余行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 状态转移：首列</span></span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 状态转移：其余列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">min</span>(dp[j - <span class="number">1</span>], dp[j]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeinsshiri.github.io/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&%E7%AE%97%E6%B3%95/dp%E9%97%AE%E9%A2%98/dp%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zeins_XvJin_Shiri">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeins's Blog">
      <meta itemprop="description" content="在何处付出，便在何处收获">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeins's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&%E7%AE%97%E6%B3%95/dp%E9%97%AE%E9%A2%98/dp%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">dp问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-07 17:18:48" itemprop="dateCreated datePublished" datetime="2024-02-07T17:18:48+08:00">2024-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-08 16:33:48" itemprop="dateModified" datetime="2024-02-08T16:33:48+08:00">2024-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构&算法</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>436</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20dynamic%20programming/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20dynamic%20programming.md" title="动态规划 dynamic programming">动态规划 dynamic programming</a>常规dp问题参考</p>
<p>带约束dp问题</p>
<p><img src="/image/image_kWGH-jvESy.png"></p>
<p><img src="/image/image_mC-XJL5Geq.png"></p>
<p><img src="/image/image_sxGmjf9o_z.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 带约束爬楼梯：动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">climbingStairsConstraintDP</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化 dp 表，用于存储子问题的解</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 初始状态：预设最小子问题的解</span></span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 状态转移：从较小子问题逐步求解较大子问题</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        dp[i][<span class="number">2</span>] = dp[i - <span class="number">2</span>][<span class="number">1</span>] + dp[i - <span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">1</span>] + dp[n][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/image/image_Y0zcmhvvEu.png"></p>

      
    </div>

    
    
    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeinsshiri.github.io/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&%E7%AE%97%E6%B3%95/0-1%E5%86%B3%E7%AD%96%E6%A0%91%E9%97%AE%E9%A2%98/0-1%E5%86%B3%E7%AD%96%E6%A0%91%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zeins_XvJin_Shiri">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeins's Blog">
      <meta itemprop="description" content="在何处付出，便在何处收获">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeins's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&%E7%AE%97%E6%B3%95/0-1%E5%86%B3%E7%AD%96%E6%A0%91%E9%97%AE%E9%A2%98/0-1%E5%86%B3%E7%AD%96%E6%A0%91%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">0-1决策树问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-07 17:18:48" itemprop="dateCreated datePublished" datetime="2024-02-07T17:18:48+08:00">2024-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-08 16:42:58" itemprop="dateModified" datetime="2024-02-08T16:42:58+08:00">2024-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构&算法</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/image/image_WT4ZBmASeA.png"></p>
<p>有n个选项；每个选项只能选择一次；那么可以进行n轮0-1决策；求前n轮决策最优解<br><strong>第i轮决策后最大价值</strong>状态转移方程：<br>$f(i,c)&#x3D;f(i-1,c-wgt(i-1))+val(i-1)$;i-1轮决策选择了1<br>$f(i,c)&#x3D;f(i-1,c)$;i-1轮决策选择了0<br>$&#x3D;&gt;f(i,c)&#x3D;max(f(i-1,c),f(i-1,c-wgt(i-1))+val(i-1))$&#x2F;&#x2F;代码按这个来写<br>边界条件：</p>
<ol>
<li>$f(0,c)&#x3D;0||f(i,0)&#x3D;0$最小子结构</li>
<li>c≥0&amp;&amp;c-wgt(i-1)≥0重量约束</li>
</ol>
<h1 id="暴力搜索"><a href="#暴力搜索" class="headerlink" title="暴力搜索"></a>暴力搜索</h1><p>怎么看都像是一种分治（又像枚举）：<strong>第i轮决策后最大价值</strong>&#x3D;i-1轮决策后最大价值+第i轮决策增加的价值</p>
<p><img src="/image/image__xDeSUU6X6.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 0-1 背包：暴力搜索 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsackDFS</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;wgt, vector&lt;<span class="type">int</span>&gt; &amp;val, <span class="type">int</span> i, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若已选完所有物品或背包无容量，则返回价值 0</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> || c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若超过背包容量，则只能不放入背包</span></span><br><span class="line">    <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">knapsackDFS</span>(wgt, val, i - <span class="number">1</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算不放入和放入物品 i 的最大价值</span></span><br><span class="line">    <span class="type">int</span> no = <span class="built_in">knapsackDFS</span>(wgt, val, i - <span class="number">1</span>, c);</span><br><span class="line">    <span class="type">int</span> yes = <span class="built_in">knapsackDFS</span>(wgt, val, i - <span class="number">1</span>, c - wgt[i - <span class="number">1</span>]) + val[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 返回两种方案中价值更大的那一个</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(no, yes);</span><br><span class="line">&#125;<span class="comment">//O(2^n)???????</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h1><p>二维数组mem存储结果，O(n*cap)取决于二维数组排列数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 0-1 背包：记忆化搜索 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsackDFSMem</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;wgt, vector&lt;<span class="type">int</span>&gt; &amp;val, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;mem, <span class="type">int</span> i, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若已选完所有物品或背包无容量，则返回价值 0</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> || c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若已有记录，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (mem[i][c] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mem[i][c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若超过背包容量，则只能不放入背包</span></span><br><span class="line">    <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">knapsackDFSMem</span>(wgt, val, mem, i - <span class="number">1</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算不放入和放入物品 i 的最大价值</span></span><br><span class="line">    <span class="type">int</span> no = <span class="built_in">knapsackDFSMem</span>(wgt, val, mem, i - <span class="number">1</span>, c);</span><br><span class="line">    <span class="type">int</span> yes = <span class="built_in">knapsackDFSMem</span>(wgt, val, mem, i - <span class="number">1</span>, c - wgt[i - <span class="number">1</span>]) + val[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 记录并返回两种方案中价值更大的那一个</span></span><br><span class="line">    mem[i][c] = <span class="built_in">max</span>(no, yes);</span><br><span class="line">    <span class="keyword">return</span> mem[i][c];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h1><p>可以发现，决策树的dp策略就是从最底下的f(0,0)递推到f(3,c)；按状态表顺序递推</p>
<p><img src="/image/image_PehDFV8HkR.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 0-1 背包：动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsackDP</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;wgt, vector&lt;<span class="type">int</span>&gt; &amp;val, <span class="type">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = wgt.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(cap + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">//行迭代</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">1</span>; c &lt;= cap; c++) &#123;<span class="comment">//列迭代</span></span><br><span class="line">            <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) &#123;</span><br><span class="line">                <span class="comment">// 若超过背包容量，则不选物品 i</span></span><br><span class="line">                dp[i][c] = dp[i - <span class="number">1</span>][c];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不选和选物品 i 这两种方案的较大值</span></span><br><span class="line">                dp[i][c] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][c], dp[i - <span class="number">1</span>][c - wgt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][cap];</span><br><span class="line">&#125;<span class="comment">//O(n*cap)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>由于每行状态的计算只与其上一行的状态有关，因此我们可以使用两个数组滚动前进，将空间复杂度从 O(n^2) 将低至 O(n) 。</p>
<p>进一步思考，我们是否可以仅用一个数组实现空间优化呢？观察可知，每个状态都是由正上方或左上方的格子转移过来的。假设只有一个数组，当开始遍历第 i 行时，该数组存储的仍然是第 i−1 行的状态。</p>
<ul>
<li>如果采取正序遍历，那么遍历到 dp[i,j] 时，左上方 dp[i-1,j]~ dp[i-1,j-1]值可能已经被覆盖，此时就无法得到正确的状态转移结果。</li>
<li>如果采取倒序遍历，则不会发生覆盖问题，状态转移可以正确进行。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 0-1 背包：空间优化后的动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsackDPComp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;wgt, vector&lt;<span class="type">int</span>&gt; &amp;val, <span class="type">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = wgt.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(cap + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 倒序遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c = cap; c &gt;= <span class="number">1</span>; c--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &lt;= c) &#123;</span><br><span class="line">                <span class="comment">// 不选和选物品 i 这两种方案的较大值</span></span><br><span class="line">                dp[c] = <span class="built_in">max</span>(dp[c], dp[c - wgt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[cap];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeinsshiri.github.io/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&%E7%AE%97%E6%B3%95/n%E7%9A%87%E5%90%8E%EF%BC%88%E6%8E%92%E8%AF%BE%E9%97%AE%E9%A2%98%EF%BC%89/n%E7%9A%87%E5%90%8E%EF%BC%88%E6%8E%92%E8%AF%BE%E9%97%AE%E9%A2%98%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zeins_XvJin_Shiri">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeins's Blog">
      <meta itemprop="description" content="在何处付出，便在何处收获">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeins's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&%E7%AE%97%E6%B3%95/n%E7%9A%87%E5%90%8E%EF%BC%88%E6%8E%92%E8%AF%BE%E9%97%AE%E9%A2%98%EF%BC%89/n%E7%9A%87%E5%90%8E%EF%BC%88%E6%8E%92%E8%AF%BE%E9%97%AE%E9%A2%98%EF%BC%89/" class="post-title-link" itemprop="url">n皇后（排课问题）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-07 17:18:48" itemprop="dateCreated datePublished" datetime="2024-02-07T17:18:48+08:00">2024-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-08 16:33:20" itemprop="dateModified" datetime="2024-02-08T16:33:20+08:00">2024-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构&算法</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>n维向量空间+一些约束条件构成的解空间生成问题</p>
<p><img src="/image/image_OqEuExVZUa.png"></p>
<p>回溯策略：回溯枚举n*n矩阵解空间，并判断是否满足约束(具体是按行枚举，因为每行只能放一个，最多能放n行，每行n种放法，这样只用判断是否满足列，斜约束)；到这里O(n^2)；爆炸；所以要抽象出约束函数剪枝</p>
<p><img src="/image/image_PPHngzSPSB.png"></p>
<p><img src="/image/image_A7moa_O8px.png"></p>
<p>1）遍历所有列可能，先放第一行；再递归地放下一行<br>2）每放进一个数生成3个约束函数；其子树矩阵没加一个数判断一次</p>
<p><img src="/image/image_SJlx46KdF1.png"></p>
<p><img src="/image/image_NVxkbKy2Dh.png"></p>
<p>通过放缩因子判断</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 回溯算法：N 皇后 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> n, vector&lt;vector&lt;string&gt;&gt; &amp;state, vector&lt;vector&lt;vector&lt;string&gt;&gt;&gt; &amp;res, vector&lt;<span class="type">bool</span>&gt; &amp;cols,</span></span></span><br><span class="line"><span class="params"><span class="function">               vector&lt;<span class="type">bool</span>&gt; &amp;diags1, vector&lt;<span class="type">bool</span>&gt; &amp;diags2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当放置完所有行时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(state);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有列可能</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="comment">// 计算该格子对应的主对角线和副对角线</span></span><br><span class="line">        <span class="type">int</span> diag1 = row - col + n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> diag2 = row + col;</span><br><span class="line">        <span class="comment">// 剪枝：不允许该格子所在列、主对角线、副对角线存在皇后</span></span><br><span class="line">        <span class="keyword">if</span> (!cols[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2]) &#123;</span><br><span class="line">            <span class="comment">// 尝试：将皇后放置在该格子</span></span><br><span class="line">            state[row][col] = <span class="string">&quot;Q&quot;</span>;</span><br><span class="line">            cols[col] = diags1[diag1] = diags2[diag2] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 放置下一行</span></span><br><span class="line">            <span class="built_in">backtrack</span>(row + <span class="number">1</span>, n, state, res, cols, diags1, diags2);</span><br><span class="line">            <span class="comment">// 回退：将该格子恢复为空位</span></span><br><span class="line">            state[row][col] = <span class="string">&quot;#&quot;</span>;</span><br><span class="line">            cols[col] = diags1[diag1] = diags2[diag2] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求解 N 皇后 */</span></span><br><span class="line">vector&lt;vector&lt;vector&lt;string&gt;&gt;&gt; <span class="built_in">nQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// 初始化 n*n 大小的棋盘，其中 &#x27;Q&#x27; 代表皇后，&#x27;#&#x27; 代表空位</span></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">state</span>(n, <span class="built_in">vector</span>&lt;string&gt;(n, <span class="string">&quot;#&quot;</span>));</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">cols</span><span class="params">(n, <span class="literal">false</span>)</span></span>;           <span class="comment">// 记录列是否有皇后</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">diags1</span><span class="params">(<span class="number">2</span> * n - <span class="number">1</span>, <span class="literal">false</span>)</span></span>; <span class="comment">// 记录主对角线是否有皇后</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">diags2</span><span class="params">(<span class="number">2</span> * n - <span class="number">1</span>, <span class="literal">false</span>)</span></span>; <span class="comment">// 记录副对角线是否有皇后</span></span><br><span class="line">    vector&lt;vector&lt;vector&lt;string&gt;&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">0</span>, n, state, res, cols, diags1, diags2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/image/image_GuWMsZYRcm.png"></p>

      
    </div>

    
    
    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeinsshiri.github.io/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zeins_XvJin_Shiri">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeins's Blog">
      <meta itemprop="description" content="在何处付出，便在何处收获">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeins's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91/" class="post-title-link" itemprop="url">二叉树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-07 17:18:48" itemprop="dateCreated datePublished" datetime="2024-02-07T17:18:48+08:00">2024-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-08 16:40:57" itemprop="dateModified" datetime="2024-02-08T16:40:57+08:00">2024-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构&算法</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>每个「父节点 parent node」都有两个引用（指针），分别指向「左子节点 left-child node」和「右子节点 right-child node」，节点的左子节点及其以下节点形成的树称为该节点的「左子树 left subtree」，同理可得「右子树 right subtree」。</p>
<p><strong>在二叉树中，除叶节点外，其他所有节点都包含子节点和非空子树</strong>。</p>
<p><img src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/binary_tree_definition.png"></p>
<h3 id="常见术语"><a href="#常见术语" class="headerlink" title="常见术语"></a>常见术语</h3><ul>
<li>「根节点 root node」：位于二叉树顶层的节点，没有父节点。</li>
<li>「叶节点 leaf node」：没有子节点的节点，其两个指针均指向 None 。</li>
<li>「边 edge」：连接两个节点的线段，即节点引用（指针）。</li>
<li>节点所在的「层 level」：从顶至底递增，根节点所在层为 1 。</li>
<li>节点的「度 degree」：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。</li>
<li>二叉树的「高度 height」：从根节点到最远叶节点所经过的边的数量。</li>
<li>节点的「深度 depth」：从根节点到该节点所经过的边的数量。</li>
<li>节点的「高度 height」：从最远叶节点到该节点所经过的边的数量。</li>
</ul>
<p><img src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/binary_tree_terminology.png"></p>
<h3 id="链表实现下二叉树基本操作"><a href="#链表实现下二叉树基本操作" class="headerlink" title="链表实现下二叉树基本操作"></a>链表实现下二叉树基本操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树节点结构体 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;          <span class="comment">// 节点值</span></span><br><span class="line">    TreeNode *left;   <span class="comment">// 左子节点指针</span></span><br><span class="line">    TreeNode *right;  <span class="comment">// 右子节点指针</span></span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;<span class="comment">//链表实现的二叉树节点</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-初始化二叉树"><a href="#1-初始化二叉树" class="headerlink" title="1.   初始化二叉树"></a>1.   初始化二叉树</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化二叉树 */</span></span><br><span class="line"><span class="comment">// 初始化节点</span></span><br><span class="line">TreeNode* n1 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">TreeNode* n2 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">TreeNode* n3 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">TreeNode* n4 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">TreeNode* n5 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 构建引用指向（即指针）</span></span><br><span class="line">n1-&gt;left = n2;</span><br><span class="line">n1-&gt;right = n3;</span><br><span class="line">n2-&gt;left = n4;</span><br><span class="line">n2-&gt;right = n5;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-插入与删除节点"><a href="#2-插入与删除节点" class="headerlink" title="2.   插入与删除节点"></a>2.   插入与删除节点</h4><p><img src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/binary_tree_add_remove.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入与删除节点 */</span></span><br><span class="line">TreeNode* P = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 在 n1 -&gt; n2 中间插入节点 P</span></span><br><span class="line">n1-&gt;left = P;</span><br><span class="line">P-&gt;left = n2;</span><br><span class="line"><span class="comment">// 删除节点 P</span></span><br><span class="line">n1-&gt;left = n2;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>插入节点可能会改变二叉树的原有逻辑结构，而删除节点通常意味着删除该节点及其所有子树。因此，在二叉树中，插入与删除操作通常是由一套操作配合完成的，以实现有实际意义的操作。</p>
<h3 id="常见二叉树类型"><a href="#常见二叉树类型" class="headerlink" title="常见二叉树类型"></a>常见二叉树类型</h3><h4 id="1-完美二叉树-perfect-binary-tree"><a href="#1-完美二叉树-perfect-binary-tree" class="headerlink" title="1.   完美二叉树 perfect binary tree"></a>1.   完美二叉树 perfect binary tree</h4><p>完美二叉树中，叶节点的度为 0 ，其余所有节点的度都为 2 ；若树高度为 ℎ ，节点总数为 $ 2^{ℎ+1} −1  $，呈现指数级关系，反映自然界常见的细胞分裂现象</p>
<p><img src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/perfect_binary_tree.png"></p>
<h4 id="2-完全二叉树-complete-binary-tree"><a href="#2-完全二叉树-complete-binary-tree" class="headerlink" title="2.   完全二叉树 complete binary tree"></a>2.   完全二叉树 complete binary tree</h4><p>只有底层节点未填满，且靠左填充</p>
<p><img src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/complete_binary_tree.png"></p>
<h4 id="3-完满二叉树full-binary-tree"><a href="#3-完满二叉树full-binary-tree" class="headerlink" title="3.   完满二叉树full binary tree"></a>3.   完满二叉树full binary tree</h4><p>除了叶节点之外，其余所有节点都有两个子节点。</p>
<p><img src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/full_binary_tree.png"></p>
<h4 id="4-平衡二叉树balanced-binary-tree"><a href="#4-平衡二叉树balanced-binary-tree" class="headerlink" title="4.   平衡二叉树balanced binary tree"></a>4.   平衡二叉树balanced binary tree</h4><p>任意节点的左子树和右子树的高度之差的绝对值不超过 1 。</p>
<p><img src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/balanced_binary_tree.png"></p>
<h3 id="x20-二叉树退化"><a href="#x20-二叉树退化" class="headerlink" title="&#x20;二叉树退化"></a>&#x20;二叉树退化</h3><p>二叉树的每层节点都被填满时，达到“完美二叉树”；而当所有节点都偏向一侧时，二叉树退化为“链表”;即二叉树的最佳与最差结构</p>
<ul>
<li>完美二叉树是理想情况，可以充分发挥二叉树“分治”的优势。</li>
<li>链表则是另一个极端，各项操作都变为线性操作，时间复杂度退化至 O(n) 。</li>
</ul>
<p><img src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/binary_tree_best_worst_cases.png"></p>
<p>在最佳和最差结构下，二叉树的叶节点数量、节点总数、高度等达到极大或极小值。</p>
<p><img src="/image/image_QFfvRnUeAg.png"></p>
<h3 id="x20-二叉树遍历"><a href="#x20-二叉树遍历" class="headerlink" title="&#x20;二叉树遍历??????"></a>&#x20;二叉树遍历??????</h3><h4 id="层序遍历level-order-traversal「广度优先遍历-breadth-first-traversal」"><a href="#层序遍历level-order-traversal「广度优先遍历-breadth-first-traversal」" class="headerlink" title="层序遍历level-order traversal「广度优先遍历 breadth-first traversal」"></a>层序遍历level-order traversal「广度优先遍历 breadth-first traversal」</h4><p>从顶层到底层，每层从左到右访问节点遍历二叉树</p>
<p><img src="https://www.hello-algo.com/chapter_tree/binary_tree_traversal.assets/binary_tree_bfs.png"></p>
<p>广度优先遍历通常借助“队列”来实现。队列遵循“先进先出”的规则，而广度优先遍历则遵循“逐层推进”的规则，两者背后的思想是一致的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 层序遍历 */</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化队列，加入根节点</span></span><br><span class="line">    queue&lt;TreeNode *&gt; queue;</span><br><span class="line">    queue.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="comment">// 初始化一个列表，用于保存遍历序列</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="comment">//逐层推进的思路</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) &#123;<span class="comment">//不是空树</span></span><br><span class="line">        TreeNode *node = queue.<span class="built_in">front</span>();</span><br><span class="line">        queue.<span class="built_in">pop</span>();              <span class="comment">// 队列出队</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">// 保存节点值</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>)<span class="comment">//下层入队</span></span><br><span class="line">            queue.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 左子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">            queue.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 右子节点入队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>**时间复杂度 **O(n)：所有节点被访问一次，使用O(n) 时间，其中 n 为节点数量。</li>
<li>**空间复杂度 **O(n)：在最差情况下，即满二叉树时，遍历到最底层之前，队列中最多同时存在 (n+1)&#x2F;2 个节点，占用O(n) 空间。</li>
</ul>
<h4 id="前序、中序、后序遍历「深度优先遍历-depth-first-traversal」"><a href="#前序、中序、后序遍历「深度优先遍历-depth-first-traversal」" class="headerlink" title="???前序、中序、后序遍历「深度优先遍历 depth-first traversal」"></a>???前序、中序、后序遍历「深度优先遍历 depth-first traversal」</h4><p>前序：中左右<br>中序：左中右顺序<br>后序：左右中</p>
<p><img src="https://www.hello-algo.com/chapter_tree/binary_tree_traversal.assets/binary_tree_dfs.png"></p>
<p>深度优先搜索通常基于递归实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 前序遍历 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">preOrder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">preOrder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 中序遍历 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span></span><br><span class="line">    <span class="built_in">inOrder</span>(root-&gt;left);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">inOrder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 后序遍历 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span></span><br><span class="line">    <span class="built_in">postOrder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">postOrder</span>(root-&gt;right);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>深度优先搜索也可以基于迭代实现，有兴趣的同学可以自行研究。</p>
<p>以下是前序遍历二叉树的递归过程，其可分为“递”和“归”两个逆向的部分。</p>
<ol>
<li>“递”表示开启新方法，程序在此过程中访问下一个节点。</li>
<li>“归”表示函数返回，代表当前节点已经访问完毕。</li>
</ol>
<p><img src="/image/image_smmUSu-iBY.png"></p>
<ul>
<li>**时间复杂度 O(n)**：所有节点被访问一次，使用 <strong>O(n)</strong> 时间。</li>
<li>**空间复杂度 O(n)**：在最差情况下，即树退化为链表时，递归深度达到 n，系统占用 <strong>O(n)</strong> 栈帧空间。</li>
</ul>
<h3 id="二叉树数组实现"><a href="#二叉树数组实现" class="headerlink" title="二叉树数组实现"></a>二叉树数组实现</h3><h4 id="x20-表示完美二叉树"><a href="#x20-表示完美二叉树" class="headerlink" title="&#x20;表示完美二叉树"></a>&#x20;表示完美二叉树</h4><p>将所有节点按照层序遍历的顺序存储在一个数组中，则每个节点都对应唯一数组索引。</p>
<p>根据层序遍历的特性，我们可以推导出父节点索引与子节点索引之间的“映射公式”：<strong>若节点的索引为 i ，则该节点的左子节点索引为 2i+1 ，右子节点索引为 2i+2</strong> 。next展示了各个节点索引之间的映射关系。</p>
<p><img src="https://www.hello-algo.com/chapter_tree/array_representation_of_tree.assets/array_representation_binary_tree.png"></p>
<p><strong>映射公式的角色相当于链表中的指针</strong>。给定数组中的任意一个节点，我们都可以通过映射公式来访问它的左（右）子节点。</p>
<h4 id="表示任意二叉树"><a href="#表示任意二叉树" class="headerlink" title="表示任意二叉树"></a>表示任意二叉树</h4><p>完美二叉树是一个特例，在二叉树的中间层通常存在许多 None 。由于层序遍历序列并不包含这些 None ，因此我们无法仅凭该序列来推测 None 的数量和分布位置。<strong>这意味着存在多种二叉树结构都符合该层序遍历序列</strong>。</p>
<p>next所示，给定一个非完美二叉树，上述的数组表示方法已经失效。</p>
<p><img src="https://www.hello-algo.com/chapter_tree/array_representation_of_tree.assets/array_representation_without_empty.png"></p>
<p><strong>在层序遍历序列中显式地写出所有 None</strong>处理后，层序遍历序列就可以唯一表示二叉树了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的数组表示 */</span></span><br><span class="line"><span class="comment">// 使用 int 最大值 INT_MAX 标记空位</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; tree = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, INT_MAX, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, INT_MAX, INT_MAX, <span class="number">12</span>, INT_MAX, INT_MAX, <span class="number">15</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://www.hello-algo.com/chapter_tree/array_representation_of_tree.assets/array_representation_with_empty.png"></p>
<p>值得说明的是，<strong>完全二叉树非常适合使用数组来表示</strong>。回顾完全二叉树的定义，None 只出现在最底层且靠右的位置，<strong>因此所有 None 一定出现在层序遍历序列的末尾</strong>。</p>
<p>这意味着使用数组表示完全二叉树时，可以省略存储所有 None ，非常方便。</p>
<p><img src="https://www.hello-algo.com/chapter_tree/array_representation_of_tree.assets/array_representation_complete_binary_tree.png"></p>
<p>以下代码实现了一个基于数组表示的二叉树，包括以下几种操作。</p>
<ul>
<li>给定某节点，获取它的值、左（右）子节点、父节点。</li>
<li>获取前序遍历、中序遍历、后序遍历、层序遍历序列。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 数组表示下的二叉树类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayBinaryTree</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 深度优先遍历 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, string order, vector&lt;<span class="type">int</span>&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若为空位，则返回</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">val</span>(i) == INT_MAX)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (order == <span class="string">&quot;pre&quot;</span>)</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in">val</span>(i));</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="built_in">left</span>(i), order, res);</span><br><span class="line">        <span class="comment">// 中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (order == <span class="string">&quot;in&quot;</span>)</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in">val</span>(i));</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="built_in">right</span>(i), order, res);</span><br><span class="line">        <span class="comment">// 后序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (order == <span class="string">&quot;post&quot;</span>)</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in">val</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="built_in">ArrayBinaryTree</span>(vector&lt;<span class="type">int</span>&gt; arr) &#123;</span><br><span class="line">        tree = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 节点数量 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tree.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取索引为 i 节点的值 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">val</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若索引越界，则返回 INT_MAX ，代表空位</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= <span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">return</span> tree[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取索引为 i 节点的左子节点的索引 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">left</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取索引为 i 节点的右子节点的索引 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">right</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取索引为 i 节点的父节点的索引 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">parent</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 层序遍历 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">levelOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="comment">// 直接遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">val</span>(i) != INT_MAX)</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="built_in">val</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 前序遍历 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="string">&quot;pre&quot;</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 中序遍历 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="string">&quot;in&quot;</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 后序遍历 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="string">&quot;post&quot;</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="优势与局限性"><a href="#优势与局限性" class="headerlink" title="优势与局限性"></a>优势与局限性</h4><p>二叉树的数组表示主要有以下优点。</p>
<ul>
<li>数组存储在连续的内存空间中，对缓存友好，访问与遍历速度较快。</li>
<li>不需要存储指针，比较节省空间。</li>
<li>允许随机访问节点。</li>
</ul>
<p>然而，数组表示也存在一些局限性。</p>
<ul>
<li>数组存储需要连续内存空间，因此不适合存储数据量过大的树。</li>
<li>增删节点需要通过数组插入与删除操作实现，效率较低。</li>
<li>当二叉树中存在大量 None 时，数组中包含的节点数据比重较低，空间利用率较低。</li>
</ul>
<h3 id="二叉搜索树binary-search-tree"><a href="#二叉搜索树binary-search-tree" class="headerlink" title="二叉搜索树binary search tree"></a>二叉搜索树binary search tree</h3><p>对于任意父节点：左子节点值&lt;父节点值&lt;右子节点值⇒那么，左子树中所有节点的值 &lt; 根节点的值 &lt; 右子树中所有节点的值</p>
<p><img src="/image/image__at4VQbJmK.png"></p>
<h4 id="二叉搜索树操作"><a href="#二叉搜索树操作" class="headerlink" title="二叉搜索树操作"></a>二叉搜索树操作</h4><p>1.   查找节点</p>
<p>给定目标值 <code>num</code> 。声明当前节点 <code>cur</code> ，从二叉树根节点 <code>root</code> 出发，循环比较节点值 <code>cur.val</code> 和 <code>num</code> 间大小关系</p>
<ul>
<li>若 <code>cur.val &lt; num</code> ，说明目标节点在 <code>cur</code> 的右子树中，因此执行 <code>cur = cur.right</code>&#x20;</li>
<li>若 <code>cur.val &gt; num</code> ，说明目标节点在 <code>cur</code> 的左子树中，因此执行 <code>cur = cur.left</code>&#x20;</li>
<li>若 <code>cur.val = num</code> ，说明找到目标节点，跳出循环并返回该节点</li>
</ul>
<p>二叉搜索树的查找操作与二分查找算法的工作原理一致，都是每轮排除一半情况。<strong>循环次数最多为二叉树的高度</strong>，当二叉树平衡时，时间复杂度 O(log⁡n)&#x20;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 查找节点 */</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">search</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;<span class="comment">//搜索操作的循环次数是高度2^h-1=n  =&gt; h=logn</span></span><br><span class="line">    TreeNode *cur = root;</span><br><span class="line">    <span class="comment">// 循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 目标节点在 cur 的右子树中</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &lt; num)</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        <span class="comment">// 目标节点在 cur 的左子树中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;val &gt; num)</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        <span class="comment">// 找到目标节点，跳出循环</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回目标节点</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.   插入节点</p>
<p>给定一个待插入元素 <code>num</code></p>
<ol>
<li><strong>查找插入位置</strong>：与查找操作相似，从根节点出发，根据当前节点值和 <code>num</code> 的大小关系循环向下搜索，直到越过叶节点（遍历至 None ）时跳出循环。</li>
<li><strong>在该位置插入节点</strong>：初始化节点 <code>num</code> ，将该节点置于 None 的位置。</li>
</ol>
<p><img src="https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/bst_insert.png"></p>
<ul>
<li>二叉搜索树不允许存在重复节点，否则将违反其定义。因此，若待插入节点在树中已存在，则不执行插入，直接返回。</li>
<li>为了实现插入节点，我们需要借助节点 <code>pre</code> 保存上一轮循环的节点。这样在遍历至 None 时，我们可以获取到其父节点，从而完成节点插入操作。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入节点 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若树为空，则初始化根节点</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(num);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *cur = root, *pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到重复节点，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val == num)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="comment">// 插入位置在 cur 的右子树中</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &lt; num)</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        <span class="comment">// 插入位置在 cur 的左子树中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(num);</span><br><span class="line">    <span class="keyword">if</span> (pre-&gt;val &lt; num)</span><br><span class="line">        pre-&gt;right = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pre-&gt;left = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>与查找节点相同，插入节点使用 O(log⁡n) 时间。</p>
<p>3.   删除节点</p>
<p>先在二叉树中查找到目标节点，再将其从二叉树中删除。</p>
<p>因此，我们需要根据目标节点的子节点数量，共分为 0、1 和 2 这三种情况，执行对应的删除节点操作。</p>
<p>当待删除节点的度为 0 时，表示该节点是叶节点，可以直接删除。</p>
<p><img src="https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/bst_remove_case1.png"></p>
<p>当待删除节点的度为 1 时，将待删除节点替换为其子节点即可</p>
<p><img src="https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/bst_remove_case2.png"></p>
<p>当待删除节点的度为 2 ，无法直接删除它，而需要使用一个节点替换该节点。由于要保持二叉搜索树“左 &lt; 根 &lt; 右”的性质，<strong>因此这个节点可以是右子树最小节点或左子树最大节点</strong></p>
<p>假设我们选择右子树的最小节点（即中序遍历的下一个节点）</p>
<ol>
<li>找到待删除节点在“中序遍历序列”中的下一个节点，记为 <code>tmp</code> 。</li>
<li>将 <code>tmp</code> 的值覆盖待删除节点的值，并在树中递归删除节点 <code>tmp</code> 。</li>
</ol>
<p><img src="/image/image_hinXL8r9P-.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 删除节点 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若树为空，直接提前返回</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    TreeNode *cur = root, *pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到待删除节点，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val == num)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="comment">// 待删除节点在 cur 的右子树中</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &lt; num)</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        <span class="comment">// 待删除节点在 cur 的左子树中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若无待删除节点，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 子节点数量 = 0 or 1</span></span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;left == <span class="literal">nullptr</span> || cur-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 当子节点数量 = 0 / 1 时， child = nullptr / 该子节点</span></span><br><span class="line">        TreeNode *child = cur-&gt;left != <span class="literal">nullptr</span> ? cur-&gt;left : cur-&gt;right;</span><br><span class="line">        <span class="comment">// 删除节点 cur</span></span><br><span class="line">        <span class="keyword">if</span> (cur != root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre-&gt;left == cur)</span><br><span class="line">                pre-&gt;left = child;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pre-&gt;right = child;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若删除节点为根节点，则重新指定根节点</span></span><br><span class="line">            root = child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        <span class="keyword">delete</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子节点数量 = 2</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取中序遍历中 cur 的下一个节点</span></span><br><span class="line">        TreeNode *tmp = cur-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (tmp-&gt;left != <span class="literal">nullptr</span>) &#123;<span class="comment">//没到叶节点就继续往下递（搜索操作的循环次数是高度2^h-1=n  =&gt; h=logn）</span></span><br><span class="line">            tmp = tmp-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tmpVal = tmp-&gt;val;</span><br><span class="line">        <span class="comment">// 递归删除节点 tmp</span></span><br><span class="line">        <span class="built_in">remove</span>(tmp-&gt;val);</span><br><span class="line">        <span class="comment">// 用 tmp 覆盖 cur</span></span><br><span class="line">        cur-&gt;val = tmpVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.   中序遍历有序</p>
<p>二叉树中序遍历遵循“左 → 根 → 右”的遍历顺序，而二叉搜索树满足“左子节点 &lt; 根节点 &lt; 右子节点”的大小关系。</p>
<p>这意味着在二叉搜索树中进行中序遍历时，总是会优先遍历下一个最小节点，从而得出一个重要性质：<strong>二叉搜索树的中序遍历序列是升序的</strong>。利用中序遍历升序的性质，我们在<strong>二叉搜索树中获取有序数据仅需 O(n) 时间</strong>，无须进行额外的排序操作，非常高效。</p>
<p><img src="https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/bst_inorder_traversal.png"></p>
<p>5.构建2×搜素树：递归的找中点</p>
<h4 id="二叉搜索树效率"><a href="#二叉搜索树效率" class="headerlink" title="二叉搜索树效率"></a>二叉搜索树效率</h4><p>给定一组数据，我们考虑使用数组或二叉搜索树存储。<strong>二叉搜索树各项操作的时间复杂度都是对数阶，具有稳定高效的性能表现。只有在高频添加、低频查找删除的场景下，数组比二叉搜索树效率高</strong></p>
<p><img src="/image/image_iW2pJ4sAYu.png"></p>
<p>在理想情况下，二叉搜索树是“平衡”的，这样就可以在 log⁡n 轮循环内查找任意节点。</p>
<p>在二叉搜索树中不断地插入和删除节点，可能导致二叉树退化为链表，各种操作的时间复杂度退化为 O(n)&#x20;</p>
<p><img src="https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/bst_degradation.png"></p>
<h4 id="二叉搜索树常见应用"><a href="#二叉搜索树常见应用" class="headerlink" title="二叉搜索树常见应用"></a>二叉搜索树常见应用</h4><ul>
<li>用作系统中的多级索引，实现高效的查找、插入、删除操作。</li>
<li>作为某些搜索算法的底层数据结构。</li>
<li>用于存储数据流，以保持其有序状态。</li>
</ul>
<h3 id="AVL-树-x20"><a href="#AVL-树-x20" class="headerlink" title="AVL 树&#x20;"></a>AVL 树&#x20;</h3><p>二叉树退化为链表时(不平衡时)。查，增删操作的时间复杂度从 O(h) 近似为 O(n)；<br>AVL 树「平衡二叉搜索树 balanced binary search tree」可以使失衡节点重新恢复平衡（自平衡）</p>
<p>自平衡策略：<br>平衡树的定义为任意节点左右子树高度差绝对值≤1；$|h(ltree)-h(rtree)|≤1$；(设null节点的节点高度为-1;)使每个节点存储节点高度；计算每个节点的平衡因子;从上往下找失衡节点<br>1）失衡节点$f&gt;1$；子节点$f\geq0$⇒右旋（&#x3D;0就是所谓特殊情况）<br>2）失衡节点$f&gt;1$；子节点$f&lt;0$⇒对换再右旋<br>3）失衡节点$f&lt;-1$；子节点$f\leq0$⇒左旋<br>4）失衡节点$f&lt;-1$；子节点$f&gt;0$⇒对换再左旋</p>
<p><img src="/image/image_VdnyumwKHh.png"></p>
<p><img src="/image/image_yX4BF8hzii.png"></p>
<p>右旋特例：节点 <code>child</code> 有右子节点（记为 <code>grandChild</code> ），要在右旋中添加一步：将 <code>grandChild</code> 作为 <code>node</code> 的左子节点</p>
<p><img src="/image/image_SaFp0a3H0D.png"></p>
<p>左旋特例：节点 <code>child</code> 有左子节点（记为 <code>grandChild</code> ），要在左旋中添加一步：将 <code>grandChild</code> 作为 <code>node</code> 的右子节点</p>
<p><img src="/image/image_sEPNyOfIIa.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* AVL 树节点类 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val&#123;&#125;;          <span class="comment">// 节点值</span></span><br><span class="line">    <span class="type">int</span> height = <span class="number">0</span>;     <span class="comment">// 节点高度</span></span><br><span class="line">    TreeNode *left&#123;&#125;;   <span class="comment">// 左子节点</span></span><br><span class="line">    TreeNode *right&#123;&#125;;  <span class="comment">// 右子节点</span></span><br><span class="line">    <span class="built_in">TreeNode</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TreeNode</span><span class="params">(<span class="type">int</span> x)</span> : val(x)&#123;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取平衡因子 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">balanceFactor</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空节点平衡因子为 0</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 节点平衡因子 = 左子树高度 - 右子树高度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">height</span>(node-&gt;left) - <span class="built_in">height</span>(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取节点高度 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空节点高度为 -1 ，叶节点高度为 0</span></span><br><span class="line">    <span class="keyword">return</span> node == <span class="literal">nullptr</span> ? <span class="number">-1</span> : node-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更新节点高度 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateHeight</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点高度等于最高子树高度 + 1</span></span><br><span class="line">    node-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(node-&gt;left), <span class="built_in">height</span>(node-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 右旋操作 */</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">rightRotate</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    TreeNode *child = node-&gt;left;</span><br><span class="line">    TreeNode *grandChild = child-&gt;right;<span class="comment">//处理了特殊情况</span></span><br><span class="line">    <span class="comment">// 以 child 为原点，将 node 向右旋转</span></span><br><span class="line">    child-&gt;right = node;</span><br><span class="line">    node-&gt;left = grandChild;</span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    <span class="built_in">updateHeight</span>(node);</span><br><span class="line">    <span class="built_in">updateHeight</span>(child);</span><br><span class="line">    <span class="comment">// 返回旋转后子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 左旋操作 */</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">leftRotate</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    TreeNode *child = node-&gt;right;</span><br><span class="line">    TreeNode *grandChild = child-&gt;left;</span><br><span class="line">    <span class="comment">// 以 child 为原点，将 node 向左旋转</span></span><br><span class="line">    child-&gt;left = node;</span><br><span class="line">    node-&gt;right = grandChild;</span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    <span class="built_in">updateHeight</span>(node);</span><br><span class="line">    <span class="built_in">updateHeight</span>(child);</span><br><span class="line">    <span class="comment">// 返回旋转后子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行旋转操作，使该子树重新恢复平衡 */</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">rotate</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取节点 node 的平衡因子</span></span><br><span class="line">    <span class="type">int</span> _balanceFactor = <span class="built_in">balanceFactor</span>(node);</span><br><span class="line">    <span class="comment">// 左偏树</span></span><br><span class="line">    <span class="keyword">if</span> (_balanceFactor &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">balanceFactor</span>(node-&gt;left) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 右旋</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">rightRotate</span>(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 先左旋后右旋</span></span><br><span class="line">            node-&gt;left = <span class="built_in">leftRotate</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">rightRotate</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右偏树</span></span><br><span class="line">    <span class="keyword">if</span> (_balanceFactor &lt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">balanceFactor</span>(node-&gt;right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 左旋</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">leftRotate</span>(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 先右旋后左旋</span></span><br><span class="line">            node-&gt;right = <span class="built_in">rightRotate</span>(node-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">leftRotate</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 平衡树，无须旋转，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="AVL-树常用操作"><a href="#AVL-树常用操作" class="headerlink" title="AVL 树常用操作"></a>AVL 树常用操作</h4><p>在bst基础上递归逐级返回父节点时加个自平衡操作</p>
<p>1.   插入节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入节点 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    root = <span class="built_in">insertHelper</span>(root, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 递归插入节点（辅助方法） */</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">insertHelper</span><span class="params">(TreeNode *node, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);<span class="comment">//返回上级递归函数，由父节点左右指针存储</span></span><br><span class="line">    <span class="comment">/* 1. 查找插入位置，并插入节点 */</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; node-&gt;val)</span><br><span class="line">        node-&gt;left = <span class="built_in">insertHelper</span>(node-&gt;left, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; node-&gt;val)</span><br><span class="line">        node-&gt;right = <span class="built_in">insertHelper</span>(node-&gt;right, val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> node;    <span class="comment">// 重复节点不插入，直接返回</span></span><br><span class="line">    <span class="built_in">updateHeight</span>(node); <span class="comment">// 更新节点高度</span></span><br><span class="line">    <span class="comment">/* 2. 执行旋转操作，使该子树重新恢复平衡 */</span></span><br><span class="line">    node = <span class="built_in">rotate</span>(node);</span><br><span class="line">    <span class="comment">// 返回子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> node;<span class="comment">//返回父节点递归地自平衡</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.   删除节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 删除节点 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    root = <span class="built_in">removeHelper</span>(root, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 递归删除节点（辅助方法） */</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">removeHelper</span><span class="params">(TreeNode *node, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">/* 1. 查找节点，并删除之 */</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; node-&gt;val)</span><br><span class="line">        node-&gt;left = <span class="built_in">removeHelper</span>(node-&gt;left, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; node-&gt;val)</span><br><span class="line">        node-&gt;right = <span class="built_in">removeHelper</span>(node-&gt;right, val);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">nullptr</span> || node-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            TreeNode *child = node-&gt;left != <span class="literal">nullptr</span> ? node-&gt;left : node-&gt;right;</span><br><span class="line">            <span class="comment">// 子节点数量 = 0 ，直接删除 node 并返回</span></span><br><span class="line">            <span class="keyword">if</span> (child == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> node;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 子节点数量 = 1 ，直接删除 node</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">delete</span> node;</span><br><span class="line">                node = child;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 子节点数量 = 2 ，则将中序遍历的下个节点删除，并用该节点替换当前节点</span></span><br><span class="line">            TreeNode *temp = node-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (temp-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                temp = temp-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> tempVal = temp-&gt;val;</span><br><span class="line">            node-&gt;right = <span class="built_in">removeHelper</span>(node-&gt;right, temp-&gt;val);</span><br><span class="line">            node-&gt;val = tempVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">updateHeight</span>(node); <span class="comment">// 更新节点高度</span></span><br><span class="line">    <span class="comment">/* 2. 执行旋转操作，使该子树重新恢复平衡 */</span></span><br><span class="line">    node = <span class="built_in">rotate</span>(node);</span><br><span class="line">    <span class="comment">// 返回子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.   查找节点</p>
<p>AVL 树的节点查找操作与二叉搜索树一致，不再赘述</p>
<h4 id="AVL-树典型应用"><a href="#AVL-树典型应用" class="headerlink" title="AVL 树典型应用"></a>AVL 树典型应用</h4><ul>
<li>组织和存储大型数据，适用于高频查找、低频增删的场景。</li>
<li>用于构建数据库中的索引系统。</li>
<li>红黑树在许多应用中比 AVL 树更受欢迎。这是因为红黑树的平衡条件相对宽松，在红黑树中插入与删除节点所需的旋转操作相对较少，其节点增删操作的平均效率更高。</li>
</ul>

      
    </div>

    
    
    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeinsshiri.github.io/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BEbinary%20search;logn/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BEbinary%20search;logn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zeins_XvJin_Shiri">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeins's Blog">
      <meta itemprop="description" content="在何处付出，便在何处收获">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeins's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BEbinary%20search;logn/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BEbinary%20search;logn/" class="post-title-link" itemprop="url">二分查找binary search;logn&#x20;</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-07 17:18:48" itemprop="dateCreated datePublished" datetime="2024-02-07T17:18:48+08:00">2024-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-08 16:40:45" itemprop="dateModified" datetime="2024-02-08T16:40:45+08:00">2024-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构&算法</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>一种减治策略：适用于数据结构的元素本身存在序结构（依靠序结构比较中点减小子问题规模的）；减治在进入每一层都应该有个判断</p>
<h1 id="二分查找值"><a href="#二分查找值" class="headerlink" title="二分查找值"></a>二分查找值</h1><p>1）在数据集里搜索目标元素&#x3D;与中间值比较+前一半元素里搜索目标元素+在后一半元素里搜索目标元素<br>2）通过目标元素与中间值的比较减小子问题规模(意味着适用于存在序结构的数据结构：数组)<br>3）重复以上过程，直到目标元素&#x3D;中间值则找到，否则不存在此元素</p>
<p><img src="/image/image_5Smw1tU37i.png"></p>
<p><img src="/image/image_uED40DzVyU.png"></p>
<p><img src="/image/image_Cv13rw35rs.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二分查找（双闭区间） */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化双闭区间 [0, n-1] ，即 i, j 分别指向数组首元素、尾元素</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 循环，当搜索区间为空时跳出（当 i &gt; j 时为空）</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> m = i + (j - i) / <span class="number">2</span>; <span class="comment">// 计算中点索引 m</span></span><br><span class="line">        <span class="keyword">if</span> (nums[m] &lt; target)    <span class="comment">// 此情况说明 target 在区间 [m+1, j] 中</span></span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &gt; target) <span class="comment">// 此情况说明 target 在区间 [i, m-1] 中</span></span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 找到目标元素，返回其索引</span></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到目标元素，返回 -1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;<span class="comment">//这个双闭区间实现听说在无符号int数组上有坑；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=========================================以下为递归实现=====================================</span><br><span class="line"><span class="comment">/* 二分查找：问题 f(i, j) */</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">dfs</span>(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target, <span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line">    <span class="comment">// 若区间为空，代表无目标元素，则返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; j) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算中点索引 m</span></span><br><span class="line">    <span class="type">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[m] &lt; target) &#123;</span><br><span class="line">        <span class="comment">// 递归子问题 f(m+1, j)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(nums, target, m + <span class="number">1</span>, j);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &gt; target) &#123;</span><br><span class="line">        <span class="comment">// 递归子问题 f(i, m-1)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(nums, target, i, m - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到目标元素，返回其索引</span></span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 二分查找 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 求解问题 f(0, n-1)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(nums, target, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度 O(log⁡n)</strong> ：在二分循环中，区间每轮缩小一半，最坏情况经过h轮判断$\frac{1}{2}^{h}n&#x3D;1$逼近到最后一个元素；循环次数为 到logn&#x20;<br><strong>空间复杂度 O(1)</strong> ：指针 i和 j使用常数大小空间。</p>
<p>优点：二分查找在时间和空间方面都有较好性能</p>
<ul>
<li><strong>大数据量下，对数阶时间复杂度有显著优势</strong>。例如，当数据大小 n&#x3D;2^20 时，线性查找需要 2^20&#x3D;1048576 轮循环，而二分查找仅需 log2^20&#x3D;20 轮循环。</li>
<li>二分查找无须额外空间。相较于需要借助额外空间的搜索算法（例如哈希查找），二分查找更加节省空间。</li>
</ul>
<p>局限性:并非适用于所有情况</p>
<ul>
<li>二分查找仅适用于有序数据。若输入数据无序，为使用二分查找而专门进行排序(通常为 O(nlog⁡n) )，得不偿失。<br>对于频繁插入元素的场景，为保持数组有序性，需要将元素插入到特定位置，时间复杂度为 O(n) ，也是非常昂贵的。</li>
<li>二分查找仅适用于数组。二分查找需要跳跃式（非连续地）访问元素，而在链表中执行跳跃式访问的效率较低，因此不适合应用在链表或基于链表实现的数据结构。</li>
<li>小数据量下，线性查找性能更佳。在线性查找中，每轮只需要 1 次判断操作；而在二分查找中，需要 1 次加法、1 次除法、1 ~ 3 次判断操作、1 次加法（减法），共 4 ~ 6 个单元操作；因此，当数据量 n 较小时，线性查找反而比二分查找更快。</li>
</ul>
<h1 id="二分查找插入点"><a href="#二分查找插入点" class="headerlink" title="二分查找插入点"></a>二分查找插入点</h1><p>二分查找不仅可用于搜索目标元素，还具有许多变种问题，比如搜索目标元素的插入位置，其实不如说这种减治策略可运用在多种场合</p>
<h2 id="无重复元素"><a href="#无重复元素" class="headerlink" title="无重复元素"></a>无重复元素</h2><p><img src="/image/image_zva3ro86VA.png"></p>
<p>数组原先无重复元素：应用二分查找<br>1）有相同元素→返回索引<br>2）无相同元素；不可避免的进入最后一次i&#x3D;j的循环;i&#x3D;j&#x3D;mid&lt;target,i左移；i&#x3D;j&#x3D;mid&gt;target,j右移；这意味着i总指向第一个大于target的元素（这个元素占据了i应该呆的位置）；返回i即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二分查找插入点（无重复元素） */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearchInsertionSimple</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 初始化双闭区间 [0, n-1]</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> m = i + (j - i) / <span class="number">2</span>; <span class="comment">// 计算中点索引 m</span></span><br><span class="line">        <span class="keyword">if</span> (nums[m] &lt; target) &#123;</span><br><span class="line">            i = m + <span class="number">1</span>; <span class="comment">// target 在区间 [m+1, j] 中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &gt; target) &#123;</span><br><span class="line">            j = m - <span class="number">1</span>; <span class="comment">// target 在区间 [i, m-1] 中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m; <span class="comment">// 找到 target ，返回插入点 m</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到 target ，返回插入点 i</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="有重复元素"><a href="#有重复元素" class="headerlink" title="有重复元素"></a>有重复元素</h2><p><img src="/image/image_6At8wB_J6T.png"></p>
<p>若原先数组是允许存在多个重复元素的，那么可能有多个target，用上述方法只能返回其中一个的索引</p>
<ol>
<li>执行二分查找，得到任意一个 <code>target</code> 的索引，记为 k 。</li>
<li>从索引 k 开始，向左进行线性遍历，当找到最左边的 <code>target</code> 时返回。</li>
</ol>
<p>当数组中存在很多重复的 <code>target</code> 时，因为包含线性查找，此方法效率很低O(n)</p>
<p>新方法：这意味着解决的问题不同；在找到了target后要再找最左边的target或第一个小于target的元素<br>1）若target存在，返回最左target的索引<br>2）若target不存在，返回首个大于target的索引</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二分查找插入点（存在重复元素） */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearchInsertion</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 初始化双闭区间 [0, n-1]</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> m = i + (j - i) / <span class="number">2</span>; <span class="comment">// 计算中点索引 m</span></span><br><span class="line">        <span class="keyword">if</span> (nums[m] &lt; target) &#123;</span><br><span class="line">            i = m + <span class="number">1</span>; <span class="comment">// target 在区间 [m+1, j] 中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &gt; target) &#123;</span><br><span class="line">            j = m - <span class="number">1</span>; <span class="comment">// target 在区间 [i, m-1] 中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//到这里意味着找到第一个target,j左移排除掉（m-1,?)上的target，继续进入循环在[i,m-1]中寻找target直到找到最后一个target,j左移使j&lt;i跳出循环；此时j指向首个小于target的索引，而i=j+1正好是改插入的地方</span></span><br><span class="line">            j = m - <span class="number">1</span>; <span class="comment">// </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回插入点 i</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/image/image_TVRSctpud1.png"></p>
<p><img src="/image/image_ijjylMX6Z4.png"></p>
<p><img src="/image/image_rrhQsY3rZr.png"></p>
<h1 id="二分查找边界"><a href="#二分查找边界" class="headerlink" title="二分查找边界"></a>二分查找边界</h1><p>上述方法：找不到target返回插入点；找到target返回左边界（最左target）作为插入点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二分查找最左一个 target */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearchLeftEdge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等价于查找 target 的插入点</span></span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">binarySearchInsertion</span>(nums, target);</span><br><span class="line">    <span class="comment">// 未找到 target ，返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (i == nums.<span class="built_in">size</span>() || nums[i] != target) &#123;<span class="comment">//</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到 target ，返回索引 i</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修改为i右移排除target直到找到有边界，这是一种方法</p>
<p>更巧妙的方法是用这个找最左插入点的函数找最左target+1；那么返回的索引减1就是target的右边界</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二分查找最右一个 target */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearchRightEdge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 转化为查找最左一个 target + 1</span></span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">binarySearchInsertion</span>(nums, target + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// j 指向最右一个 target ，i 指向首个大于 target 的元素</span></span><br><span class="line">    <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 未找到 target ，返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">-1</span> || nums[j] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到 target ，返回索引 j</span></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当数组不包含 <code>target</code> 时，最终 i和 j会分别指向首个大于、小于 <code>target</code> 的元素。</p>
<p>所以，可以构造一个数组中不存在的元素，用于查找左右边界。</p>
<ul>
<li>查找最左一个 <code>target</code> ：可以转化为查找 <code>target - 0.5</code> ，并返回指针 i。</li>
<li>查找最右一个 <code>target</code> ：可以转化为查找 <code>target + 0.5</code> ，并返回指针 j。</li>
</ul>
<p><img src="https://www.hello-algo.com/chapter_searching/binary_search_edge.assets/binary_search_edge_by_element.png"></p>
<p>注意以下两点：</p>
<ul>
<li>给定数组不包含小数，这意味着我们无须关心如何处理相等的情况。</li>
<li>因为该方法引入了小数，所以需要将函数中的变量 <code>target</code> 改为浮点数类型。</li>
</ul>
<p><strong>二分查找</strong></p>
<ul>
<li>适用于大数据量的情况，效率表现稳定，最差时间复杂度为 O(log⁡n) 。</li>
<li>数据量不能过大，因为存储数组需要连续的内存空间。</li>
<li>不适用于高频增删数据的场景，因为维护有序数组的开销较大。</li>
</ul>

      
    </div>

    
    
    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeinsshiri.github.io/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&%E7%AE%97%E6%B3%95/%E5%88%86%E6%95%B0%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/%E5%88%86%E6%95%B0%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zeins_XvJin_Shiri">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeins's Blog">
      <meta itemprop="description" content="在何处付出，便在何处收获">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeins's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&%E7%AE%97%E6%B3%95/%E5%88%86%E6%95%B0%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/%E5%88%86%E6%95%B0%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">分数背包问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-07 17:18:48" itemprop="dateCreated datePublished" datetime="2024-02-07T17:18:48+08:00">2024-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-08 16:40:33" itemprop="dateModified" datetime="2024-02-08T16:40:33+08:00">2024-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构&算法</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/image/image_jVwE5Ci7ry.png"></p>
<p>分数背包和 0-1 背包整体上非常相似；不同点在于，允许只选择物品的一部分。<strong>可对物品任意地进行切分，并按照重量比例来计算物品价值</strong>。<br>贪心策略：先用单位重量最高的物品填入背包</p>
<ol>
<li>物品从单位价值高到低排序</li>
<li>遍历物品，<strong>每轮选择单位价值最高的物品</strong>填入背包。（每轮进行一次局部最优填入）</li>
<li>若剩余背包容量不足，则用当前物品一部分填满背包。</li>
</ol>
<p><img src="/image/image_BzF8eNPdBC.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 物品 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> w; <span class="comment">// 物品重量</span></span><br><span class="line">    <span class="type">int</span> v; <span class="comment">// 物品价值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Item</span>(<span class="type">int</span> w, <span class="type">int</span> v) : <span class="built_in">w</span>(w), <span class="built_in">v</span>(v) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分数背包：贪心 */</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">fractionalKnapsack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;wgt, vector&lt;<span class="type">int</span>&gt; &amp;val, <span class="type">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建物品列表，包含两个属性：重量、价值</span></span><br><span class="line">    vector&lt;Item&gt; items;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; wgt.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        items.<span class="built_in">push_back</span>(<span class="built_in">Item</span>(wgt[i], val[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按照单位价值 item.v / item.w 从高到低进行排序;序结构定义函数</span></span><br><span class="line">    <span class="built_in">sort</span>(items.<span class="built_in">begin</span>(), items.<span class="built_in">end</span>(), [](Item &amp;a, Item &amp;b) &#123; <span class="built_in">return</span> (<span class="type">double</span>)a.v / a.w &gt; (<span class="type">double</span>)b.v / b.w; &#125;);</span><br><span class="line">    <span class="comment">// 循环贪心选择</span></span><br><span class="line">    <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : items) &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.w &lt;= cap) &#123;</span><br><span class="line">            <span class="comment">// 若剩余容量充足，则将当前物品整个装进背包</span></span><br><span class="line">            res += item.v;</span><br><span class="line">            cap -= item.w;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若剩余容量不足，则将当前物品的一部分装进背包</span></span><br><span class="line">            res += (<span class="type">double</span>)item.v / item.w * cap;</span><br><span class="line">            <span class="comment">// 已无剩余容量，因此跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最差情况下，需要遍历整个物品列表，<strong>因此时间复杂度为 O(n)</strong> ，排序用了**O(n)**；其中 n 为物品数量。</p>
<p>由于初始化了一个 <code>Item</code> 对象列表，<strong>因此空间复杂度为O(n)</strong></p>
<h3 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h3><p>反证法：假设每轮填入单位最大价值物品所得并不一定是全局最优解；<br>⇒假设得到全局最优解时，不一定每轮填入单位最大价值物品<br>⇒假设得到全局最优解时，不一定会填入单位价值最高的物品x&#x20;<br>假设物品 x 是单位价值最高的物品，使用某算法求得最大价值为 <code>res</code> ，但该解中不包含物品 x 。</p>
<p>现在从背包中拿出单位重量的任意物品，并替换为单位重量的物品 x 。由于物品 x 的单位价值最高，因此替换后的总价值一定大于 <code>res</code> 。<strong>这与 <strong><strong><code>res</code></strong></strong> 是最优解矛盾，说明最优解中必须包含物品 x</strong>&#x20;</p>
<p>对于该解中的其他物品，我们也可以构建出上述矛盾。总而言之，<strong>单位价值更大的物品总是更优选择</strong>，这说明贪心策略是有效的。</p>

      
    </div>

    
    
    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2024-02 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Zeins_XvJin_Shiri</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">330k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:01</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">
    <!--由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动 -->
  </div>

<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("03/01/2023 10:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>
    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/zeinsshiri/" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"mhchem":false,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script src="/js/third-party/comments/livere.js"></script>

  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  

  
  
    <script src="/js/cursor/fireworks.js"></script>
  

  
  
<style>
#selectionCopyright {
    position: absolute;
    display: none;
    background: rgba(244,67,54,.7);
    color: #fff;
    border-radius: 6px;
    box-shadow: none;
    border: none;
    font-size: 14px;
}
#selectionCopyright a{
    color:#fff;
    border-color: #fff;
}
#selectionCopyright::before {
    content: "";
    width: 0;
    height: 0;
    border-style: solid;
    border-width: 6px 8px 6px 0;
    border-color: transparent rgba(244,67,54,.7) transparent transparent;
    position: absolute;
    left: -8px;
    top:50%;
    transform:translateY(-50%);
}
</style>

<button id="selectionCopyright" disabled="disabled">本文由Zeins原创并遵循CC4.0，转载请注明出处并链接回原文地址哟</button>

<script>
window.onload = function() {
    function selectText() {
        if (document.selection) { //IE浏览器下
            return document.selection.createRange().text; //返回选中的文字
        } else { //非IE浏览器下
            return window.getSelection().toString(); //返回选中的文字
        }
    }
    var content = document.getElementsByTagName("body")[0];
    var scTip = document.getElementById('selectionCopyright');

    content.onmouseup = function(ev) { //设定一个onmouseup事件
        var ev = ev || window.event;
        var left = ev.clientX;//获取鼠标相对浏览器可视区域左上角水平距离距离
        var top = ev.clientY;//获取鼠标相对浏览器可视区域左上角垂直距离距离
        var xScroll = Math.max(document.body.scrollLeft, document.documentElement.scrollLeft);//获取文档水平滚动距离
        var yScroll = Math.max(document.body.scrollTop, document.documentElement.scrollTop);//获取文档垂直滚动距离
        if (selectText().length > 0) {
            setTimeout(function() { //设定一个定时器
                scTip.style.display = 'inline-block';
                scTip.style.left = left + xScroll + 15 + 'px';//鼠标当前x值
                scTip.style.top = top + yScroll - 15 + 'px';//鼠标当前y值
            }, 100);
        } else {
            scTip.style.display = 'none';
        }
    };

    content.onclick = function(ev) {
        var ev = ev || window.event;
        ev.cancelBubble = true;
    };
    document.onclick = function() {
        scTip.style.display = 'none';
    };
};
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":290},"mobile":{"show":false},"react":{"opacityDefault":1,"opacityOnHover":1},"log":false,"tagMode":false});</script></body>
</html>


