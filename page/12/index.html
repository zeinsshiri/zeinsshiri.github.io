<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"zeinsshiri.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>


    <meta name="description" content="在何处付出，便在何处收获">
<meta property="og:type" content="website">
<meta property="og:title" content="Zeins&#39;s Blog">
<meta property="og:url" content="https://zeinsshiri.github.io/page/12/">
<meta property="og:site_name" content="Zeins&#39;s Blog">
<meta property="og:description" content="在何处付出，便在何处收获">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Zeins_XvJin_Shiri">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zeinsshiri.github.io/page/12/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/12/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Zeins's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/rss2.xml" title="Zeins's Blog" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Zeins's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">笔记直接导入的，排版稍差，得有时间再处理</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zeins_XvJin_Shiri"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Zeins_XvJin_Shiri</p>
  <div class="site-description" itemprop="description">在何处付出，便在何处收获</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">134</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zeinsshiri/" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zeinsshiri&#x2F;" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:Rennai10000@outlook.com" title="E-Mail → mailto:Rennai10000@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Zeins_x_Shiri" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Zeins_x_Shiri" rel="noopener me" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="rss fa-fw"></i>RSS</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeinsshiri.github.io/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/linux-cmd/linux-cmd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zeins_XvJin_Shiri">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeins's Blog">
      <meta itemprop="description" content="在何处付出，便在何处收获">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeins's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/linux-cmd/linux-cmd/" class="post-title-link" itemprop="url">linux-cmd</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-07 17:18:48" itemprop="dateCreated datePublished" datetime="2024-02-07T17:18:48+08:00">2024-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-08 16:31:08" itemprop="dateModified" datetime="2024-02-08T16:31:08+08:00">2024-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BD%AF%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">软件</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>linux-cmd程序大都基于系统函数实现</p>
<h2 id="shell特性"><a href="#shell特性" class="headerlink" title="shell特性"></a>shell特性</h2><p>shell应用程序：提供命令交互方式获取用户输入，并显示程序的执行结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1)shell启动脚本:</span><br><span class="line">∼/.bashrc</span><br><span class="line"></span><br><span class="line">2)启用补齐（大都默认加入了∼/.bashrc）:</span><br><span class="line"><span class="built_in">source</span> /etc/bash_completion      </span><br><span class="line"></span><br><span class="line">3)cmd历史</span><br><span class="line"><span class="built_in">history</span></span><br><span class="line"></span><br><span class="line">4）</span><br><span class="line">创建终端标签 Ctrl + Shift + t</span><br><span class="line">切换标签 Alt+n</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h2><h3 id="目录-文件操作"><a href="#目录-文件操作" class="headerlink" title="目录&#x2F;文件操作"></a>目录&#x2F;文件操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">1）列出</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"><span class="built_in">ls</span> -a</span><br><span class="line"><span class="built_in">ls</span> -R        //连同子目录列出</span><br><span class="line">ll</span><br><span class="line"></span><br><span class="line">2）查看路径</span><br><span class="line"><span class="built_in">cd</span> -        // 进入上次目录</span><br><span class="line"><span class="built_in">cd</span> ~        // 进入家目录</span><br><span class="line"><span class="built_in">which</span>        //查看指定命令路径<span class="built_in">which</span> <span class="built_in">ls</span></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line"></span><br><span class="line">3)创建/删除</span><br><span class="line"><span class="built_in">mkdir</span></span><br><span class="line"><span class="built_in">rmdir</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">touch</span>          //创建文件或更新时间</span><br><span class="line"><span class="built_in">rm</span>             //Delete the file</span><br><span class="line"><span class="built_in">rm</span> -rf   </span><br><span class="line"></span><br><span class="line">4）重命名/移动文件</span><br><span class="line"><span class="built_in">mv</span> f1 f2       //重命名</span><br><span class="line"><span class="built_in">mv</span> f1 ~/       //移动</span><br><span class="line"></span><br><span class="line">5）拷贝</span><br><span class="line"><span class="built_in">cp</span> f1 ../</span><br><span class="line"><span class="built_in">cp</span> f1 f2       //f1拷贝为f2</span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> dir1 dir2 -r  //Copy the directory</span><br><span class="line"><span class="built_in">cp</span> dir1 ~/ -r</span><br><span class="line"></span><br><span class="line">6) 查看数据块内的文件内容</span><br><span class="line"><span class="built_in">cat</span></span><br><span class="line">more            //单屏查看</span><br><span class="line"><span class="built_in">head</span> -5 f1            //查看头5行</span><br><span class="line"><span class="built_in">tail</span> -5 f1      //查看末5行</span><br><span class="line"></span><br><span class="line">tree            //树形显示，要查看目录文件数据块中的下属文件哈希表（inode:name）</span><br><span class="line"></span><br><span class="line">7）查看数据块内的文件头</span><br><span class="line">file -bcvz -f hello.c     //查看文件格式类型；-L 直接显示符号连接所指向的文件的类别；-m&lt;魔法数字文件&gt; 　指定魔法数字文件；-z 尝试解读压缩文件内容</span><br><span class="line"></span><br><span class="line">8）查看文件Inode</span><br><span class="line"><span class="built_in">stat</span> f1         //查看文件f1的Inode</span><br><span class="line"></span><br><span class="line"><span class="built_in">du</span> -hk ./*             //查看目录大小,以K为单位</span><br><span class="line"></span><br><span class="line"><span class="built_in">wc</span> -l f1              //读取文件行数</span><br><span class="line"><span class="built_in">wc</span> -c f1              //读取文件字节数</span><br><span class="line"><span class="built_in">wc</span> –bytes f1</span><br><span class="line"><span class="built_in">wc</span> –chars f1</span><br><span class="line"><span class="built_in">wc</span> -w f1              //读取文件”字长“数</span><br><span class="line"></span><br><span class="line">9）查看文件系统（查看磁盘）</span><br><span class="line"><span class="built_in">df</span> --block-size=GB      //查看磁盘使用情况</span><br><span class="line"><span class="built_in">df</span> --block-size=MB </span><br><span class="line"></span><br><span class="line">10）链接（软：快捷方式；硬：副本链接）</span><br><span class="line"><span class="built_in">touch</span> f1</span><br><span class="line"><span class="built_in">ln</span> f1 f_hard       //f_hard为f1的硬链接文件；不同名但有相同incode</span><br><span class="line"><span class="built_in">ln</span> -s f1 f_soft    //ls -li可显示出软链接文件具有不同incode;但f_soft的incode指向数据块存放的是f1的路径名；（类比快捷方式）</span><br></pre></td></tr></table></figure>

<h3 id="文件属性-用户（组）管理"><a href="#文件属性-用户（组）管理" class="headerlink" title="文件属性&#x2F;用户（组）管理"></a>文件属性&#x2F;用户（组）管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1）文件权限/所属管理</span><br><span class="line"><span class="built_in">chmod</span> 777 f1                        //用户-同组-其他的权限rwx-rwx-rwx</span><br><span class="line"></span><br><span class="line">sudo <span class="built_in">chown</span> -Rv user2:group2 f1      //f1改变为user2和group2所有</span><br><span class="line">sudo <span class="built_in">chgrp</span> xvjin f1                  //f1改变为xvjin组所有</span><br><span class="line"></span><br><span class="line"><span class="built_in">umask</span>                        //创建文件时的默认权限掩码</span><br><span class="line"><span class="built_in">umask</span> 0022                  //将文件权限掩码设置为 0022，000-010-010;表示新创建的文件对组用户屏蔽写权限&amp;~<span class="built_in">umask</span></span><br><span class="line"><span class="built_in">umask</span> -S</span><br><span class="line"></span><br><span class="line">2）用户（组）管理</span><br><span class="line"><span class="built_in">who</span>           //查看用户列表</span><br><span class="line"><span class="built_in">whoami</span>        //查看登录用户</span><br><span class="line"><span class="built_in">cd</span> /home &amp;&amp; <span class="built_in">ls</span>         //查看用户/用户组</span><br><span class="line"></span><br><span class="line">sudo adduser -g mygroup -G g2,root -d /home/xvjin -m xvjin     //添加用户xvjin：-g mygroup指定属于mygroup 组；-d /home/xvjin -m指定创建用户家目录;-G g2,root指定其还属于g2,root组</span><br><span class="line">sudo deluser -r xvjin     //删除用户</span><br><span class="line"></span><br><span class="line">sudo addgoup xvjin     //添加用户组</span><br><span class="line">sudo delgroup xvjin     //删除用户组</span><br><span class="line"></span><br><span class="line">su xvjin               //切换用户</span><br><span class="line">sudo su                 //切换为root用户</span><br><span class="line"></span><br><span class="line">sudo passwd xvjin      //设置密码</span><br><span class="line">passwd                 //设置root密码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h3><p>-type</p>
<p><img src="/image/image_jWUUhpsMZO.png"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">1）搜文件</span><br><span class="line">find / -name <span class="string">&#x27;f*&#x27;</span>    //找根目录下f开头的</span><br><span class="line">find / -<span class="built_in">type</span> l      //找根目录下的软链接</span><br><span class="line">find / -maxdepth 1 -name <span class="string">&#x27;f*&#x27;</span>    //找根目录下f开头的文件，搜索深度为1</span><br><span class="line">find / -size +20M -size -50M    //找根目录下找大于20M,小于50M的</span><br><span class="line">find / -ctime 1      //找根目录下修改时间在1D以内的</span><br><span class="line">find /usr/ -name <span class="string">&quot;*tmp*&quot;</span> -<span class="built_in">exec</span> <span class="built_in">ls</span> -l &#123; &#125; \;       //搜索含tmp字样文件；每个参数传给&#123;&#125;；对每个参数启动新的 <span class="built_in">ls</span> -l 进程；-<span class="built_in">exec</span>的交互版-ok</span><br><span class="line">find /usr/ -name <span class="string">&quot;*tmp*&quot;</span> | xargs grep <span class="string">&quot;printf&quot;</span>       //| xargs把find的输出转换为参数集传递给grep <span class="string">&quot;printf&quot;</span>命令</span><br><span class="line">find /usr/ -name <span class="string">&quot;*tmp*&quot;</span> -print0 | xargs -0 grep <span class="string">&quot;printf&quot;</span>     //-print0表示以null作为参数间隔标记</span><br><span class="line"></span><br><span class="line">2）搜内容</span><br><span class="line">grep ‘<span class="built_in">printf</span>’ /usr/include -R -I -n //在头文件目录下查找包含<span class="built_in">printf</span>的文件;-R递归；-n显示行号；-I不区分大小写</span><br><span class="line">grep </span><br><span class="line">grep -nc <span class="string">&quot;this&quot;</span> demo_file     //从单个文件中查找指定的字符串</span><br><span class="line">sudo grep -nc <span class="string">&quot;this&quot;</span> demo_*        //从多个文件中查找指定的字符串</span><br><span class="line">grep -l <span class="string">&#x27;root&#x27;</span> /etc/fstab /etc/passwd /etc/mtab  //打印有root内容的文件名</span><br><span class="line">grep -vnc <span class="string">&#x27;nobody&#x27;</span> /etc/passwd           //打印没有内容nobody的行</span><br><span class="line">grep -nc ^backup /etc/passwd              //打印以 “backup” 开头的行</span><br><span class="line">grep -nc bash$ /etc/passwd             //打印以 “bash” 结尾的行</span><br><span class="line">sudo grep -rnc nobody /etc             //递归查找</span><br><span class="line">grep -inc IP_Forward /etc/sysctl.conf     //忽略大小写</span><br><span class="line">sudo sysctl -a | grep -wnc <span class="string">&#x27;vm.swappiness&#x27;</span>    //仅匹配整个单词</span><br><span class="line">grep -nc -e nobody -e mail /etc/passwd         //搜索多个</span><br><span class="line">grep -nc -E <span class="string">&quot;nobody|mail&quot;</span> /etc/passwd</span><br><span class="line"></span><br><span class="line">grep -nc -f grep_pattern /etc/passwd           //搜索规则文件中的内容；grep_pattern文件中内容： </span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> grep_pattern</span><br><span class="line">^linuxtechi</span><br><span class="line">root</span><br><span class="line"><span class="literal">false</span>$</span><br><span class="line">$</span><br><span class="line"></span><br><span class="line">grep -nc -B 4 <span class="string">&quot;games&quot;</span> /etc/passwd             //打印在模式匹配之前的四行</span><br><span class="line">grep -nc -A 4 <span class="string">&quot;games&quot;</span> /etc/passwd             //打印在模式匹配后四行</span><br><span class="line">grep -nc -C 4 <span class="string">&quot;games&quot;</span> /etc/passwd             //打印在模式匹配周围四行</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_36602427/article/details/86551862" title="   https://blog.csdn.net/baidu_36602427/article/details/86551862">   https://blog.csdn.net/baidu_36602427&#x2F;article&#x2F;details&#x2F;86551862</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_48016395/article/details/123197489#:~:text=sudo%20apt-get%20install%20package%20%E5%AE%89%E8%A3%85%E5%8C%85%20sudo%20apt-get%20remove,search%20package%20%E6%90%9C%E7%B4%A2%E8%BD%AF%E4%BB%B6%E5%8C%85%20sudo%20apt-cache%20show%20package%20%E8%8E%B7%E5%8F%96%E5%8C%85%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%A6%82%E8%AF%B4%E6%98%8E%E3%80%81%E5%A4%A7%E5%B0%8F%E3%80%81%E7%89%88%E6%9C%AC%E7%AD%89" title=" Ubuntu使用apt管理安装软件包_ubuntu安装apt_白白甜甜冰的博客-CSDN博客 一、apt简介 apt 是 Advanced Packaging Tool 的简称，是一款安装包管理工具。在 Ubuntu 下，我们可以使用 apt 命令可用于软件包的安装、删除、清理等，类似于 Windows 中的软件管理工具。 二、apt管理软件包的相关命令sudo apt-get update 更新源sudo apt-get install package 安装包 sudo apt-get  https://blog.csdn.net/weixin_48016395/article/details/123197489#:~:text=sudo%20apt-get%20install%20package%20%E5%AE%89%E8%A3%85%E5%8C%85%20sudo%20apt-get%20remove,search%20package%20%E6%90%9C%E7%B4%A2%E8%BD%AF%E4%BB%B6%E5%8C%85%20sudo%20apt-cache%20show%20package%20%E8%8E%B7%E5%8F%96%E5%8C%85%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%A6%82%E8%AF%B4%E6%98%8E%E3%80%81%E5%A4%A7%E5%B0%8F%E3%80%81%E7%89%88%E6%9C%AC%E7%AD%89"> Ubuntu使用apt管理安装软件包_ubuntu安装apt_白白甜甜冰的博客-CSDN博客 一、apt简介 apt 是 Advanced Packaging Tool 的简称，是一款安装包管理工具。在 Ubuntu 下，我们可以使用 apt 命令可用于软件包的安装、删除、清理等，类似于 Windows 中的软件管理工具。 二、apt管理软件包的相关命令sudo apt-get update 更新源sudo apt-get install package 安装包 sudo apt-get  https://blog.csdn.net/weixin_48016395&#x2F;article&#x2F;details&#x2F;123197489#:~:text&#x3D;sudo%20apt-get%20install%20package%20%E5%AE%89%E8%A3%85%E5%8C%85%20sudo%20apt-get%20remove,search%20package%20%E6%90%9C%E7%B4%A2%E8%BD%AF%E4%BB%B6%E5%8C%85%20sudo%20apt-cache%20show%20package%20%E8%8E%B7%E5%8F%96%E5%8C%85%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%A6%82%E8%AF%B4%E6%98%8E%E3%80%81%E5%A4%A7%E5%B0%8F%E3%80%81%E7%89%88%E6%9C%AC%E7%AD%89</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/apt/sources.list                 //修改软件源（包存储服务器）</span><br><span class="line">apt-get update                            //更新源</span><br><span class="line"></span><br><span class="line">apt-cache search sqlite                      //搜索软件包</span><br><span class="line">apt-cache show sqlite                       //获取包的相关信息，如说明、大小、版本等</span><br><span class="line"></span><br><span class="line">apt-get install sqlite                     //安装</span><br><span class="line">apt-get install sqlite --reinstall       //重新安装包</span><br><span class="line"></span><br><span class="line">apt-get upgrade                         //更新已安装的包</span><br><span class="line"></span><br><span class="line">apt-get remove sqlite                      //删除包</span><br><span class="line">apt-get remove sqlite --purge          //删除包，包括配置文件等</span><br><span class="line"></span><br><span class="line">apt-get -f install 修复安装</span><br><span class="line"></span><br><span class="line">apt-get dist-upgrade                 //升级系统</span><br><span class="line"></span><br><span class="line">//查看已安装包的小工具</span><br><span class="line">apt-get install aptitude</span><br><span class="line">aptitude show sqlite                  //查看本机sqlite包</span><br><span class="line"></span><br><span class="line"><span class="comment">#）源码安装</span></span><br><span class="line">1）</span><br><span class="line">apt-get <span class="built_in">source</span> sqlite                  //下载该包的源代码</span><br><span class="line">2）</span><br><span class="line">apt-cache depends sqlite               //了解使用该包依赖那些包</span><br><span class="line">apt-cache rdepends sqlite              //查看该包被哪些包依赖</span><br><span class="line">apt-get check                          //检查是否有损坏的依赖</span><br><span class="line">apt-get build-dep sqlite               //安装相关的编译环境</span><br><span class="line">apt-get clean &amp;&amp; apt-get autoclean       //清理无用的包</span><br><span class="line">3）解压</span><br><span class="line">4）<span class="built_in">cd</span> sqlite &amp;&amp; ./configure            //检测文件是否缺失，生成Makefile,检测编译环境</span><br><span class="line">5)make                                 //编译源码，生成库和可执行程序</span><br><span class="line">6）make install                        //把库和可执行程序，安装到系统路径下</span><br><span class="line">make distclean                         //删除和卸载软件</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -ah ./src            //查看路径所占用的磁盘空间；会递归列出其下各目录文件情况</span><br><span class="line"><span class="built_in">du</span> -ah src | <span class="built_in">sort</span> -nr    //按大小排序</span><br><span class="line"><span class="built_in">du</span> -sh ./src           //只显示src目录占用的磁盘空间总大小</span><br><span class="line"><span class="built_in">du</span> -h --max-depth src   //输出当前目录下各个子目录所使用的空间</span><br><span class="line"><span class="built_in">du</span> -c a.log b.log       //显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="压缩包管理"><a href="#压缩包管理" class="headerlink" title="压缩包管理"></a>压缩包管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">gz算法：</span><br><span class="line">tar zcvf xvjin.tar.gz d1 f2             //将d1，f2压缩为xvjin.tar.gz</span><br><span class="line">tar zxvf xvjin.tar.gz -C ./tmp                  //解压到tmp文件夹</span><br><span class="line"></span><br><span class="line">bz2算法:</span><br><span class="line">tar jcvf xvjin.tar.bz2 d1 f2 </span><br><span class="line">tar jxvf xvjin.tar.bz2</span><br><span class="line"></span><br><span class="line">rar:</span><br><span class="line">rar a -r newdir d1                      //将d1压缩成newdir.rar</span><br><span class="line">unrar x newdir.rar                      //解压</span><br><span class="line"></span><br><span class="line">zip:</span><br><span class="line">zip -r newdir.zip d1                      //将d1压缩成newdir.zip</span><br><span class="line">unzip newdir.zip </span><br></pre></td></tr></table></figure>

<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ps -aux                                    //进程管理器</span><br><span class="line">ps -Lf 2423                                 //显示pid为2423的进程</span><br><span class="line">ps -aux | grep chrome                       //进程过滤出chrome</span><br><span class="line">top                                      //文字UI的进程管理器</span><br><span class="line"></span><br><span class="line">//cmd+&amp;后台运行/或ctrl+z</span><br><span class="line"><span class="built_in">cat</span> &amp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">jobs</span>                                 //查看后台作业</span><br><span class="line"></span><br><span class="line"><span class="built_in">fg</span> %1                                //把挂起的作业1移到前台</span><br><span class="line"><span class="built_in">bg</span> 5893</span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span> -SIGKILL 5893                   //强制终止进程5893，适用于不能处理信号的进程</span><br><span class="line"><span class="built_in">kill</span> 5893                            //给进程5893发终止信号</span><br><span class="line"></span><br><span class="line">free -m                           //查看空闲内存</span><br><span class="line"></span><br><span class="line"><span class="built_in">env</span>                                 //环境变量列表</span><br><span class="line"><span class="built_in">export</span> PATH=./lib                   //设置当前shell进程的临时环境变量(PATH,ARCH , CROSS_COMPILE)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ifconfig                                //查看网卡信息</span><br><span class="line"></span><br><span class="line">ifconfig eth0 up                        //开启网卡eth0</span><br><span class="line">ifconfig eth0 down                       //关闭网卡</span><br><span class="line"></span><br><span class="line">ifconfig eth0 192.168.120.110          //给eth0配置临时IP</span><br><span class="line"></span><br><span class="line">ping</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="常用服务器构建"><a href="#常用服务器构建" class="headerlink" title="常用服务器构建"></a>常用服务器构建</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>man man</p>
<p><img src="/image/image_9Rgpa7aLox.png"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">命令 --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">man -k <span class="built_in">read</span> | grep transform                //以<span class="built_in">read</span>为关键字查找相关的man page，并过滤出transform 相关内容</span><br><span class="line">man 2 <span class="built_in">read</span>                            //在2section查看<span class="built_in">read</span></span><br><span class="line"></span><br><span class="line">clear                          //清屏;快捷键：Ctrl-l</span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span>                      //别名列表</span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -alh&#x27;</span>           //取别名</span><br><span class="line"></span><br><span class="line"><span class="built_in">date</span>                           //查看时间</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;text&quot;</span></span><br><span class="line"></span><br><span class="line">sudo poweroff                         //切断电源</span><br><span class="line"></span><br><span class="line">shutdown -r now                            //立刻重新开机</span><br><span class="line">shutdown -t3 -r now                            //立刻重新开机, 但在警告和删除processes 之间, 延迟3秒钟.</span><br><span class="line">reboot</span><br><span class="line"></span><br><span class="line">shutdown -h now                            //立刻关机</span><br><span class="line">shutdown -r 10 <span class="string">&#x27;Hey! Go away!&#x27;</span>          //10 分钟後关机</span><br><span class="line">shutdown -k now <span class="string">&#x27;Hey! Go away! now....&#x27;</span>          //发出警告讯息, 但没有真的关机</span><br><span class="line">shutdown -h 10:42 <span class="string">&#x27;Hey! Go away!&#x27;</span>          //10:42 分关机</span><br><span class="line"></span><br><span class="line"><span class="built_in">uname</span> -a                           //查看内核版本</span><br><span class="line"></span><br><span class="line">lsb_release -a                           //查看发行版本信息</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.查看网卡信息</span><br><span class="line">ifconfig</span><br><span class="line">2.关闭网卡</span><br><span class="line">sudo ifconfig eth0 down</span><br><span class="line">3.开启网卡eth0</span><br><span class="line">sudo ifconfig eth0 up</span><br><span class="line">4.给eth0配置临时IP</span><br><span class="line">sudo ifconfig eth0 IP</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>echo:打印字符串或者打印变量的值(比如打印出PATH),也可以echo xxx &gt; 1.txt,即进行cin操作</p>
<p>sudo gedit &#x2F;etc&#x2F;enviroment用gedit编辑器编辑环境变量,然后需要重启,sudo使普通权限用户具备管理员允许的高级权限</p>
<p><img src="/image/image_FdKS7ys3i0.png"></p>
<p>chmod xxx file_name编辑文件权限xxx是9位二进制表示的权限的十进制形式(拥有者,组,其他)</p>
<blockquote>
<p>直接键入程序名shell会去PATH找这个程序</p>
</blockquote>
<p><img src="/image/image_7VoPcJmkoq.png"></p>
<p>注意：&#x20;</p>
<p>如果没有指定查找目录，则为当前目录。</p>
<p>&#x20;</p>
<p><img src="/image/image_1aJwL6RmQh.png"></p>
<p>$ find . -name “ *.txt “    <a target="_blank" rel="noopener" href="//xn--fiqw3f.xn--mnq06f04pwfl25qw6g" title="//其中.代表当前路径">&#x2F;&#x2F;其中.代表当前路径</a>。 &#x20;</p>
<p>$ find -name “ *.txt “      &#x2F;&#x2F;没加路径，默认是当前路径下查找。&#x20;</p>
<p>find 还有一些高级的用法，如查找最近几天(几个小时)之内(之前)有变动的文件 &#x20;</p>
<p>$ find  &#x2F;home&#x2F;book  -mtime -2       &#x2F;&#x2F;查找&#x2F;home 目录下两天内有变动的文件。</p>
<p>其他命令:</p>
<p>定位</p>
<p>which   命令名&#x2F;应用程序名&#x20;<br>whereis  命令名&#x2F;应用程序名</p>
<p>设置密码</p>
<p>sudu passwd root&#x2F;book</p>
<p>su root&#x2F;book切换用户</p>

      
    </div>

    
    
    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeinsshiri.github.io/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&%E7%AE%97%E6%B3%95/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%20selection%20sort/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%20selection%20sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zeins_XvJin_Shiri">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeins's Blog">
      <meta itemprop="description" content="在何处付出，便在何处收获">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeins's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&%E7%AE%97%E6%B3%95/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%20selection%20sort/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%20selection%20sort/" class="post-title-link" itemprop="url">选择排序 selection sort</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-07 17:18:48" itemprop="dateCreated datePublished" datetime="2024-02-07T17:18:48+08:00">2024-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-08 16:34:58" itemprop="dateModified" datetime="2024-02-08T16:34:58+08:00">2024-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构&算法</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>711</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>退化分治（子问题间存在依赖，必须先解决前面的才能解决后面的）+枚举策略：<br>设数组长度 n，排序&#x3D;枚举n个数中找到最小值放在索引0+枚举剩下n-1个数中找到次小值放在索引1。。。。。。。<br>外循环缩小排序区间；内循环遍历比较,每次比较更小值留下跟后面继续比（放在一个迭代器K（目前最小值）中），内循环结束后k为本区间最小值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 选择排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 外循环：未排序区间为 [i, n-1]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;<span class="comment">//是n-1而不是n因为排序区间缩小到n-1索引时只剩一个值，就是最大值</span></span><br><span class="line">        <span class="comment">// 内循环：找到未排序区间内的最小元素</span></span><br><span class="line">        <span class="type">int</span> k = i;<span class="comment">//设最小值为k</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;<span class="comment">//从j到size-1</span></span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[k])</span><br><span class="line">                k = j; <span class="comment">// 记录最小元素的索引</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将该最小元素与未排序区间的首个元素交换</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度为 O(n^2)、非自适应排序</strong>：外循环共 n−1 轮，第一轮的未排序区间长度为 n ，最后一轮的未排序区间长度为 2 ，即各轮外循环分别包含 n、n−1、…、3、2 轮内循环，求和为 $\frac{(n−1)(n+2)}{2}$&#x20;</li>
<li><strong>空间复杂度 O(1)、原地排序</strong>：指针 i 和 j使用常数大小的额外空间。</li>
<li><strong>非稳定排序</strong>：元素 <code>nums[i]</code> 有可能被交换至与其相等的元素的右边，导致两者相对顺序发生改变。</li>
</ul>
<p><img src="/image/image_LlNnFiYkcG.png"></p>

      
    </div>

    
    
    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeinsshiri.github.io/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%20greedy%20algorithm/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%20greedy%20algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zeins_XvJin_Shiri">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeins's Blog">
      <meta itemprop="description" content="在何处付出，便在何处收获">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeins's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%20greedy%20algorithm/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%20greedy%20algorithm/" class="post-title-link" itemprop="url">贪心算法 greedy algorithm</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-07 17:18:48" itemprop="dateCreated datePublished" datetime="2024-02-07T17:18:48+08:00">2024-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-08 16:36:25" itemprop="dateModified" datetime="2024-02-08T16:36:25+08:00">2024-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构&算法</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>846</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>每一步决策都选局部最优解，进而导致全局最优解。<br>严格应用greedy algorithm：必然要证明：<strong>全局最优解能由局部最优解（子问题的优解）构造</strong></p>
<p>贪心算法和动态规划都常用于解决优化问题。它们之间存在一些相似之处，比如都依赖最优子结构性质，但工作原理是不同的：</p>
<ul>
<li>贪心算法不会重新考虑过去的决策，而是一路向前地进行贪心选择，不断缩小问题范围，直至问题被解决。</li>
<li>动态规划根据之前阶段的所有决策来考虑当前决策，并使用过去子问题的解来构建当前子问题的解。</li>
</ul>
<p><img src="/image/image_BF-simJpCh.png"></p>
<p>有一篇论文给出了一个 O(n^3) 时间复杂度的算法，用于判断一个硬币组合是否可以使用贪心算法找出任何金额的最优解。</p>
<p>Pearson, David. A polynomial-time algorithm for the change-making problem. Operations Research Letters 33.3 (2005): 231-234.</p>
<h2 id="贪心优点与局限性"><a href="#贪心优点与局限性" class="headerlink" title="贪心优点与局限性"></a>贪心优点与局限性</h2><p>严格使用要给出可行性证明</p>
<h2 id="贪心典型例题"><a href="#贪心典型例题" class="headerlink" title="贪心典型例题"></a>贪心典型例题</h2><p>贪心算法常常应用在满足贪心选择性质和最优子结构的优化问题中，以下列举了一些典型的贪心算法问题。</p>
<ul>
<li><strong>硬币找零问题</strong>：在某些硬币组合下，贪心算法总是可以得到最优解。</li>
<li><strong>区间调度问题</strong>：假设你有一些任务，每个任务在一段时间内进行，你的目标是完成尽可能多的任务。如果每次都选择结束时间最早的任务，那么贪心算法就可以得到最优解。</li>
<li><strong>分数背包问题</strong>：给定一组物品和一个载重量，你的目标是选择一组物品，使得总重量不超过载重量，且总价值最大。如果每次都选择性价比最高（价值 &#x2F; 重量）的物品，那么贪心算法在一些情况下可以得到最优解。</li>
<li><strong>股票买卖问题</strong>：给定一组股票的历史价格，你可以进行多次买卖，但如果你已经持有股票，那么在卖出之前不能再买，目标是获取最大利润。</li>
<li><strong>霍夫曼编码</strong>：霍夫曼编码是一种用于无损数据压缩的贪心算法。通过构建霍夫曼树，每次选择出现频率最小的两个节点合并，最后得到的霍夫曼树的带权路径长度（即编码长度）最小。</li>
<li><strong>Dijkstra 算法</strong>：它是一种解决给定源顶点到其余各顶点的最短路径问题的贪心算法。</li>
</ul>

      
    </div>

    
    
    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeinsshiri.github.io/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&%E7%AE%97%E6%B3%95/%E9%87%8D%E5%A4%8D%E6%93%8D%E4%BD%9C%EF%BC%88%E8%BF%AD%E4%BB%A3&%E9%80%92%E5%BD%92%EF%BC%89/%E9%87%8D%E5%A4%8D%E6%93%8D%E4%BD%9C%EF%BC%88%E8%BF%AD%E4%BB%A3&%E9%80%92%E5%BD%92%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zeins_XvJin_Shiri">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeins's Blog">
      <meta itemprop="description" content="在何处付出，便在何处收获">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeins's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&%E7%AE%97%E6%B3%95/%E9%87%8D%E5%A4%8D%E6%93%8D%E4%BD%9C%EF%BC%88%E8%BF%AD%E4%BB%A3&%E9%80%92%E5%BD%92%EF%BC%89/%E9%87%8D%E5%A4%8D%E6%93%8D%E4%BD%9C%EF%BC%88%E8%BF%AD%E4%BB%A3&%E9%80%92%E5%BD%92%EF%BC%89/" class="post-title-link" itemprop="url">重复操作（迭代&递归）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-07 17:18:48" itemprop="dateCreated datePublished" datetime="2024-02-07T17:18:48+08:00">2024-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-08 16:34:26" itemprop="dateModified" datetime="2024-02-08T16:34:26+08:00">2024-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构&算法</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="迭代iteration"><a href="#迭代iteration" class="headerlink" title="迭代iteration"></a>迭代iteration</h2><p>随参数变化进行重复操作;其典型就是各种循环，嵌套结构<br><code>for</code> 循环是最常见的迭代形式之一，<strong>适合预先知道迭代次数时使用</strong>。需注意的是，Python 中 <code>range(a, b)</code> 对应的区间是“左闭右开”的，对应的遍历范围为 a,a+1,…,b−1&#x20;</p>
<p><img src="/image/image_gioLlUT71L.png"></p>
<p><img src="/image/image_OcaOHgI-wr.png"></p>
<h2 id="递归recursion"><a href="#递归recursion" class="headerlink" title="递归recursion"></a>递归recursion</h2><p>通过函数调用自身来解决问题。包含两阶段</p>
<ol>
<li><strong>递</strong>：程序一级级调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。</li>
<li><strong>归</strong>：触发“终止条件”后，程序从最深层的递归函数开始逐层把解返回上一层，最终构建原问题的解</li>
</ol>
<p>从实现的角度看，递归代码主要包含三要素</p>
<ol>
<li><strong>终止条件</strong>：用于决定什么时候由“递”转“归”。</li>
<li><strong>递归调用</strong>：对应“递”，函数调用自身，通常输入更小或更简化的参数。</li>
<li><strong>返回结果</strong>：对应“归”，将当前递归层级的结果返回至上一层。</li>
</ol>
<p><img src="/image/image_-QUL99FZUr.png"></p>
<h3 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h3><p><a href="../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/C.md" title="C">C</a>参考栈帧部分</p>
<p>递归函数每次调用自身时，系统都会在栈区分配内存，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果。在触发终止条件前，同时存在 n 个未返回的递归函数，<strong>递归深度为 n</strong> 。</p>
<ul>
<li>函数的上下文数据都存储在称为“栈帧空间”的内存区域中，直至函数返回后才会被释放。因此，<strong>递归通常比迭代更加耗费内存空间</strong>。</li>
<li>递归调用会产生额外开销。<strong>因此通常比循环时间效率低</strong></li>
</ul>
<p><img src="/image/image_yadn-YSsoh.png"></p>
<h3 id="尾递归tail-recursion"><a href="#尾递归tail-recursion" class="headerlink" title="尾递归tail recursion"></a>尾递归tail recursion</h3><p><strong>若函数在返回前的最后一步才进行递归调用</strong>，则该函数可被某些语言的编译器&#x2F;解释器优化，使其在空间效率上与迭代相当<br>尾递归优化原理：以计算 1+2+⋯+n 为例f（n）&#x3D;n+f(n-1)</p>
<p><img src="/image/image_k1yOC5fNN6.png"></p>
<p><img src="/image/image_XWILw2wK-U.png"></p>
<ul>
<li><strong>普通递归</strong>：解决原问题f(n)需递归地解决n+f(n-1)这种形式的子问题；每级向下调用都要暂存n参数等待下级调用返回再计算；如此每级调用都会push一个栈帧，产生额外开销</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 递归 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recur</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 递：递归调用</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">recur</span>(n - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 归：返回结果</span></span><br><span class="line">    <span class="keyword">return</span> n + res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>尾递归</strong>：解决原问题f(n)需递归地解决n+f(n-1)这种形式的子问题；<strong>每级向下调用都把本要暂存的n参数传参到下级调用；如此到最后一级调用再把每级收集的参数加入计算</strong>；某些编译器识别到这种情况；便会进行优化；节约每级调用产生栈帧的开销；<br>递归树向下传递会有栈帧开销的原因是要暂存数据等回归时计算，把这些数据即时计算了在传递下去，则暂存栈帧是多余的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 尾递归 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tailRecur</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> res)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// 尾递归调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tailRecur</span>(n - <span class="number">1</span>, res + n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代模拟递归"><a href="#迭代模拟递归" class="headerlink" title="迭代模拟递归"></a>迭代模拟递归</h3><p>思路是：<strong>用一个显式的栈模拟调用栈的行为</strong>；递归多少层，栈就应该多少层；<br>递：通过迭代计算出每级递归暂存的参数push into stack<br>归：然后遍历pop stack一级级计算返回值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使用迭代模拟递归 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">forLoopRecur</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用一个显式的栈来模拟系统调用栈</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 递：递归调用</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 通过“入栈操作”模拟“递”</span></span><br><span class="line">        stack.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 归：返回结果</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 通过“出栈操作”模拟“归”</span></span><br><span class="line">        res += stack.<span class="built_in">top</span>();</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// res = 1+2+3+...+n</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用途：尽管迭代和递归在很多情况下可以互相转换，但也不一定值得这样做</p>
<ul>
<li>对于某些复杂问题，模拟系统调用栈的行为可能非常困难。</li>
<li>当递归被转换为迭代后，代码可能变得更复杂（可读性更差）</li>
</ul>
<p>总之，<strong>选择迭代还是递归取决于特定问题的性质</strong>。在编程实践中，权衡两者的优劣并根据情境选择合适的方法</p>
<p>递归常见3种优化：<br>1）写成尾递归→编译器自动进行尾递归优化<br>&#x20;                     →手动改写成迭代进行尾递归优化（因为没有尾递归优化还是会暂存调用现场）</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/36587160" title=" 尾递归为啥能优化？ 扩展阅读brambles：通用的递归转循环方法前言这篇文章其实是我两年以前写的，文尾给自己开了一个坑，说是要手写一个自动将尾递归的函数优化成一个用循环迭代的函数，结果这坑一拖就是两年，我也差不多忘了有这回事… https://zhuanlan.zhihu.com/p/36587160"> 尾递归为啥能优化？ 扩展阅读brambles：通用的递归转循环方法前言这篇文章其实是我两年以前写的，文尾给自己开了一个坑，说是要手写一个自动将尾递归的函数优化成一个用循环迭代的函数，结果这坑一拖就是两年，我也差不多忘了有这回事… https://zhuanlan.zhihu.com/p/36587160</a></p>
<p>2）直接改写成迭代形式<br>3）</p>

      
    </div>

    
    
    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeinsshiri.github.io/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97queue/%E9%98%9F%E5%88%97queue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zeins_XvJin_Shiri">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeins's Blog">
      <meta itemprop="description" content="在何处付出，便在何处收获">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeins's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97queue/%E9%98%9F%E5%88%97queue/" class="post-title-link" itemprop="url">队列queue</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-07 17:18:48" itemprop="dateCreated datePublished" datetime="2024-02-07T17:18:48+08:00">2024-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-08 16:41:07" itemprop="dateModified" datetime="2024-02-08T16:41:07+08:00">2024-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构&算法</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>遵循先入先出规则的线性数据结构。队列头部称为“队首”，尾部称为“队尾”，将把元素加入队尾的操作称为“入队”，删除队首元素的操作称为“出队”。</p>
<p><img src="https://www.hello-algo.com/chapter_stack_and_queue/queue.assets/queue_operations.png"></p>
<h3 id="队列常用操作"><a href="#队列常用操作" class="headerlink" title="队列常用操作"></a>队列常用操作</h3><p><img src="/image/image_ZszKYnS0p9.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化队列 */</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; queue;</span><br><span class="line"><span class="comment">/* 元素入队 */</span></span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"><span class="comment">/* 访问队首元素 */</span></span><br><span class="line"><span class="type">int</span> front = queue.<span class="built_in">front</span>();</span><br><span class="line"><span class="comment">/* 元素出队 */</span></span><br><span class="line">queue.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">/* 获取队列的长度 */</span></span><br><span class="line"><span class="type">int</span> size = queue.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">/* 判断队列是否为空 */</span></span><br><span class="line"><span class="type">bool</span> empty = queue.<span class="built_in">empty</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="队列实现"><a href="#队列实现" class="headerlink" title="队列实现"></a>队列实现</h3><p>可在一端添加元素，并在另一端删除元素的数据结构。因此，链表和数组都可以用来实现队列。</p>
<h4 id="1-基于链表的实现"><a href="#1-基于链表的实现" class="headerlink" title="1.   基于链表的实现"></a>1.   基于链表的实现</h4><p>可将链表“头节点”和“尾节点”分别视为“队首”和“队尾”，规定队尾仅可添加节点，队首仅可删除节点</p>
<p><img src="/image/image_2hNc01pfyI.png"></p>
<p><img src="/image/image_3pLJG0tjb6.png"></p>
<p><img src="/image/image_GmsdAXGai5.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基于链表实现的队列 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedListQueue</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    ListNode *front, *rear; <span class="comment">// 头节点 front ，尾节点 rear</span></span><br><span class="line">    <span class="type">int</span> queSize;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkedListQueue</span>() &#123;</span><br><span class="line">        front = <span class="literal">nullptr</span>;</span><br><span class="line">        rear = <span class="literal">nullptr</span>;</span><br><span class="line">        queSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">LinkedListQueue</span>() &#123;</span><br><span class="line">        <span class="comment">// 遍历链表删除节点，释放内存</span></span><br><span class="line">         <span class="built_in">freeMemoryLinkedList</span>(front); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取队列的长度 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断队列是否为空 */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queSize == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 入队 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 尾节点后添加 num</span></span><br><span class="line">        ListNode *node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(num);</span><br><span class="line">        <span class="comment">// 如果队列为空，则令头、尾节点都指向该节点</span></span><br><span class="line">        <span class="keyword">if</span> (front == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            front = node;</span><br><span class="line">            rear = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果队列不为空，则将该节点添加到尾节点后</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            rear-&gt;next = node;</span><br><span class="line">            rear = node;</span><br><span class="line">        &#125;</span><br><span class="line">        queSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 出队 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">peek</span>();</span><br><span class="line">        <span class="comment">// 删除头节点</span></span><br><span class="line">        ListNode *tmp = front;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        queSize--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问队首元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> front-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将链表转化为 Vector 并返回 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">toVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode *node = front;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            res[i] = node-&gt;val;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-基于数组的实现"><a href="#2-基于数组的实现" class="headerlink" title="2.   基于数组的实现"></a>2.   基于数组的实现</h4><p>由于数组删除首元素的时间复杂度为 O(n) ，这会导致出队操作效率较低。可采用以下方法避免这个问题。</p>
<p>我们可以使用一个变量 <code>front</code> 指向队首元素的索引，并维护一个变量 <code>size</code> 用于记录队列长度。定义 <code>rear = front + size</code> ，这个公式计算出的 <code>rear</code> 指向队尾元素之后的下一个位置。</p>
<p>基于此设计，**数组中包含元素的有效区间为<code>[front, rear - 1]</code>**，各种操作的实现方法如图 5-6 所示。</p>
<ul>
<li>入队操作：将输入元素赋值给 <code>rear</code> 索引处，并将 <code>size</code> 增加 1 。</li>
<li>出队操作：只需将 <code>front</code> 增加 1 ，并将 <code>size</code> 减少 1 。</li>
</ul>
<p>可以看到，入队和出队操作都只需进行一次操作，时间复杂度均为 �(1) 。</p>
<p><img src="/image/image_2rHBBh8kSB.png"></p>
<p><img src="/image/image_wopj38EUqU.png"></p>
<p><img src="/image/image_zyhO0OmXia.png"></p>
<p>不断入队和出队，<code>front</code> 和 <code>rear</code> 都在向右移动，<strong>当rear到达数组尾部时就无法继续移动了</strong>。可将数组视为首尾相接的“环形数组”。对于环形数组，我们需要让 <code>front</code> 或 <code>rear</code> 在越过数组尾部时，直接回到数组头部继续遍历。这种周期性规律可以通过“取余操作”实现（队列是模系统）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基于环形数组实现的队列 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayQueue</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *nums;       <span class="comment">// 用于存储队列元素的数组</span></span><br><span class="line">    <span class="type">int</span> front;       <span class="comment">// 队首指针，指向队首元素</span></span><br><span class="line">    <span class="type">int</span> queSize;     <span class="comment">// 队列长度</span></span><br><span class="line">    <span class="type">int</span> queCapacity; <span class="comment">// 队列容量</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ArrayQueue</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        <span class="comment">// 初始化数组</span></span><br><span class="line">        nums = <span class="keyword">new</span> <span class="type">int</span>[capacity];</span><br><span class="line">        queCapacity = capacity;</span><br><span class="line">        front = queSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ArrayQueue</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取队列的容量 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取队列的长度 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断队列是否为空 */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">size</span>() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 入队 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queSize == queCapacity) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;队列已满&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算队尾指针，指向队尾索引 + 1</span></span><br><span class="line">        <span class="comment">// 通过取余操作，实现 rear 越过数组尾部后回到头部</span></span><br><span class="line">        <span class="type">int</span> rear = (front + queSize) % queCapacity;<span class="comment">//模queCapacity系统首尾相连，0=queCapacity</span></span><br><span class="line">        <span class="comment">// 将 num 添加至队尾</span></span><br><span class="line">        nums[rear] = num;</span><br><span class="line">        queSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 出队 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">peek</span>();</span><br><span class="line">        <span class="comment">// 队首指针向后移动一位，若越过尾部则返回到数组头部</span></span><br><span class="line">        front = (front + <span class="number">1</span>) % queCapacity;</span><br><span class="line">        queSize--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问队首元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> nums[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将数组转化为 Vector 并返回 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">toVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 仅转换有效长度范围内的列表元素</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(queSize)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = front; i &lt; queSize; i++, j++) &#123;</span><br><span class="line">            arr[i] = nums[j % queCapacity];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上实现的队列仍然具有局限性，即其长度不可变。然而，这个问题不难解决，我们可以将数组替换为动态数组，从而引入扩容机制。有兴趣的同学可以尝试自行实现。？？？？？？？</p>
<p>两种实现的对比结论与栈一致，在此不再赘述。</p>
<h3 id="队列典型应用"><a href="#队列典型应用" class="headerlink" title="队列典型应用"></a>队列典型应用</h3><ul>
<li><strong>淘宝订单</strong>。购物者下单后，订单将加入队列中，系统随后会根据顺序依次处理队列中的订单。在双十一期间，短时间内会产生海量订单，高并发成为工程师们需要重点攻克的问题。</li>
<li><strong>各类待办事项</strong>。任何需要实现“先来后到”功能的场景，例如打印机的任务队列、餐厅的出餐队列等。队列在这些场景中可以有效地维护处理顺序。</li>
</ul>

      
    </div>

    
    
    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeinsshiri.github.io/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zeins_XvJin_Shiri">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeins's Blog">
      <meta itemprop="description" content="在何处付出，便在何处收获">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeins's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">内存管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-07 17:18:48" itemprop="dateCreated datePublished" datetime="2024-02-07T17:18:48+08:00">2024-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-08 16:31:44" itemprop="dateModified" datetime="2024-02-08T16:31:44+08:00">2024-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BD%AF%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">软件</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>程序运行时，程序的数据会加载到内存；<strong>裸机 CPU 直接操作内存的「物理地址」</strong>；如果想在内存中并发运行两个程序，各进程却共享相同的物理内存简直灾难；</p>
<p>内存管理为了解决以下问题：<br>1）内存冲突→虚拟内存；使得进程之间的内存地址互不影响<br>2）虚拟内存地址映射物理地址→MMU，页表维护虚拟页与物理页的映射关系<br>3）内存碎片→内存分页<br>4)逻辑段与虚拟内存地址间的映射关系→段表维护段号与页表基地址关系；页表维护虚拟页与物理页的映射关系<br>5）页表项时空复杂度问题：页表树节约存储,TLB解决页表树时间复杂度上升问题<br>6）内存资源紧张→内存交换：CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域</p>
<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a><strong>虚拟内存</strong></h1><p>每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响</p>
<p><img src="/image/image_xBa7Q_F2EV.png"></p>
<p><img src="/image/image_ba9ELML_Gd.png"></p>
<p><img src="/image/image_LhUQGPEu0l.png"></p>
<p>每个进程都独立占有一套<strong>虚拟地址空间</strong>；操作内存时，cpu通过对TLB或段表，页表查询虚拟地址对应的物理页表基地址；再通过内存管理单元（MMU）把物理页基地址+偏移地址映射到物理地址；虚拟内存可使进程运行内存超过物理内存；</p>
<p>由于进程无法访问其他进程的页表（私有），解决了多进程间地址冲突问题；</p>
<p>32位地址总线的地址空间0x0~0xffff ffff大小就是$2^{32}&#x3D;4G;G&#x3D;2^{10}*2^{10}*2^{10}$；每个地址指向一个字节，<strong>虚拟空间</strong>大小为4GB</p>
<p>Linux下虚拟地址空间的内部又被分为<strong>内核空间和用户空</strong>间：</p>
<p><img src="/image/image_s15d6Bk4FA.png"></p>
<p>用户态虚拟内存空间为 3 GB，虚拟内存地址范围为：0x0000 0000 - 0xC000 000&#x20;<br>内核态虚拟内存空间为 1 GB，虚拟内存地址范围为：0xC000 000 - 0xFFFF FFFF<br>不可访问的保留区: C 语言中我们通常会将一些无效的指针设置为 NULL，指向这块不允许访问的地址</p>
<ul>
<li>代码段，包括二进制可执行代码；</li>
<li>数据段，包括已初始化的静态常量和全局变量；</li>
<li>BSS 段，包括未初始化的静态变量和全局变量；</li>
<li>堆段，包括动态分配的内存，从低地址开始向上增长；</li>
<li>文件映射段，包括动态库、共享内存等，从低地址开始向上增长（<a target="_blank" rel="noopener" href="http://lishiwen4.github.io/linux/linux-process-memory-location" title="跟硬件和内核版本有关 (opens new window)">跟硬件和内核版本有关 (opens new window)</a>）；</li>
<li>栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 <code>8 MB</code>。当然系统也提供了参数，以便我们自定义大小；</li>
</ul>
<p>上图中的内存布局可以看到，代码段下面还有一段内存空间的（灰色部分），这一块区域是「保留区」，之所以要有保留区这是因为在大多数的系统里，我们认为比较小数值的地址不是一个合法地址，例如，我们通常在 C 的代码里会将无效的指针赋值为 NULL。因此，这里会出现一段不可访问的内存保留区，防止程序因为出现 bug，导致读或写了一些小内存地址的数据，而使得程序跑飞。</p>
<p>在这 7 个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的 <code>malloc()</code> 或者 <code>mmap()</code> ，就可以分别在堆和文件映射段动态分配内存</p>
<h1 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h1><p><img src="/image/image_ROzb8ueuCN.png"></p>
<p><img src="/image/image_TJ5lWPh2X2.png"></p>
<p><strong>分页是把虚拟&#x2F;物理内存空间划分</strong>为连续且尺寸固定的内存空间（<strong>页</strong><em>Page</em>）； Linux 下每页大小 <code>4KB</code>；若内存不以固定的页单位分配，释放；会产生内存碎片（进程需要连续的空闲内存，离散分布的空闲内存的容纳能力取决于最大连续空闲内存）</p>
<h1 id="内存交换"><a href="#内存交换" class="headerlink" title="内存交换"></a><strong>内存</strong>交换</h1><p>os会把「最近没被使用」的内存页释放掉，也就是暂时写在硬盘上，称为<strong>换出</strong>（<em>Swap Out</em>）。需要时再加载进来，称为<strong>换入</strong>（<em>Swap In</em>）；<strong>机器卡顿</strong>的原因之一</p>
<p>内存交换空间，在 Linux 系统下称为 Swap 空间，这块空间从硬盘划分出来用于内存与硬盘的空间交换</p>
<h1 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h1><p><img src="/image/image_cApb-RJlea.png"></p>
<p><img src="/image/image_4Cwy9VlWwr.png"></p>
<p>程序运行时数据可分为逻辑段：汇编层面为代码段** +<strong>数据段</strong> **+堆栈段+扩展段；这样同属性数据都放在了一块连续空间；</p>
<p>在程序开始运行时，os将可执行文件中的代码段载入物理内存，并建立虚拟内存地址到物理地址的映射。当执行到操作内存指令时，指令所需数据从可执行文件中的数据段载入到内存中。此时，os根据虚拟地址到物理地址的映射关系，对物理内存数据段进行操作；</p>
<p>CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域<br>**<br><strong>段页式内存管理</strong>虚拟地址(win)&#x3D;段号+段内页号+页内位移**<br>页式内存管理<strong>虚拟地址（linux）&#x3D;多级页号+页内位移</strong></p>
<p>虚拟地址到物理地址的映射关系主要由段表和页表维护：<br>页式内存管理:段表维护段号与页表基地址关系（该段存在哪些页里边）；页表维护该段页号与物理页基地址的映射关系（页的物理地址）；页表里的页表项还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等</p>
<p>页式内存管理:段基地址缺省为0；主要由页表维护该段页号与物理页基地址的映射关系（页的物理地址）</p>
<p><img src="/image/image_xJH-7n4icx.png"></p>
<p><img src="/image/image_tvvesMQyJ1.png"></p>
<h2 id="页表树"><a href="#页表树" class="headerlink" title="页表树"></a>页表树</h2><p>32 位环境下，虚拟空间共有 $2^{32}$B&#x3D;4GB，假设一个页的大小 4KB（2^12），那么虚拟内存就要划分2^20 页，每个「页表项」需要 4 字节存储页表基地址，需要 <code>4MB</code> 内存存储页表；每个进程都有自己的页表；进程创建时默认就有4MB开销；运行多个进程时是非常大的内存了，更别说 64 位环境了</p>
<p>所以页表项引入页表树来维护：2^20&#x3D;1024*1024个页表项可划分为每层1024个节点的2级页表；如果按深度优先序去建表，那么最后没用到的连续的页表虚拟基地址的页表项就不用建立，且二级页表项也可等到要用时再插入节点；大大节约内存</p>
<p><img src="/image/image_Xn6aLCNX1L.png"></p>
<p>64 位环境下一般是四级目录：$2^{64}B$空间，$2^{52}$&#x3D;$2^{13}<em>$$2^{13}</em>$$2^{13}<em>$$2^{13}</em>$页;每层8K个节点<br>1）全局页目录项 PGD（<em>Page Global Directory</em><br>2）上层页目录项 PUD（<em>Page Upper Directory</em>）<br>3）中间页目录项 PMD（<em>Page Middle Directory</em><br>4）页表项 PTE（<em>Page Table Entry</em>）<br>每个进程都用一张段表维护段号与该段页表基地址关系；该段页表维护虚拟页号与物理页号的映射关系</p>
<p><img src="/image/image_z7CmDSJh0-.png"></p>
<p><img src="/image/image_tPMM5W3Jxb.png"></p>
<h2 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h2><p><img src="/image/image_Ft0oF4nx0D.png"></p>
<p><img src="/image/image_0PRgmPXC0t.png"></p>
<p>把最常访问的几个页表项存储到 CPU 芯片中的 Cache，这个 Cache 就是 TLB（<em>Translation Lookaside Buffer</em>） ，通常称为页表缓存、转址旁路缓存、快表等;<br>CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表</p>
<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a><strong>内存</strong>分配</h1>
      
    </div>

    
    
    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeinsshiri.github.io/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/linux%E6%8C%87%E5%8D%97/linux%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zeins_XvJin_Shiri">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeins's Blog">
      <meta itemprop="description" content="在何处付出，便在何处收获">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeins's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/linux%E6%8C%87%E5%8D%97/linux%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">linux指南</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-07 17:18:48" itemprop="dateCreated datePublished" datetime="2024-02-07T17:18:48+08:00">2024-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-08 16:30:55" itemprop="dateModified" datetime="2024-02-08T16:30:55+08:00">2024-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BD%AF%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">软件</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="x20-Linux文件组织标准-https-zhuanlan-zhihu-com-p-107263805"><a href="#x20-Linux文件组织标准-https-zhuanlan-zhihu-com-p-107263805" class="headerlink" title="&#x20;Linux文件组织标准 https://zhuanlan.zhihu.com/p/107263805"></a>&#x20;Linux文件组织标准 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/107263805" title="https://zhuanlan.zhihu.com/p/107263805">https://zhuanlan.zhihu.com/p/107263805</a></h2><p>确定每个目录下该放什么文件和数据，并希望 Linux 用户能遵循该准则</p>
<p><img src="/image/image_KEN1jWMntU.png"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/ 根目录</span><br><span class="line">bin //存放2进制可执行文件，如命令</span><br><span class="line">boot //内核和启动程序</span><br><span class="line">  grub //引导器相关文件</span><br><span class="line">dev //设备文件；字符设备，块设备</span><br><span class="line">etc //存放用户信息和系统配置文件；系统软件的启动配置文件，系统在启动过程中需要读取的文件都在这个目录。如LILO参数、用</span><br><span class="line">户账户和密码。</span><br><span class="line">home //用户的主目录。下面是自己定义的用户名的文件夹</span><br><span class="line">lib //系统程序库文件,这个目录里存放着系统最基本的动态链接共享库，类似于Windows下的system32</span><br><span class="line">目录，几乎所有的应用程序都需要用到这些共享库。</span><br><span class="line">media //挂载媒体设备，如光驱、U盘等</span><br><span class="line">mnt //目录是让用户临时挂载别的文件系统，如挂载Windows下的某个分区，ubuntu默认还是挂载在/media目录。</span><br><span class="line">opt //可选的应用软件包（很少使用）</span><br><span class="line">proc //这个目录是系统内存的映射，我们可以直接访问这个目录来获取系统信息。也就是说，这个目录的内容不在硬盘上而是在内存里。</span><br><span class="line">sbin //管理员系统程序</span><br><span class="line">selinux</span><br><span class="line">srv</span><br><span class="line">sys //udev用到的设备目录树，/sys反映你机器当前所接的设备</span><br><span class="line">tmp //临时文件夹</span><br><span class="line">usr //这是个最庞大的目录，用户应用程序资源目录</span><br><span class="line">  bin // 应用程序</span><br><span class="line">  game //游戏程序</span><br><span class="line">  include</span><br><span class="line">  lib //应用程序的库文件</span><br><span class="line">  lib64</span><br><span class="line">  <span class="built_in">local</span> //包含用户程序等</span><br><span class="line">  sbin //管理员应用程序</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>FHS 建议所有软件开发者都应该将数据合理地放置到usr目录的子目录下。</p>
<p>一般来说，&#x2F;usr 下的子目录有：</p>
<ul>
<li>&#x2F;usr&#x2F;bin&#x2F;：绝大部分的用户命令都在此处，它与&#x2F;bin目录的区别在于后者存放与开机相关的命令。</li>
<li>&#x2F;usr&#x2F;include&#x2F;：C&#x2F;C++的头文件和包含文件。</li>
<li>&#x2F;usr&#x2F;lib&#x2F;：包含各应用软件的函数库、目标文件，以及一些不被用户惯用的执行文件。</li>
<li>&#x2F;usr&#x2F;local&#x2F;：系统管理员在本机自行下载的软件。</li>
<li>&#x2F;usr&#x2F;sbin&#x2F;：非系统正常运行需要的系统命令。</li>
<li>&#x2F;usr&#x2F;share&#x2F;：放置共享文件的地方</li>
<li>&#x2F;usr&#x2F;src&#x2F;：源码放置的地方</li>
</ul>
<p>&#x2F;var 目录下主要放置常态化变动的文件，例如缓存、登录日志文件、软件运行产生的文件等。</p>
<p>&#x2F;var 下的子目录常见有：</p>
<ul>
<li>&#x2F;var&#x2F;cache&#x2F;：应用程序运行过程中产生的暂存文件。</li>
<li>&#x2F;var&#x2F;lib&#x2F;：应用程序运行过程中，需要使用到的数据文件放置的目录。</li>
<li>&#x2F;var&#x2F;lock&#x2F;：某些设备或文件要求使用时具有排他性，即上锁，该目录存放这类设备文件。</li>
<li>&#x2F;var&#x2F;log&#x2F;：日志或登录文件放置的目录。</li>
<li>&#x2F;var&#x2F;mail&#x2F;：放置个人电子邮件的目录。</li>
<li>&#x2F;var&#x2F;run&#x2F;：某些程序或者是服务启动后，将它们的 PID 记录在这个目录下</li>
<li>&#x2F;var&#x2F;spool&#x2F;：这个目录通常会放置一些队列数据，包括等待收寄的电子邮件、cron 任务等</li>
</ul>
<p>usr存放系统非必须app的不可改变数据,var存储可变临时数据</p>
<blockquote>
<p>共享文件夹在&#x2F;mnt下找</p>
</blockquote>
<p>7种文件类型:</p>
<p>f&#x2F;-:普通文件</p>
<p>d:目录文件</p>
<p>i:链接文件</p>
<p>p:管道文件(系统编程</p>
<p>s:网络套接字(网络编程</p>
<p>c:字符设备文件</p>
<p>b:块设备文件</p>
<h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><p>在Windows下，可直接访问检测到的外设，如磁盘、U盘等,因windos会自动分盘;将各分区(新设备)存储挂载到其对应根目录下；</p>
<p>在Linux下，外部硬件设备如磁盘、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=SD%E5%8D%A1&spm=1001.2101.3001.7020" title="SD卡">SD卡</a>等无法直接访问,要手动挂载实体存储到某目录下:</p>
<p>cd  &#x2F;dev查看新设备</p>
<p>mount &#x2F;dev&#x2F;sdb1 &#x2F;mountdir      # 将外部设备 &#x2F;dev&#x2F;sdb1 挂载到 mountdir</p>
<p>umount &#x2F;mountdir # 使用完以后，取消挂载</p>
<p>lsblk查看挂载情况</p>
<h2 id="软件包管理器"><a href="#软件包管理器" class="headerlink" title="软件包管理器"></a>软件包管理器</h2><p>下载一个软件:你可能需要下载,解压,编译,链接(写makefile,cmake);更别提要遵守fhs</p>
<p>.&#x2F;configure  自动生成make<br>make &#x20;<br>make install</p>
<p>软件包管理系统提供了易于使用的GUI和命令行工具，使用户能在线搜索,安装预编译的二进制发布版本、更新和删除软件包.还提供依赖管理功能，自动处理软件包之间的依赖关系</p>
<p>命令概览：</p>
<p>两大包管理系统（.deb技术）（.rpm技术）<br>低级工具（rpm)(dpkg）<br>高级工具（apt-get,aptitude）（yum）<br>查找软件包(apt-get update，apt-cache search search_string),(yum search search_string)<br>高级安装软件包（apt-get update ; apt-get install package_name）,(yum install package_name)<br>低级软件包安装命令（dpkg –install package_file）(rpm -i package_file)<br>删除&#x2F;卸载软件包（apt-get remove package_name）(yum erase package_name)<br>更新库中的软件包（apt-get update; apt-get upgrade）（yum update）<br>更新软件包文件中的软件包（dpkg –install package_file）（rpm -U package_file）<br>查看系统已安装软件包（dpkg –list）（rpm -qa）<br>判断软件是否安装（dpkg –status packagename）（rpm -q package_name）<br>显示已安装软甲的相关信息（apt-cache show packagename）（yum info package_name）<br>查看某文件或目录谁装的（dpkg –search filename）（rpm -qf file_name）</p>
<h2 id="以太网设置"><a href="#以太网设置" class="headerlink" title="以太网设置"></a>以太网设置</h2><p>如果是板子要有桥接网卡并网;若是虚拟机,要虚拟网卡;</p>
<p>硬件有了,驱动装了,协议服务装了,应用装了,还得设置ip</p>
<p>ip设置</p>
<p>临时设置:ifconfig  port xxx.xxx.xxx.xxx</p>
<p>设置端口port的IP为xxxx;port用ifconfig查询</p>
<blockquote>
<p>虚拟机和主机的默认网关不一致</p>
</blockquote>
<p>永久设置:</p>
<p>vi &#x2F;etc&#x2F;network&#x2F;interfaces</p>
<p>修改ip,掩码,默认网关;或把临时设置写进bootload</p>
<p>重启网络&#x20;</p>
<p>&#x2F;etc&#x2F;init.d&#x2F;S40network restart</p>
<p>虚拟机联网</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_37131111/article/details/54000029" title=" VMware 虚拟机如何连接网络_vmware虚拟机连接网络_王一一的博客的博客-CSDN博客 ps：本教程是针对虚拟机NAT模式连接网络一、首先查看自己的虚拟机服务有没有开启，选择电脑里面的服务查看；1.计算机点击右键选择管理 2.进入管理选择VM开头的服务如果没有开启的话就右键开启 二、虚拟机服务开启后就查看本地网络虚拟机的网卡启动没有1.电脑右下角网络标志右键进入网络和共享中心2.点击更改适配器，查看虚拟机的虚拟网卡启动没有，没有启动的话右键点击启动  3.网卡开启后设置ip地址_vm https://blog.csdn.net/qq_37131111/article/details/54000029"> VMware 虚拟机如何连接网络_vmware虚拟机连接网络_王一一的博客的博客-CSDN博客 ps：本教程是针对虚拟机NAT模式连接网络一、首先查看自己的虚拟机服务有没有开启，选择电脑里面的服务查看；1.计算机点击右键选择管理 2.进入管理选择VM开头的服务如果没有开启的话就右键开启 二、虚拟机服务开启后就查看本地网络虚拟机的网卡启动没有1.电脑右下角网络标志右键进入网络和共享中心2.点击更改适配器，查看虚拟机的虚拟网卡启动没有，没有启动的话右键点击启动  3.网卡开启后设置ip地址_vm https://blog.csdn.net/qq_37131111&#x2F;article&#x2F;details&#x2F;54000029</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/130984945" title="VMware虚拟机网络配置-NAT篇 0 前言网上有好多VMware的网络配置教程，各个方法都不一样，新人往往云里雾里，本人亦深受其害，偶尔成功一次，也不明白原理，下一次照样犯错，故写博客记录。 1 想要达成的效果主机和虚拟机之间，可以互相ping通… https://zhuanlan.zhihu.com/p/130984945">VMware虚拟机网络配置-NAT篇 0 前言网上有好多VMware的网络配置教程，各个方法都不一样，新人往往云里雾里，本人亦深受其害，偶尔成功一次，也不明白原理，下一次照样犯错，故写博客记录。 1 想要达成的效果主机和虚拟机之间，可以互相ping通… https://zhuanlan.zhihu.com/p/130984945</a></p>
<p>0）开启vm的服务<br>1）设置虚拟子网vmnetx：192.168.80.0;gateway:2；自动分配范围<br>2)虚拟适配器静态设置ip为1；动态有时会分配到相同网段出问题<br>3）虚拟网络设置为vmnetx;<br>4）虚拟机设置本机ip；不能占用上述几个IP；在分配范围内；重启搞定</p>
<p>桥接:</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/he_and/article/details/86589239" title=" win10 vmware没有vmnet0(桥接后无法上网）解决办法_vm无法将网络更改为桥接状态_tnt阿信的博客-CSDN博客 这个问题困扰了我好久_vm无法将网络更改为桥接状态 https://blog.csdn.net/he_and/article/details/86589239"> win10 vmware没有vmnet0(桥接后无法上网）解决办法_vm无法将网络更改为桥接状态_tnt阿信的博客-CSDN博客 这个问题困扰了我好久_vm无法将网络更改为桥接状态 https://blog.csdn.net/he_and&#x2F;article&#x2F;details&#x2F;86589239</a></p>
<p>虚拟网络设置选择网卡;分配同主机网段ip</p>
<p>nat:</p>
<p>设置虚拟的IP子网,分配虚拟网关IP</p>
<p>分配适配器和虚拟机虚拟ip</p>
<h2 id="配置环境变量指定交叉编译工具链"><a href="#配置环境变量指定交叉编译工具链" class="headerlink" title="配置环境变量指定交叉编译工具链"></a>配置环境变量指定交叉编译工具链</h2><p>首先你要下载交叉工具链</p>
<p>1)临时指定</p>
<p>只对本次终端有效</p>
<p>export ARCH&#x3D;arm&#x20;<br>export CROSS_COMPILE&#x3D;arm-buildroot-linux-gnueabihf-&#x20;<br>export PATH&#x3D;$PATH:&#x2F;home&#x2F;book&#x2F;100ask_imx6ull-sdk&#x2F;ToolChain&#x2F;arm-buildroot-linux-gnueabihf_sdk-buildroot&#x2F;bin</p>
<p>2)通过配置bash自动脚本永久指定</p>
<p>进入~&#x2F;.bashrc输入上述3条指令</p>
<blockquote>
<p>设置完毕后，要执行<br>source ~&#x2F;.bashrc<br>命令使其生效，可通过<br>arm <em>-buildroot</em>-linux-gnueabihf-gcc -v</p>
</blockquote>
<blockquote>
<p>或echo打印设置的变量</p>
</blockquote>
<blockquote>
<p>验证是否成功</p>
</blockquote>
<h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>开启防火墙</p>
<p>sudo ufw status<br>sudo ufw enable</p>
<p><strong>关闭防火墙</strong></p>
<p>sudo ufw disable</p>

      
    </div>

    
    
    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeinsshiri.github.io/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%89/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zeins_XvJin_Shiri">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeins's Blog">
      <meta itemprop="description" content="在何处付出，便在何处收获">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeins's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%89/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%89/" class="post-title-link" itemprop="url">文件系统（磁盘管理系统）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-07 17:18:48" itemprop="dateCreated datePublished" datetime="2024-02-07T17:18:48+08:00">2024-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-08 16:31:34" itemprop="dateModified" datetime="2024-02-08T16:31:34+08:00">2024-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BD%AF%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">软件</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/183238194" title="一口气搞懂「文件系统」，就靠这 25 张图了 前言不多 BB，直接上「硬菜」。 正文文件系统的基本组成文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以… https://zhuanlan.zhihu.com/p/183238194">一口气搞懂「文件系统」，就靠这 25 张图了 前言不多 BB，直接上「硬菜」。 正文文件系统的基本组成文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以… https://zhuanlan.zhihu.com/p/183238194</a></p>
<p>文件格式：数据以比特流的形式存储，为了能够流通；需要一套编码&#x2F;解码规则，即文件格式；当我们打开一个文件时，计算机会根据文件格式来解析文件的内容，并将其呈现给用户或进行相应的处理操作</p>
<p>文件系统：1，2就是建立数据结构维护数据并设计数据操作算法<br>1）文件存储以及磁盘空间管理：负责在磁盘上分配空间存储文件并记录文件相关信息；文件删除时，文件系统回收这些空间<br>1.2）文件备份和恢复</p>
<p>2）文件管理：实现增删改查，移动，重命名等系统功能；用户通过文件系统的接口管理文件<br>2.2）文件访问控制</p>
<p>3）文件压缩和加密<br>4）文件共享：文件系统可以将文件共享给其他计算机或用户，使得多个用户可以同时访问和修改文件</p>
<h1 id="ELF文件格式"><a href="#ELF文件格式" class="headerlink" title="ELF文件格式"></a>ELF文件格式</h1><table>
<thead>
<tr>
<th>ELF 文件类型</th>
<th>说明</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>可重定位文件(Relocatable File)</td>
<td>包含代码和数据、可被链接为可执行文件或共享目标文件，静态链接库被归为此类</td>
<td>Linux 下的 *.o</td>
</tr>
<tr>
<td>可执行文件(Executable File)</td>
<td>此类文件包含了可以直接执行的文件</td>
<td>&#x2F;bin&#x2F;bash</td>
</tr>
<tr>
<td>共享目标文件(Share Object File)</td>
<td>此类文件包含了可以直接执行的文件</td>
<td>linux 的 *.so&#xA;&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</td>
</tr>
<tr>
<td>核心转储文件(Core Dump File)</td>
<td>当进程意外终止，系统生成的核心转储文件</td>
<td>Linux 下的 core dump文件</td>
</tr>
</tbody></table>
<p><img src="/image/image_s1VyhB2QNc.png"></p>
<p><img src="/image/image_LUCdweUOM0.png"></p>
<h2 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">readelf -h hello.o </span><br><span class="line"><span class="comment">#读取elf文件头；文件头描述文件属性：文件类型、目标硬件、目标操作系统等；</span></span><br><span class="line">- ELF 魔数。</span><br><span class="line">- 文件机器字节长度。</span><br><span class="line">- 数据存储方式。</span><br><span class="line">- 版本。</span><br><span class="line">- 运行平台。</span><br><span class="line">- ABI 版本。</span><br><span class="line">- ELF 重定位类型。</span><br><span class="line">- 硬件平台。</span><br><span class="line">- 硬件平台版本。</span><br><span class="line">- 入口地址（目标文件入口地址为 0，只有相对位置）。</span><br><span class="line">- 程序的入口和长度。</span><br><span class="line">- 段表的位置和长度。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/image/image_R3rXd-Wqm-.png"></p>
<p><img src="/image/image_y9RNrr9HSX.png"></p>
<h2 id="逻辑段表"><a href="#逻辑段表" class="headerlink" title="逻辑段表"></a>逻辑<strong>段表</strong></h2><p><img src="/image/image_e4xoVFJsqZ.png"></p>
<p>readelf -S f1或objdump -h f1查看段表属性</p>
<p><img src="/image/image_FyB2rpFAvp.png"></p>
<p><img src="/image/image_U9l0DJAWpJ.png"></p>
<h2 id="代码段（-text）"><a href="#代码段（-text）" class="headerlink" title="代码段（.text）"></a>代码段（.text）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#C 编译后的机器指令保存在代码段（.text）； </span></span><br><span class="line">objdump -ds hello.o | grep -A 9 -E <span class="string">&#x27;main:&gt;|f:&gt;&#x27;</span><span class="comment">#-d输出汇编源码;-s 16进制显示；过滤main和f函数</span></span><br></pre></td></tr></table></figure>

<p><img src="/image/image_-mG7-kZwwz.png"></p>
<p><img src="/image/image_0taojPzF2G.png"></p>
<h2 id="数据段（-data）"><a href="#数据段（-data）" class="headerlink" title="数据段（.data）"></a>数据段（.data）</h2><p>保存非零初始化全局变量和局部静态变量</p>
<p><img src="/image/image_nXnR1PIlZ8.png"></p>
<h2 id="只读数据段（-rodata）"><a href="#只读数据段（-rodata）" class="headerlink" title="只读数据段（.rodata）"></a>只读数据段（.rodata）</h2><p>const 修饰的变量和字符串常量（包括 printf 函数中的格式化字符串%d）;可以通过优化.rodata 段的大小，进而优化程序的大小</p>
<p><img src="/image/image_GyCTpHeHBT.png"></p>
<h2 id="bss-段"><a href="#bss-段" class="headerlink" title="bss 段"></a>bss 段</h2><p>记录零初始化全局变量&#x2F;局部静态变量大小总和；并预留位置，最终链接时在分配到.bss段（具体和编译器有关）</p>
<h2 id="符号表段（-symtab）"><a href="#符号表段（-symtab）" class="headerlink" title="符号表段（.symtab）"></a>符号表段（.symtab）</h2><p><img src="https://pic3.zhimg.com/80/v2-19eb0bd6897bd2eb201f1f8a8b11a5a6_720w.webp"></p>
<p>以数组结构形式保存符号信息（函数和变量），符号值即地址。</p>
<p>readelf -s查看段表属性：name符号名称；Ndx:所处段；Type:符号类型；value:首字节在段内的偏移量<br>eg:<br>f 和 main 函数的 Ndx 对应的值是 1，表示在.text 段（.text 段在段表中的索引是 1）,类型为 FUNC，value 分别是 0x00000000 和 0x00000040，表明两个函数指令字节码的首字节分别在.text 的 0x00000000 和 0x00000040 偏移处。</p>
<p>printf 的 Ndx 是 UND，表明这个符号在 object_file.o 里面没有被定义，仅仅是引用。</p>
<p>static_val.1843 和 gint_val 两个符号的 Ndx 都是 3，说明他们都被定义在数据段。value 分别是 0x00000000 和 0x00000004，表明两个函数指令字节码的首字节分别在.data 的 0x00000000 和 0x00000004 偏移处。</p>
<h2 id="comment"><a href="#comment" class="headerlink" title=".comment"></a>.comment</h2><p>存放编译器版本信息</p>
<h2 id="符号表-shstrtab-：Section-String-table"><a href="#符号表-shstrtab-：Section-String-table" class="headerlink" title="符号表(.shstrtab)：Section String table"></a>符号表(.shstrtab)：Section String table</h2><p>存放符号的名称字符串</p>
<h2 id="dynamic"><a href="#dynamic" class="headerlink" title=".dynamic"></a>.dynamic</h2><p>动态链接信息</p>
<h2 id="重定位代码段（-rel-text）"><a href="#重定位代码段（-rel-text）" class="headerlink" title="重定位代码段（.rel.text）"></a>重定位代码段（.rel.text）</h2><p>描述在重定位时连接器如何修改相应段里的内容。对于.text，对应的重定位表是.rel.text。使用objdump -r 查看重定位表。</p>
<p><img src="https://pic2.zhimg.com/80/v2-ab4bf8b83a7cf4ec8f2f9496d24ed319_720w.webp"></p>
<h2 id="自定义段表"><a href="#自定义段表" class="headerlink" title="自定义段表"></a><strong>自定义段表</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*GCC 编译出来的目标文件默认放到.text ，全局变量和静态变量默认放到.data 和.bss 段。但有时我们希望有些变量或代码可以放到指定的段中，以实现某些特定功能。*/</span></span><br><span class="line"><span class="comment">//GCC 指定段扩展机制:全局变量或者函数前加入 _attribute_((section(&quot;name&quot;))) 属性就可把变量或函数放入到”name“段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把变量放到start_var_init段：</span></span><br><span class="line">__attribute__((section(<span class="string">&quot;start_var_init&quot;</span>))) <span class="type">int</span> init_status = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//把函数放到start_fun_init段：</span></span><br><span class="line">__attribute__((section(<span class="string">&quot;start_fun_init&quot;</span>))) <span class="type">void</span> <span class="title function_">start_func</span><span class="params">()</span>&#123;    </span><br><span class="line">    <span class="comment">//init code    </span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查看段表中的符号名字符串表shstrtab确认:readelf -s</span></span><br></pre></td></tr></table></figure>

<p><img src="/image/image_sma3mLOaUm.png"></p>
<p><img src="/image/image_R_bVlgz6df.png"></p>
<h1 id="文件系统基本组成"><a href="#文件系统基本组成" class="headerlink" title="文件系统基本组成"></a>文件系统基本组成</h1><p><img src="/image/image_APl8uir-hH.png"></p>
<p>文件系统由2个数据结构维护：<strong>dientry</strong>→inode→盘块中存储的文件内容（目录文件的文件内容是子目录和文件信息）<br>1）<strong>目录项</strong><em><strong>directory entry</strong></em>**（dientry）**:{文件名，inode，与其他目录项的层级关系…};<strong>是由内核维护的数据结构，不存放于磁盘，缓存在内存</strong><br>2）<em><strong>index node</strong></em><strong>（</strong>inode**） **:记录文件的属性:inode 编号、权限、类型、大小、时间、用户、盘块位置等;多数的inode都存储在磁盘上。少量常用、近期使用的inode会被缓存到内存中</p>
<p>硬链接的实现就是多个目录项中的索引节点指向同一个文件</p>
<p>磁盘进行格式化会被分成三个存储区域<br>1）超级块：存储文件系统的详细信息，比如块个数、块大小、空闲块等<br>2）索引节点区<br>3）数据块区<br>当文件系统挂载时超级块区加载进内存；当文件被访问时索引节点区进入内存</p>
<h1 id="虚拟文件系统Virtual-File-System，VFS接口"><a href="#虚拟文件系统Virtual-File-System，VFS接口" class="headerlink" title="虚拟文件系统Virtual File System，VFS接口"></a>虚拟文件系统<em><strong>Virtual File System，VFS</strong></em>接口</h1><p>win常见的文件系统：fat32  ntfs  exfat&#x20;<br>linux常见：<br>1)磁盘文件系统: 它是直接把数据存储在磁盘中，比如 Ext 2&#x2F;3&#x2F;4、XFS 等都是这类文件系统。<br>2)内存文件系统: 这类文件系统的数据不是存储在硬盘的，而是占用内存空间，我们经常用到的 <code>/proc</code> 和 <code>/sys</code> 文件系统都属于这一类，读写这类文件，实际上是读写内核中相关的数据数据。<br>3)网络文件系统:用来访问其他计算机主机数据的文件系统，比如 NFS、SMB 等等。</p>
<p>文件系统的种类众多，故在其上定义了<strong>统一接口</strong>标准vfs<br>文件系统首先要先挂载到某个目录才可以正常使用，比如 Linux 系统在启动时，会把文件系统挂载到根目录。</p>
<p><img src="/image/image_SoU77l0gee.png"></p>
<p>系统调用要经过两层接口：</p>
<p><img src="/image/image_sgp3QStLIm.png"></p>
<p>vfs接口层核心封装:file、dentry、inode、super_block结构体协同工作以实现对各种文件系统的访问和操作</p>
<p><img src="/image/image_WG1yi2l4ZM.png"></p>
<p>PCB</p>
<ul>
<li>File<ul>
<li>dientry<ul>
<li>Inode<ul>
<li>super_block</li>
</ul>
</li>
<li>inode_operations</li>
</ul>
</li>
<li>file_operations</li>
</ul>
</li>
</ul>
<p>进程控制块（Process Control Block，PCB）中维护着一份文件描述符表。索引为文件描述符，表项中FILE*指向维护已打开的文件的file结构体</p>
<p>file结构体指向file_operations结构体，其中的成员都是函数指针，指向各种文件操作的内核函数</p>
<p>file结构体指向dentry结构体，dentry结构体指向inode结构体；</p>
<p>inode结构体指向inode_operations结构体，其中的成员都是函数指针，指向影响文件和目录布局的函数</p>
<p>inode结构体指向super_block结构体，super_block结构体保存着该文件系统的超级块信息，例如文件系统类型、块大小等。同时，super_block结构体的s_root成员是一个指向dentry的指针，表示该文件系统的根目录被挂载到了哪里。</p>
<p>eg:把fd传入fopen()<br>1）fopen根据文件描述符找到打开文件信息的file结构体；<br>2）从dentry获取全局信息和磁盘数据位置<br>3）调用file_operations结构体中的open函数</p>
<h1 id="磁盘上文件系统"><a href="#磁盘上文件系统" class="headerlink" title="磁盘上文件系统"></a>磁盘上文件系统</h1><h2 id="磁盘上的文件系统结构"><a href="#磁盘上的文件系统结构" class="headerlink" title="磁盘上的文件系统结构"></a>磁盘上的文件系统结构</h2><p><img src="/image/image_GkiPYIRBcr.png"></p>
<p>Linux 文件系统由多个块组组成。<strong>每个</strong>块组包含<br>超级块：文件系统全局信息；inode 总数、块总数；各块组 inode 数、块数；文件系统版本号、上次<code>mount</code>的时间等<br>块组描述符表：块组描述符存储当前块组信息；空闲块和空闲 inode 总数，从哪里开始是inode表，数据块等；表中有多个块组描述符<br>数据块区：包含文件有用数据<br>inode列表 ：数据块区中各文件都有一个Inode；其记录文件属性(inode 编号、权限、类型、大小、时间、用户、盘块位置、索引信息等）<br>数据块&#x2F;inode 位图：对应数据块或 inode空间 是空闲，还是被使用中</p>
<p><strong>超级块和块组描述符表</strong>在许多块组开头都有一份拷贝，原因是系统崩溃后；如果有冗余的副本，该信息是可能恢复的。 - 通过使文件和管理数据尽可能接近，减少了磁头寻道和旋转，这可以提高文件系统的性能</p>
<p>Ext2 的后续版本采用了稀疏技术。只写入到块组 0、块组 1 和其他 ID 可以表示为 3、 5、7 的幂的块组中；减少了磁盘空间的占用</p>
<h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><p>非连续存储：即文件数据块链式存储的关键，是要用节点指针&#x2F;额外建立的数据结构存储节点关系</p>
<h3 id="连续存储"><a href="#连续存储" class="headerlink" title="连续存储"></a>连续存储</h3><p><strong>inode需指定「起始块的位置」和「长度」</strong>；<br><strong>优点：读写效率高</strong>，一次磁盘寻道就可读出整个文件<br>缺点：<br>「磁盘碎片」:连续存储文件被删除产生磁盘碎片；存储文件长度要小于磁盘碎片才能存入<br>「文件长度不易扩展」:文件扩展后长度如果＞所在连续空闲空间长度，则不能扩展或扩展非常耗时</p>
<h3 id="隐式链表（指针存储数据块节点关系）"><a href="#隐式链表（指针存储数据块节点关系）" class="headerlink" title="隐式链表（指针存储数据块节点关系）"></a>隐式链表（指针存储数据块节点关系）</h3><p>隐式链表形式：文件头Inode存储起始块和末尾块指针；数据块有一个指针指向下一块；<br>数据块指针会多消耗一些磁盘空间；且通过指针遍历节点的方式访问文件；O(节点数)时间复杂度</p>
<h3 id="显式链表（文件分配表存储数据块节点关系）"><a href="#显式链表（文件分配表存储数据块节点关系）" class="headerlink" title="显式链表（文件分配表存储数据块节点关系）"></a>显式链表（<strong>文件分配表</strong>存储数据块节点关系）</h3><p>Inode存储起始块；内存中开辟<strong>文件分配表（</strong><em><strong>File Allocation Table，FAT</strong></em><strong>）</strong>；数据块号：下个块号的数组；<br>缺点是大磁盘有太多块，fat将会很占内存；优点是查找文件是在内存中进行，文件检索效率加快；支撑随机访问<br>eg:<br>文件A为4-7-2-10-12–1;</p>
<p><img src="/image/image_r0gv14yvR6.png"></p>
<h3 id="索引块（索引块存储数据块节点关系表）"><a href="#索引块（索引块存储数据块节点关系表）" class="headerlink" title="索引块（索引块存储数据块节点关系表）"></a>索引块（索引块存储数据块节点关系<strong>表</strong>）</h3><p>Inode存储索引块指针（索引块可以是1个，或链式，树状多级的多个）→磁盘<strong>索引块</strong>维护的数据块指针；支撑随机访问</p>
<p>若文件大到一个索引数据块放不下索引信息，使用以下两种</p>
<h3 id="链式索引存储（链式索引块存储数据块节点关系）"><a href="#链式索引存储（链式索引块存储数据块节点关系）" class="headerlink" title="链式索引存储（链式索引块存储数据块节点关系）"></a>链式索引存储（链式索引块存储数据块节点关系）</h3><p>Inode存储首个索引块指针，索引块存储文件数据块指针和下一个索引块指针，当索引块存满，就可通过指针找到下一索引块。这种方式会出现链表普遍的问题：万一某个指针损坏了，后面的数据就无法读取了</p>
<p><img src="/image/image_dzTRr3bswL.png"></p>
<h3 id="多级索引存储：（多叉树存储数据块节点关系）"><a href="#多级索引存储：（多叉树存储数据块节点关系）" class="headerlink" title="多级索引存储：（多叉树存储数据块节点关系）"></a><strong>多级索引</strong>存储：（多叉树存储数据块节点关系）</h3><p><img src="/image/image_uk0yGIxi1g.png"></p>
<p><img src="/image/image_Nb6iICv1L1.png"></p>
<p>Linux  Ext 2&#x2F;3文件系统存储方式：<br>根据文件的大小，存放的方式会有所变化：<br>文件所需数据块小于 10 ，则采用直接查找的方式；（Inode指向连续数据块）<br>文件所需数据块超过 10 ，则采用一级间接索引方式；（数据块链式存储，索引块维护数据块指针）<br>前两种方式都不够存放大文件，则采用二级间接索引方式；<br>二级索引也不够存放大文件，采用三级间接索引方式；</p>
<p><img src="/image/image_HOAl9ipYMl.png"></p>
<h3 id="目录文件存储"><a href="#目录文件存储" class="headerlink" title="目录文件存储"></a>目录文件存储</h3><p>磁盘上的目录文件数据块存储文件&#x2F;子目录信息<br>1)默认有.和..两个文件的（Inode,文件类型，文件名）信息<br>2)其他文件的信息都存在一张哈希表中(文件名：文件信息所在块号)</p>
<p>目录查询是通过在磁盘上反复搜索完成，需要不断地进行 I&#x2F;O 操作，开销较大。所以，为了减少 I&#x2F;O 操作，把当前使用的文件目录缓存在内存，以后要使用该文件时只要在内存中操作，从而降低了磁盘操作次数，提高了文件系统的访问速度</p>
<p><img src="/image/image_9AP0mFFLdu.png"></p>
<h2 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h2><p>空闲表法：为空闲空间建一张表，内容为该空闲区第一个块号和连续空闲块数；<br>当请求分配磁盘空间时，系统依次扫描空闲表里的内容，直到找到合适空闲区域；<br>当用户撤销一个文件时，系统回收文件空间；os顺序扫描空闲表找一个空闲表条目并将释放空间的第一个物理块号及它占用的块数填到这个条目中;<br>缺点：<br>当有大量离散分布的空闲区，空闲表将很大，查询效率会很低。另外，这种分配技术适用于建立连续文件。</p>
<p><img src="/image/image_tPEkEry1o2.png"></p>
<p>空闲链表法：每个空闲块里有一个指针指向下一个空闲块;主存中保存一个指针指向第一个空闲块<br>创建文件时:从链头上依次取下需要的块。<br>回收空间时：把这些空闲块依次接到链头上</p>
<p>缺点：不能随机访问，在链上增加或移动空闲块时需要做很多 I&#x2F;O 操作，工作效率低；同时数据块的指针消耗了一定的存储空间。</p>
<p><img src="/image/image_7mIDy-q5h0.png"></p>
<p>位图法（Linux 文件系统采用）：二进制每位都表示磁盘中1个盘块的使用情况，0&#x3D;空闲；1&#x3D;已分配；<br>空闲Inode位图和空闲数块位图管理磁盘数据空闲块和 inode 空闲块</p>
<h1 id="软硬链接"><a href="#软硬链接" class="headerlink" title="软硬链接"></a>软硬链接</h1><p>硬链接是**多个文件的dientry的「索引节点」**指向同一个 inode;即指向同一文件；<br><strong>只有删除所有硬链接及原文件对inode的索引，系统才会彻底删除该文件</strong></p>
<p><img src="/image/image_XIeDjlmue4.png"></p>
<p>软链接创建有<strong>独立的 inode</strong>的文件，但<strong>文件内容是另一文件的路径</strong>，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以<strong>软链接是可跨文件系统的</strong></p>
<p><img src="/image/image_r1yADyjkt3.png"></p>
<h1 id="文件操作posix"><a href="#文件操作posix" class="headerlink" title="文件操作posix"></a>文件操作posix</h1><h2 id="stat-access-utime"><a href="#stat-access-utime" class="headerlink" title="stat&#x2F;access&#x2F;utime"></a>stat&#x2F;access&#x2F;utime</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">dev_t</span>     st_dev;     <span class="comment">/* 设备号（主设备号，次设备号）*/</span></span><br><span class="line">    <span class="type">ino_t</span>     st_ino;     <span class="comment">/* inode的数量 */</span></span><br><span class="line">    <span class="type">mode_t</span>    st_mode;    <span class="comment">/* 文件的类型和存取的权限 */</span></span><br><span class="line">    <span class="type">nlink_t</span>   st_nlink;   <span class="comment">/* 硬链接的数量 */</span></span><br><span class="line">    <span class="type">uid_t</span>     st_uid;     <span class="comment">/* 所用者的uid */</span></span><br><span class="line">    <span class="type">gid_t</span>     st_gid;     <span class="comment">/* 所有者的组id */</span></span><br><span class="line">    <span class="type">dev_t</span>     st_rdev;    <span class="comment">/* device ID (if special file) */</span></span><br><span class="line">    <span class="type">off_t</span>     st_size;    <span class="comment">/* 总大小,字节数 */</span></span><br><span class="line">    <span class="type">blksize_t</span> st_blksize; <span class="comment">/* blocksize for filesystem I/O */</span></span><br><span class="line">    <span class="type">blkcnt_t</span>  st_blocks;  <span class="comment">/* number of 512B blocks allocated */</span></span><br><span class="line">    <span class="type">time_t</span>    st_atime;   <span class="comment">/* 最后访问时间（access）*/</span></span><br><span class="line">    <span class="type">time_t</span>    st_mtime;   <span class="comment">/* 最后修改时间（modification）文件内容的改动时间 */</span></span><br><span class="line">    <span class="type">time_t</span>    st_ctime;   <span class="comment">/* 最后改动时间（change）文件属性的改动时间 */</span></span><br><span class="line">&#125;;</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//根据传入文件路径读取文件的inode，把inode文件属性填入一个struct stat结构体传出给调用者。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">stat/fstat检查符号链接时，检查的是符号链接所引用的文件</span></span><br><span class="line"><span class="comment">lstat检查符号链接时，检查的是符号链接本身</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*实现原理：假设传入路径/opt/file</span></span><br><span class="line"><span class="comment">1）读出inode表中第2项，即根目录inode，并找到根目录数据块位置</span></span><br><span class="line"><span class="comment">2）从根目录的数据块中找出文件名为opt的记录，从记录中读出它的inode号</span></span><br><span class="line"><span class="comment">3）读出opt目录的inode，从中找出它的数据块的位置</span></span><br><span class="line"><span class="comment">4）从opt目录的数据块中找出文件名为file的记录，从记录中读出它的inode号</span></span><br><span class="line"><span class="comment">5）读出file文件的inode</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> stat(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> stat *buf);</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"></span><br><span class="line">@ret:成功返回<span class="number">0</span>；失败返回<span class="number">-1</span>，并设置相应errno的值</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//检查执行当前进程的用户访问pathname是否有mode权限</span></span><br><span class="line"><span class="comment">//实现：access函数取出文件inode中的st_mode字段，比较一下访问权限</span></span><br><span class="line"><span class="type">int</span> access(<span class="type">const</span> <span class="type">char</span> * pathname,  <span class="type">int</span> mode);</span><br><span class="line"></span><br><span class="line">@mode:</span><br><span class="line"><span class="number">06</span> 检查读写权限</span><br><span class="line">R_OK/<span class="number">04</span> 检查读权限(目录的读是能否ls)</span><br><span class="line">W_OK/<span class="number">02</span> 检查写权限</span><br><span class="line">X_OK /<span class="number">01</span> 检查执行权限(目录的执行是cd)</span><br><span class="line">F_OK/<span class="number">00</span> 检查文件的存在性</span><br><span class="line"></span><br><span class="line">@ret:返回<span class="number">0</span>表示允许访问，返回<span class="number">-1</span>表示错误或不允许访问；并设置erno:</span><br><span class="line">EACCESS  参数pathname 所指定的文件不符合所要求测试的权限。</span><br><span class="line">EROFS   欲测试写入权限的文件存在于只读文件系统内。</span><br><span class="line">EFAULT  参数pathname指针超出可存取内存空间。</span><br><span class="line">EINVAL  参数mode 不正确。</span><br><span class="line">ENAMETOOLONG  参数pathname太长。</span><br><span class="line">ENOTDIR  参数pathname为一目录。</span><br><span class="line">ENOMEM  核心内存不足    </span><br><span class="line">ELOOP   参数pathname有过多符号连接问题。</span><br><span class="line">EIO I/O  存取错误。</span><br><span class="line">============================================================================================</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="chown-chmod-utime-truncate"><a href="#chown-chmod-utime-truncate" class="headerlink" title="chown&#x2F;chmod&#x2F;utime&#x2F;truncate"></a>chown&#x2F;chmod&#x2F;utime&#x2F;truncate</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//改变文件所有者和组，即修改inode中的User和Group字段，只有超级用户才能正确调用这几个函数</span></span><br><span class="line"><span class="comment">/*差异：</span></span><br><span class="line"><span class="comment">chown、fchown修改符号链接时，修改符号链接指向的文件的权限</span></span><br><span class="line"><span class="comment">lchown修改软链接时，修改的是符号链接权限。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span>;<span class="comment">//posix</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fchown</span><span class="params">(<span class="type">int</span> fd, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span>;<span class="comment">//ansi</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lchown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span>;</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="comment">//改变文件的访问权限，也就是修改inode中的st_mode字段</span></span><br><span class="line">============================================================================================</span><br><span class="line"><span class="comment">//改变文件的访问时间和修改时间，也就是修改inode中的atime和mtime字段</span></span><br><span class="line">============================================================================================</span><br><span class="line"><span class="comment">//把文件截断到某个长度，若比原来短，则后面的数据被截掉了，比原来长，则后面多出来的部分用0填充，这需要修改inode中的Blocks索引项以及块位图中相应的bit</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="link-symlink-unlink-readlink"><a href="#link-symlink-unlink-readlink" class="headerlink" title="link&#x2F;symlink&#x2F;unlink&#x2F;readlink"></a>link&#x2F;symlink&#x2F;unlink&#x2F;readlink</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建硬链接，其原理是在目录的数据块中添加一条新记录，其中的inode号字段和原文件相同</span></span><br><span class="line">============================================================================================</span><br><span class="line"><span class="comment">//创建一个符号链接，这需要创建一个新的inode，其中st_mode字段的文件类型是符号链接，原文件的路径保存在inode中或者分配一个数据块来保存</span></span><br><span class="line">============================================================================================</span><br><span class="line"><span class="comment">//删除一个链接。如果是符号链接则释放这个符号链接的inode和数据块，清除inode位图和块位图中相应的位。如果是硬链接则从目录的数据块中清除一条文件名记录，如果当前文件的硬链接数已经是1了还要删除它，就同时释放它的inode和数据块，清除inode位图和块位图中相应的位</span></span><br><span class="line">============================================================================================</span><br><span class="line"><span class="comment">//读取一个符号链接所指向的目标路径，其原理是从符号链接的inode或数据块中读出保存的数据，这就是目标路径</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//给文件改名，移动文件位置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br><span class="line"></span><br><span class="line">@ret:成功返回<span class="number">0</span>，失败返回<span class="number">-1</span>，并设置相应errno</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变文件名，需要修改目录数据块中的文件名记录，如果原文件名和新文件名不在一个目录下则需要从原目录数据块中清除一条记录然后添加到新目录的数据块中。mv(1)命令是基于rename函数实现的，因此在同一分区的不同目录中移动文件并不需要复制和删除文件的inode和数据块，只需要一个改名操作，即使要移动整个目录，这个目录下有很多子目录和文件也要随着一起移动，移动操作也只是对顶级目录的改名操作，很快就能完成。但是，如果在不同的分区之间移动文件就必须复制和删除inode和数据块，如果要移动整个目录，所有子目录和文件都要复制删除，这就很慢了</span></span><br></pre></td></tr></table></figure>

<h2 id="basename-dirname"><a href="#basename-dirname" class="headerlink" title="basename&#x2F; dirname"></a><strong>basename&#x2F;</strong> dirname</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libgen.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">dirname</span><span class="params">(<span class="type">char</span> *path)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">basename</span><span class="params">(<span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure>

<p>mkdir&#x2F;rmdir</p>
<h2 id="opendir-closedir"><a href="#opendir-closedir" class="headerlink" title="opendir&#x2F;closedir"></a>opendir&#x2F;closedir</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">  <span class="type">ino_t</span>          d_ino;       <span class="comment">/* inode number */</span></span><br><span class="line">  <span class="type">off_t</span>          d_off;       <span class="comment">/* offset to the next dirent */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> d_reclen;    <span class="comment">/* length of this record */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>  d_type;      <span class="comment">/* type of file */</span></span><br><span class="line">  <span class="type">char</span>           d_name[<span class="number">256</span>]; <span class="comment">/* filename */</span></span><br><span class="line">&#125;;</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="comment">//根据目录的路径字符串，返回一个DIR指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭DIR指针所指向的目录流</span></span><br></pre></td></tr></table></figure>

<h2 id="seekdir"><a href="#seekdir" class="headerlink" title="seekdir"></a>seekdir</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将DIR指针所指向的目录流偏移跳跃到某一位置</span></span><br></pre></td></tr></table></figure>

<h2 id="readdir"><a href="#readdir" class="headerlink" title="readdir"></a>readdir</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据DIR指针，返回DIR指针所指向的目录项的指针（dirent *）</span></span><br></pre></td></tr></table></figure>

<h2 id="telldir"><a href="#telldir" class="headerlink" title="telldir"></a>telldir</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回DIR指针所指向目录流的当前位置（long类型）</span></span><br></pre></td></tr></table></figure>

<h2 id="getcwd"><a href="#getcwd" class="headerlink" title="getcwd"></a>getcwd</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *buf,<span class="type">size_t</span> size)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ex"><a href="#ex" class="headerlink" title="ex"></a>ex</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归列出目录下文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_PATH 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* dirwalk:  apply fcn to all files in dir */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dirwalk</span><span class="params">(<span class="type">char</span> *dir, <span class="type">void</span> (*fcn)(<span class="type">char</span> *))</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[MAX_PATH];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dp</span>;</span></span><br><span class="line">  DIR *dfd;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((dfd = opendir(dir)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;dirwalk: can&#x27;t open %s\n&quot;</span>, dir);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ((dp = readdir(dfd)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dp-&gt;d_name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span></span><br><span class="line">        || <span class="built_in">strcmp</span>(dp-&gt;d_name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;    <span class="comment">/* skip self and parent */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(dir)+<span class="built_in">strlen</span>(dp-&gt;d_name)+<span class="number">2</span> &gt; <span class="keyword">sizeof</span>(name))</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;dirwalk: name %s %s too long\n&quot;</span>,</span><br><span class="line">        dir, dp-&gt;d_name);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">sprintf</span>(name, <span class="string">&quot;%s/%s&quot;</span>, dir, dp-&gt;d_name);</span><br><span class="line">      (*fcn)(name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  closedir(dfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fsize:  print the size and name of file &quot;name&quot; */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fsize</span><span class="params">(<span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stbuf</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stat(name, &amp;stbuf) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fsize: can&#x27;t access %s\n&quot;</span>, name);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((stbuf.st_mode &amp; S_IFMT) == S_IFDIR)</span><br><span class="line">    dirwalk(name, fsize);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%8ld %s\n&quot;</span>, stbuf.st_size, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc == <span class="number">1</span>)  <span class="comment">/* default: current directory */</span></span><br><span class="line">    fsize(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">while</span> (--argc &gt; <span class="number">0</span>)</span><br><span class="line">      fsize(*++argv);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个程序还是不如ls -R健壮，它有可能死循环，思考一下什么情况会导致死循环</span></span><br></pre></td></tr></table></figure>

<p>文件组织；文件保护；文件映射，文件共享</p>
<p>readelf -h hello.o读取</p>

      
    </div>

    
    
    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeinsshiri.github.io/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E6%96%87%E4%BB%B6IO/%E6%96%87%E4%BB%B6IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zeins_XvJin_Shiri">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeins's Blog">
      <meta itemprop="description" content="在何处付出，便在何处收获">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeins's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E6%96%87%E4%BB%B6IO/%E6%96%87%E4%BB%B6IO/" class="post-title-link" itemprop="url">文件IO</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-07 17:18:48" itemprop="dateCreated datePublished" datetime="2024-02-07T17:18:48+08:00">2024-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-08 16:31:22" itemprop="dateModified" datetime="2024-02-08T16:31:22+08:00">2024-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BD%AF%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">软件</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>16k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-function-fread.html" title=" C 库函数 – fread() | 菜鸟教程 C 库函数 - fread()   C 标准库 - &lt;stdio.h&gt;  描述 C 库函数 size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) 从给定流 stream 读取数据到 ptr 所指向的数组中。 声明 下面是 fread() 函数的声明。  size_t fread(void *ptr, size_ https://www.runoob.com/cprogramming/c-function-fread.html"> C 库函数 – fread() | 菜鸟教程 C 库函数 - fread()   C 标准库 - &amp;lt;stdio.h&amp;gt;  描述 C 库函数 size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) 从给定流 stream 读取数据到 ptr 所指向的数组中。 声明 下面是 fread() 函数的声明。  size_t fread(void *ptr, size_ https://www.runoob.com/cprogramming/c-function-fread.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/linuxapi/README.md" title=" 阅前必读 - 《Linux API速查手册》 - 书栈网 · BookStack Linux API速查手册https://github.com/guodongxiaren/LinuxAPI/wiki果冻虾仁 的Linux系统编程学习记录 Linux API速查手册 https://www.bookstack.cn/read/linuxapi/README.md"> 阅前必读 - 《Linux API速查手册》 - 书栈网 · BookStack Linux API速查手册https://github.com/guodongxiaren/LinuxAPI/wiki果冻虾仁 的Linux系统编程学习记录 Linux API速查手册 https://www.bookstack.cn/read/linuxapi/README.md</a></p>
<h1 id="IO机制-编写zeinsos再去弄懂"><a href="#IO机制-编写zeinsos再去弄懂" class="headerlink" title="IO机制?编写zeinsos再去弄懂"></a>IO机制?编写zeinsos再去弄懂</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/183238194" title="https://zhuanlan.zhihu.com/p/183238194">https://zhuanlan.zhihu.com/p/183238194</a></p>
<h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p>全缓冲:缓冲区写满了就写回内核。读写常规文件通常是全缓冲的。</p>
<p>行缓冲:如果用户程序写的数据中有换行符就把这一行写回内核，或者如果缓冲区写满了就写回内核。标准输入和标准输出对应终端设备时通常是行缓冲的。</p>
<p>无缓冲:用户程序每次调库函数做写操作都要通过系统调用写回内核。标准错误输出通常是无缓冲的，这样用户程序产生的错误信息可以尽快输出到设备。</p>
<h2 id="IO缓冲机制"><a href="#IO缓冲机制" class="headerlink" title="IO缓冲机制"></a>IO缓冲机制</h2><p>ansi接口特性：<br>1）跨平台移植性<br>2.1）写缓冲：使用ansi写磁盘，会在用户进程空间创建buffer（默认4096K），写满后一次性进行系统调用把数据写进内核进程空间buffer,内核再进行驱动调用写进磁盘（os缓输出：会在空闲时择机刷到磁盘）；避免因频繁系统&#x2F;驱动调用造成cpu频繁变态（暂存和时间开销）；且直接操作高速设备，减少了等待时间<br>2.2）读缓冲：第一次读磁盘进行系统调用时在用户进程空间开辟buffer缓存从磁盘中读出的数据;再次需要读时直接从buffer读；cpu就不用频繁变态（os预读入：读磁盘会尽量读出更多数据到内核buffer）；且缓存后操作的是高速设备<br>2.3)3种缓冲区类型：</p>
<p>IO频率高，用ansi快,频率低，sys_call实时性好</p>
<h2 id="直接与非直接-I-O机制"><a href="#直接与非直接-I-O机制" class="headerlink" title="直接与非直接 I&#x2F;O机制"></a>直接与非直接 I&#x2F;O机制</h2><h2 id="阻塞与非阻塞-I-O-VS-同步与异步-I-O"><a href="#阻塞与非阻塞-I-O-VS-同步与异步-I-O" class="headerlink" title="阻塞与非阻塞 I&#x2F;O VS 同步与异步 I&#x2F;O"></a>阻塞与非阻塞 I&#x2F;O VS 同步与异步 I&#x2F;O</h2><h2 id="内核读写机制"><a href="#内核读写机制" class="headerlink" title="内核读写机制"></a>内核读写机制</h2><p>内核进程读缓存机制：内核把已读过的目录用目录项这个数据结构缓存在内存，再读到相同目录只需从内存读，提高了文件系统效率</p>
<p>内核进程进行磁盘读写最小单位为数据块：<br>1）磁盘读写的最小单位是<strong>扇区</strong>（<code>512B</code>） ，为提高读写效率，设置每次读写数据块（Linux ：<code>4KB</code>8 个扇区）；<br>eg:<br>用户进程从文件读 1 字节，文件系统则要获取字节所在数据块（内核空间），再返回数据块对应的用户进程所需的数据部分。<br>用户进程写 1 字节进文件，文件系统则找到要写入数据的数据块位置，修改数据块中对应部分，最后再把数据块写回磁盘</p>
<h2 id="打开文件表"><a href="#打开文件表" class="headerlink" title="打开文件表"></a>打开文件表</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">os为每个进程维护一个打开文件表&#123;</span><br><span class="line">    文件位置指针：os跟踪上次读写位置作为当前文件位置指针</span><br><span class="line">    文件打开计数器：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件，该计数器跟踪打开和关闭的数量，当该计数为 0 时，系统关闭文件，删除该条目；</span><br><span class="line">    文件磁盘位置：</span><br><span class="line">    访问权限：进程打开文件有访问模式（创建、只读、读写、添加等），该信息以便操作系统能允许或拒绝 I/O 请求；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ANSI"><a href="#ANSI" class="headerlink" title="ANSI"></a>ANSI</h1><h2 id="stdio-h库全局变量-库宏-库变量类型"><a href="#stdio-h库全局变量-库宏-库变量类型" class="headerlink" title="stdio.h库全局变量&#x2F;库宏&#x2F;库变量类型"></a>stdio.h库全局变量&#x2F;库宏&#x2F;库变量类型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span>：无符号整数类型，它是 <span class="keyword">sizeof</span> 关键字的结果。</span><br><span class="line">FILE：存储文件流信息的结构体类型。</span><br><span class="line"><span class="type">fpos_t</span>：这是一个适合存储文件中任何位置的对象类型</span><br><span class="line"></span><br><span class="line">errno:调用函数出错时，会重新设置了errno字符串全局变量</span><br><span class="line"></span><br><span class="line"><span class="literal">NULL</span>：空指针常量</span><br><span class="line"></span><br><span class="line">SEEK_CUR、SEEK_END 和 SEEK_SET：fseek 函数中使用，表示文件读写指针（光标位置）</span><br><span class="line"></span><br><span class="line">EOF：文档的结尾都有一个隐藏字符”EOF”，当程序读取它的时候，就会知道文件已经到达结尾；文件结束符只能被clearerr函数清除</span><br><span class="line"></span><br><span class="line"><span class="built_in">stderr</span>、<span class="built_in">stdin</span> 和 <span class="built_in">stdout</span>：这些宏是指向 FILE 类型的指针，对应于标准错误、标准输入和标准输出流。</span><br><span class="line"></span><br><span class="line">_IOFBF、_IOLBF 和 _IONBF：这些宏扩展了带有特定值的整型常量表达式，并适用于 setvbuf 函数的第三个参数。</span><br><span class="line"></span><br><span class="line">BUFSIZ：这个宏是一个整数，该整数代表了 setbuf 函数使用的缓冲区大小。</span><br><span class="line"></span><br><span class="line">FOPEN_MAX：这个宏是一个整数，该整数代表了系统可以同时打开的文件数量。</span><br><span class="line"></span><br><span class="line">FILENAME_MAX：这个宏是一个整数，该整数代表了字符数组可以存储的文件名的最大长度。如果实现没有任何限制，则该值应为推荐的最大值。</span><br><span class="line"></span><br><span class="line">L_tmpnam：这个宏是一个整数，该整数代表了字符数组可以存储的由 tmpnam 函数创建的临时文件名的最大长度。</span><br><span class="line"></span><br><span class="line">TMP_MAX：这个宏是 tmpnam 函数可生成的独特文件名的最大数量。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="fopen-fclose"><a href="#fopen-fclose" class="headerlink" title="fopen&#x2F;fclose"></a>fopen&#x2F;fclose</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line">FILE *<span class="title function_">fdopen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line">FILE *<span class="title function_">freopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *mode, FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line">@path:文件路径名</span><br><span class="line">@mode:打开方式</span><br><span class="line">r  只读，文件必须已存在</span><br><span class="line">r+  可读可写，文件必须已存在（用于更新）</span><br><span class="line">w  只写，不存在则创建，已存在则删除已有文件内容（视为新的空文件）</span><br><span class="line">w+  可读可写，文件不存在则创建，已存在则截断为<span class="number">0</span>字节（视为新的空文件）（用于更新）</span><br><span class="line">a  只允许追加数据，文件不存在则创建</span><br><span class="line">a+  允许读和追加数据，文件不存在则创建</span><br><span class="line">@RET:成功，返回文件指针（FILE *）；否则返回 <span class="literal">NULL</span>，且设置全局变量 errno 标识错误</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fclose(FILE *fp);</span><br><span class="line"></span><br><span class="line">@fp:打开文件的指针</span><br><span class="line">@RET:</span><br><span class="line"><span class="number">0</span>  成功</span><br><span class="line">EOF  失败（EOF为stdio.h定义的宏，=<span class="number">-1</span>）；并设置适当errno的值。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>mode参数加b表示二进制形式打开&#x2F;关闭，否则默认为文本模式t；二进制模式处理是为了跨平台，因为win平台字符处理时会把\n转化为\r\n</p>
<h2 id="fseek-rewind-ftell"><a href="#fseek-rewind-ftell" class="headerlink" title="fseek&#x2F;rewind&#x2F;ftell"></a>fseek&#x2F;rewind&#x2F;ftell</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//移动文件读写位置光标</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *fp,<span class="type">long</span> offset,<span class="type">int</span> whence)</span>;</span><br><span class="line"></span><br><span class="line">@fp:指向打开的文件</span><br><span class="line">@offset:相较whence的偏移字节</span><br><span class="line">@whence:文件内部指针的基准：</span><br><span class="line">SEEK_SET 文件开始位置，其值为<span class="number">0</span></span><br><span class="line">SEEK_CUR 文件当前位置，其值为<span class="number">1</span></span><br><span class="line">SEEK_END 文件结束位置，其值为<span class="number">2</span></span><br><span class="line">@RET:成功<span class="number">0</span>。失败<span class="number">-1</span></span><br><span class="line">============================================================================================</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//重置文件指针到开始位置</span></span><br><span class="line"><span class="type">void</span> rewind(FILE *fp);</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="type">long</span> ftell(FILE *fp);</span><br><span class="line"></span><br><span class="line">@RET:出错返回<span class="number">-1</span>;否则报告当前光标位置距离文件开始处是第几个字符</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="fwrite-fread"><a href="#fwrite-fread" class="headerlink" title="fwrite&#x2F;fread"></a>fwrite&#x2F;fread</h2><p>fread不区分文件结束和错误。如有必要，请使用feof和ferror</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr,<span class="type">size_t</span> size,<span class="type">size_t</span> n,FILE *fp)</span>;</span><br><span class="line"></span><br><span class="line">@ptr:要写入数据内存块的指针</span><br><span class="line">@size:要写入的字节大小，通常为<span class="keyword">sizeof</span>(数据类型)。</span><br><span class="line">@n:写入内存块个数</span><br><span class="line">@fp:要写入文件的指针</span><br><span class="line">@RET:返回写入内存块个数，若与 n 不同，则可能发生了一个错误或者到达了文件末尾。</span><br><span class="line">如果成功写入，文件内部指针会向右移动n*size</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> fread(<span class="type">void</span> *ptr,<span class="type">size_t</span> size,<span class="type">size_t</span> n,FILE *fp);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="fputs-fgets"><a href="#fputs-fgets" class="headerlink" title="fputs&#x2F;fgets"></a>fputs&#x2F;fgets</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//将s指向的字符串，舍去结束标记’\0’后写入到fp指向的文件缓冲区</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s,FILE *fp)</span>;</span><br><span class="line"></span><br><span class="line">@s：指向要写入的字符串</span><br><span class="line">@fp:指向被写入的文件（文件缓冲区）</span><br><span class="line">@RET:返回写入的实际字符数；出现错误，返回EOF</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="comment">//从fp所指向的文件缓冲区当前位置读size-1个字符，并在其后补充’\0’，写入到s指向的内存区；读取到换行符，或到达文件末尾会停止</span></span><br><span class="line"><span class="type">char</span> *fgets(<span class="type">char</span> *s,<span class="type">int</span> size,FILE *fp);</span><br><span class="line"></span><br><span class="line">@RET:成功，返回相同的 fp 参数。如果到达文件末尾或者没有读取到任何字符，返回一个空指针。如果发生错误，返回一个空指针</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="fgetc-fputc"><a href="#fgetc-fputc" class="headerlink" title="fgetc&#x2F;fputc"></a>fgetc&#x2F;fputc</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getchar</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> c, FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">putchar</span><span class="params">(<span class="type">int</span> c)</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="feof-ferror-clearerr-perror"><a href="#feof-ferror-clearerr-perror" class="headerlink" title="feof&#x2F;ferror&#x2F;clearerr&#x2F;perror"></a>feof&#x2F;ferror&#x2F;clearerr&#x2F;perror</h2><p>EOF 宏表示读到文件结尾，还能表示 I&#x2F;O 操作中的读、写错误以及其他一些关联操作的错误状态。仅凭返回 EOF(-1) 就认为文件结束显然是不正确的。 &#x20;<br>实际的程序中，应该每执行一次文件操作，就用 ferror 函数检测是否出错（IO操作<strong>返回值也有所反映</strong>）；用 feof 函数检测文件是否结束</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *fp)</span>;<span class="comment">//查看光标后是否还有内容，有返回0，无返回1</span></span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">    FILE *p;</span><br><span class="line">    p = fopen(<span class="string">&quot;open.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);<span class="comment">//空文件</span></span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) </span><br><span class="line">     &#123;</span><br><span class="line">        perror(<span class="string">&quot;打开文件时发生错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    getc(p);</span><br><span class="line">    <span class="keyword">if</span> (feof(p))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件为空。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rewind(p);<span class="comment">//将光标跳回到文件开头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//无论是空文件，还是存有信息的文件，当文件被打开，光标处于默认的开头时，光标后都有信息(空文件中有EOF)；所以要光标向后一位在调用feof；</span></span><br><span class="line">============================================================================================</span><br><span class="line"><span class="type">int</span> ferror(FILE *fp);<span class="comment">//返回为真时就表示有错误发生</span></span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">   fp = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);<span class="comment">//空文件</span></span><br><span class="line">   c = fgetc(fp);</span><br><span class="line">   <span class="keyword">if</span>( ferror(fp) )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;读取文件：file.txt 时发生错误\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   clearerr(fp);</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="type">void</span> clearerr(FILE *stream)<span class="comment">//清除给定流(字节序列) 的文件结束和错误标识符</span></span><br><span class="line">============================================================================================</span><br><span class="line"><span class="type">void</span> perror(<span class="type">const</span> <span class="type">char</span> *str)</span><br><span class="line"><span class="comment">//把一个自定义错误描述str输出到 stderr。首先输出字符串 str，后跟一个冒号，然后是一个空格，然后是errno</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="printf-scanf"><a href="#printf-scanf" class="headerlink" title="printf&#x2F;scanf"></a>printf&#x2F;scanf</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//*printf打印到标准输出，fprintf打印到指定的文件。sprintf打印到用户提供的缓冲区str中并在末尾加&#x27;\0&#x27;；</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line">@RET:成功返回格式化输出的字节数（不包括字符串的结尾<span class="string">&#x27;\0&#x27;</span>），出错返回一个负值</span><br><span class="line"></span><br><span class="line"><span class="comment">//snprintf更安全，参数size指定了缓冲区长度，若格式化后字符串长度超过缓冲区，snprintf就把字符串截断到size-1字节，再加上一个&#x27;\0&#x27;写入缓冲区，能保证字符串以&#x27;\0&#x27;结尾</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line">@RET:成功返回格式化输出的字节数（不包括字符串的结尾<span class="string">&#x27;\0&#x27;</span>），出错返回一个负值;</span><br><span class="line">如果字符串被截断，返回的是截断之前的长度，把它和实际缓冲区中的字符串长度相比较就可以知道是否发生了截断。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vsnprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//scanf从标准输入读字符，按format解释这些字符后赋给后面的传出参数(传地址而不能传值);fscanf从指定的文件中读字符</span></span><br><span class="line"><span class="comment">//而sscanf从指定的字符串str中读字符</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">scanf</span>(<span class="type">const</span> <span class="type">char</span> *format, ...);</span><br><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line">@RET:成功匹配一个转换说明就给一个参数赋值，如果读到文件或字符串末尾就停止</span><br><span class="line">或者如果遇到和格式化字符串不匹配的地方（比如转换说明是%d却读到字符A）就停止。则<span class="built_in">scanf</span>的返回值可能小于赋值参数的个数，文件的读写位置指向输入中不匹配的地方，下次调用库函数读文件时可以从这个位置继续。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vsscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfscanf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line">============================================================================================</span><br><span class="line">%d 十进制有符号整数</span><br><span class="line">%u 十进制无符号整数</span><br><span class="line">%f 浮点数</span><br><span class="line">%s 字符串</span><br><span class="line">%c 单个字符</span><br><span class="line">%p 指针的值</span><br><span class="line">%e 指数形式的浮点数</span><br><span class="line">%x, %X 无符号以十六进制表示的整数</span><br><span class="line">%o 无符号以八进制表示的整数</span><br><span class="line">%g 把输出的值按照 %e 或者 %f 类型中输出长度较小的方式输出</span><br><span class="line">%p 输出地址符</span><br><span class="line">%lu <span class="number">32</span>位无符号整数</span><br><span class="line">%llu <span class="number">64</span>位无符号整数</span><br><span class="line">%% 输出百分号字符本身。</span><br><span class="line">%<span class="number">-10</span>s：左对齐并占用宽度为 <span class="number">10</span> 的字符串；</span><br><span class="line">%<span class="number">5.2f</span>：右对齐并占用宽度为 <span class="number">5</span>，保留两位小数的浮点数；</span><br><span class="line">%<span class="meta">#x：输出带有 0x 前缀的十六进制数。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h1><h2 id="open-close"><a href="#open-close" class="headerlink" title="open&#x2F;close"></a>open&#x2F;close</h2><p>查看进程当前已打开的文件描述符：cat &#x2F;proc&#x2F;进程ID&#x2F;fd</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname,<span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname,<span class="type">int</span> flags,<span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">creat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname,<span class="type">mode_t</span> mode)</span>;</span><br><span class="line"></span><br><span class="line">@flags：位图参数；&lt;fcntl.h&gt;中的<span class="number">3</span>类宏可位或|</span><br><span class="line"><span class="number">1</span>）访问方式</span><br><span class="line">O_RDONLY：  只读</span><br><span class="line">O_WRONLY：  只写</span><br><span class="line">O_RDWR：  可读写</span><br><span class="line"><span class="number">2</span>）打开时标志</span><br><span class="line">O_CREAT：  不存在则创建。使用此选项时需要提供第三个参数mode，表示该文件的访问权限；无此标志时打开文件不存在会出错返回</span><br><span class="line">O_EXCL：  与O_CREAT联用，如果文件已存在则返回错误</span><br><span class="line">O_TRUNC：  如果文件已存在，且以只写或可读可写方式打开，则将其长度截断（Truncate）为<span class="number">0</span>字节；即清空文件的内容，仅对普通文件有用；</span><br><span class="line">         open一个文件时必须明确指定O_TRUNC才会截断文件，否则直接在原来的数据上改写</span><br><span class="line">O_NOATIME：不更新访问时间戳</span><br><span class="line">O_NOCTTY：  若打开的文件是终端设备，不让它作为该进程的控制终端</span><br><span class="line">O_NOBLOCK：  以非阻塞模式访问；read/write不会阻塞</span><br><span class="line">O_DIRECTORY：如果文件名是目录，则打开失败</span><br><span class="line"><span class="number">3</span>）IO操作方式</span><br><span class="line">O_DIRECT：   直接IO</span><br><span class="line">O_APPEND：  追加而非覆盖</span><br><span class="line">O_NONBLOCK：  对文件的read()/write()，当无立即可用输入(或输出不能立即写出)时能以EAGAIN错误状态标志立即返回</span><br><span class="line">O_ASYNC：  (异步)此标志被设置，文件描述符有输入数据时会生成SIGIO信号</span><br><span class="line">O_SYNC：每次write都等到物理 I/O 操作完成后才返回</span><br><span class="line">O_DSYNC：等待物理 I/O 数据完成，不等待文件属性更新</span><br><span class="line">O_RSYNC</span><br><span class="line">@mode：知道具有权限；实际要&amp;~umask</span><br><span class="line">@RET：成功返回新分配的文件描述符，出错返回<span class="number">-1</span>并设置errno</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> close(<span class="type">int</span> fd);</span><br><span class="line"></span><br><span class="line">@RET：成功返回<span class="number">0</span>，出错返回<span class="number">-1</span>并设置errno</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h2><p>内核中对一个文件描述符（fd）的偏移量只维护一个值，也就是说你用读写方式打开一个文件，如果先用read读取了n个字符，紧接着用write写入字符，那么后来写入字符从n+1个字符位置开始。所以需要用lseek来使fd的偏移量置于文件开始位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"></span><br><span class="line">@fd：文件描述符</span><br><span class="line">@offset：偏移量</span><br><span class="line">@whence：偏移量的基准位置。</span><br><span class="line">SEEK_SET 文件开始位置，其值为<span class="number">0</span></span><br><span class="line">SEEK_CUR 文件当前位置，其值为<span class="number">1</span></span><br><span class="line">SEEK_END 文件结束位置，其值为<span class="number">2</span></span><br><span class="line">@RET:</span><br></pre></td></tr></table></figure>

<h2 id="read-write"><a href="#read-write" class="headerlink" title="read&#x2F;write"></a>read&#x2F;write</h2><p>当进程调用一个阻塞的系统函数时，该进程被置于睡眠（Sleep）状态，这时内核调度其它进程运行（read内部实现中：如果缓冲区中没有数据可读，就切换到阻塞态）；<br>直到该进程等待的事件发生了（比如网络上接收到数据包，或者调用<code>sleep</code>指定的睡眠时间到了）它才有可能继续运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"></span><br><span class="line">@fd: 文件描述符</span><br><span class="line">@buf:  读取数据存在buf指针指向的缓冲区;如果buf是一个字符数组名，count用它的<span class="keyword">sizeof</span>值。若buf是字符指针（字符串）则count用它的<span class="built_in">strlen</span>值</span><br><span class="line">@count:  读取字节数</span><br><span class="line">@RET:成功，返回读取的字节数，提前遇到EOF，则返回<span class="number">0</span>。出错返回<span class="number">-1</span>，并设置相应errno值；如果errno的值是EINTR，表示遇到调用信号而中断了读取，那么我们可以再次尝试read；</span><br><span class="line">从终端设备读，通常以行为单位，读到换行符就返回；</span><br><span class="line">从网络读，根据不同的传输层协议和内核缓存机制，返回值可能小于请求的字节数</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> write(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count);</span><br><span class="line"></span><br><span class="line">@fd：  文件描述符</span><br><span class="line">@buf：  写入的数据存放在buf指针指向的缓冲区</span><br><span class="line">@count：  写入的字节数</span><br><span class="line">@RET:成功，返回值为写入的字节数；否则返回值为<span class="number">-1</span>，并设置相应的errno值</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用O_NONBLOCK标志打开设备时，read&#x2F;write操作不会被阻塞。以read为例，如果设备当前没有可读数据，read函数会立即返回-1，并将errno设置为EWOULDBLOCK&#x2F;EAGAIN。表示在正常情况下应该被阻塞（would block）。调用者应该尝试再次读取（again）。这种行为方式被称为轮询（Poll），调用者只是查询一下设备状态，而不是在这里阻塞等待，这样可以同时监视多个设备。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/device&quot;</span>, O_RDONLY | O_NONBLOCK);  <span class="comment">// 打开设备文件，指定O_NONBLOCK标志</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="type">ssize_t</span> bytesRead;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">if</span>((bytesRead = read(fd, buffer, <span class="keyword">sizeof</span>(buffer))) &gt; <span class="number">0</span>) &#123;  <span class="comment">// 使用read读取设备数据;如果无数据会在这一步阻塞</span></span><br><span class="line">        <span class="comment">// 处理读取到的数据</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (bytesRead == <span class="number">-1</span>) &#123;<span class="comment">//不等待就绪，而是在一个较短的时间窗口内轮询几次</span></span><br><span class="line">        <span class="keyword">if</span> (errno == EWOULDBLOCK || errno == EAGAIN) &#123;</span><br><span class="line">            <span class="comment">// 设备暂时没有数据可读，稍后再试</span></span><br><span class="line">            perror(<span class="string">&quot;Try again NO.%d\n&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//出错</span></span><br><span class="line">            perror(<span class="string">&quot;read_error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(fd);  <span class="comment">// 关闭设备文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="fcntl-ioctl？"><a href="#fcntl-ioctl？" class="headerlink" title="fcntl&#x2F;ioctl？"></a>fcntl&#x2F;ioctl？</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/88457656" title=" linux驱动中ioctl函数的讲解 第30章IOCTL函数30-1：ioctl函数的作用：设备在运行的时候可能要求数据的写入是连续的，如果这个时候仍然用WRITE函数去写指令的话，就有可能导致数据的不连续，比如声卡放音乐卡顿，电影播放不流畅等等的情况，为… https://zhuanlan.zhihu.com/p/88457656"> linux驱动中ioctl函数的讲解 第30章IOCTL函数30-1：ioctl函数的作用：设备在运行的时候可能要求数据的写入是连续的，如果这个时候仍然用WRITE函数去写指令的话，就有可能导致数据的不连续，比如声卡放音乐卡顿，电影播放不流畅等等的情况，为… https://zhuanlan.zhihu.com/p/88457656</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">//可用fcntl函数改变已打开文件的访问属性，而不需重新打开文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, <span class="type">long</span> arg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, <span class="keyword">struct</span> flock *lock)</span>;</span><br><span class="line"></span><br><span class="line">@fd： 文件描述符</span><br><span class="line">@cmd： 控制操作命令</span><br><span class="line">F_DUPFD    复制文件描述符</span><br><span class="line">F_GETFD    获取文件描述符标签</span><br><span class="line">F_SETFD    设置文件描述符标签</span><br><span class="line">F_GETFL    获取文件描述符的状态标志</span><br><span class="line">F_SETFL    设置文件描述符的状态标志</span><br><span class="line">F_GETFLK    获取文件锁</span><br><span class="line">F_SETFLK    设置文件锁</span><br><span class="line">F_SETLKW    阻塞地设置或释放文件锁，要等待完成</span><br><span class="line">F_GETOWN    获取收到SIGIO信号的进程或进程组ID</span><br><span class="line">F_SETOWN    设置接收SIGIO信号的进程或进程组ID</span><br><span class="line">@arg： 命令的参数</span><br><span class="line">@RET:</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">    <span class="type">int</span> fd, flags，oldflags;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;file.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((oldflags= fcntl(fd, F_GETFL)) == <span class="number">-1</span>) &#123;<span class="comment">// 获取旧文件描述符标志</span></span><br><span class="line">        perror(<span class="string">&quot;fcntl - F_GETFL&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flags = oldflags | O_NONBLOCK;</span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETFL, flags) == <span class="number">-1</span>) &#123;<span class="comment">// 设置非阻塞标志</span></span><br><span class="line">        perror(<span class="string">&quot;fcntl - F_SETFL&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件描述符已设置为非阻塞模式。\n&quot;</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="comment">//可用fcntl函数改变已打开文件的属性（最终要修改设备），而不需重新打开文件</span></span><br><span class="line"><span class="type">int</span> ioctl(<span class="type">int</span> fd, <span class="type">int</span> request, ...);</span><br><span class="line"></span><br><span class="line">@request:命令参数；ioctl-》sys.ioctl-&gt;driver;设备驱动会根据这个传下来的cmd进行操作</span><br><span class="line">可变参数取决于request，通常是一个指向变量或结构体的指针。</span><br><span class="line">@RET:出错返回<span class="number">-1</span>，成功返回值取决于request;并设置全局变量 errno :</span><br><span class="line">EBADF d is not a valid descriptor. </span><br><span class="line">EFAULT argp references an inaccessible memory area. </span><br><span class="line">EINVAL Request or argp is not valid. </span><br><span class="line">ENOTTY d is not associated with a character special device. </span><br><span class="line">ENOTTY The specified request does not apply to the kind of object that the descriptor d references.</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line">ret = ioctl(fd, MYCMD);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ioctl: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//原子操作：文件描述符重定向；重定向目标文件要保证打开</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line"></span><br><span class="line">@RET:dup2成功返回新的文件描述符，出错返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">newfd = dup(<span class="number">1</span>);    <span class="comment">//返回最小可用文件描述符给newfd；并将newfd重定向到标准输出；则newfd和1都指向stdout</span></span><br><span class="line">dup2(<span class="number">1</span>,<span class="number">5</span>);         <span class="comment">//将“5”重定向到标准输出,这样操作5相当于操作1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">eg2:<span class="comment">//重定向stdout</span></span><br><span class="line">  <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>((fd = open(<span class="string">&quot;test.txt&quot;</span>,O_RDWR|O_CREAT|O_TRUNC)) == <span class="number">-1</span>) <span class="comment">//打开并清空外部文件</span></span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;open failed !&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span> oldfd = <span class="number">-1</span>;     </span><br><span class="line">  <span class="keyword">if</span>(oldfd = dup(<span class="number">1</span>) == <span class="number">-1</span>)           <span class="comment">//oldfd-&gt;stdout;保存原来指向</span></span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;fd redirect failed !&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">         </span><br><span class="line">  <span class="keyword">if</span>(dup2(fd,<span class="number">1</span>) == <span class="number">-1</span>)                    <span class="comment">//1-&gt;test.txt</span></span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;1 redirect failed !&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//重定向后进行操作</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>( dup2(oldfd,<span class="number">1</span>) == <span class="number">-1</span>)                    <span class="comment">//1-&gt;stdout;重定向恢复</span></span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;std redirect failed !&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  close(fd);</span><br><span class="line">  close(oldfd);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p><img src="/image/image_z9Z3NvZfDU.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="comment">/*把部分磁盘文件映射到内存，则文件中的位置直接就有对应的内存地址，</span></span><br><span class="line"><span class="comment">1）对文件的读写可直接用指针来做；且系统会自动回写脏页面到对应的文件磁盘上；那么就不需要read/write函数;这样能获得较高的性能</span></span><br><span class="line"><span class="comment">2）内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> prot, <span class="type">int</span> flag, <span class="type">int</span> filedes, <span class="type">off_t</span> off)</span>;</span><br><span class="line"></span><br><span class="line">@addr：指向欲映射的内存起始地址，通常设为 <span class="literal">NULL</span>，代表让系统自动选定地址，映射成功后返回该地址。</span><br><span class="line">@length：代表将文件中多大的部分映射到内存。</span><br><span class="line">@prot：映射区域保护方式。为以下宏组合：</span><br><span class="line">PROT_EXEC 映射区域可被执行</span><br><span class="line">PROT_READ 映射区域可读取</span><br><span class="line">PROT_WRITE 映射区域可写入</span><br><span class="line">PROT_NONE 映射区域不能存取</span><br><span class="line">@flags：影响映射区域的各种特性。在调用mmap()时必须要指定MAP_SHARED 或MAP_PRIVATE。</span><br><span class="line">MAP_FIXED： 如果参数start所指的地址无法成功建立映射时，则放弃映射，不对地址做修正。通常不鼓励用此旗标。</span><br><span class="line">MAP_SHARED：对映射区域写入数据会复制回文件内，而且允许其他映射该文件的进程共享。</span><br><span class="line">MAP_PRIVATE： 对映射区域的写入操作会产生一个映射文件的复制，即私人的“写入时复制”（copy on write）对此区域作的任何修改都不会写回原来的文件内容。</span><br><span class="line">MAP_ANONYMOUS：建立匿名映射。此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享。</span><br><span class="line">MAP_DENYWRITE：只允许对映射区域的写入操作，其他对文件直接写入的操作将会被拒绝。</span><br><span class="line">MAP_LOCKED： 将映射区域锁定住，这表示该区域不会被置换（swap）。</span><br><span class="line">@fd：要映射到内存中的文件描述符。如果使用匿名内存映射时，即flags中设置了MAP_ANONYMOUS，fd设为<span class="number">-1</span>。有些系统不支持匿名内存映射，则可以使用fopen打开/dev/zero文件，然后对该文件进行映射，可以同样达到匿名内存映射的效果。</span><br><span class="line">@offset：文件映射的偏移量，通常设置为<span class="number">0</span>，代表从文件最前方开始对应，offset必须是分页大小的整数倍。</span><br><span class="line">@RET：映射成功返回映射区内存起始地址，否则返回MAP_FAILED(－<span class="number">1</span>)，错误原因存于errno 中：</span><br><span class="line">EBADF 参数fd 不是有效的文件描述词</span><br><span class="line">EACCES 存取权限有误。如果是MAP_PRIVATE 情况下文件必须可读，使用MAP_SHARED则要有PROT_WRITE以及该文件要能写入。</span><br><span class="line">EINVAL 参数start、length 或offset有一个不合法。</span><br><span class="line">EAGAIN 文件被锁住，或是有太多内存被锁住。</span><br><span class="line">ENOMEM 内存不足。</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="comment">//该调用在进程地址空间中解除一个映射关系，addr是调用mmap()时返回的地址，len是映射区的大小；</span></span><br><span class="line"><span class="comment">//当映射关系解除后，对原来映射地址的访问将导致段错误发生。</span></span><br><span class="line"><span class="type">int</span> munmap(<span class="type">void</span> *addr, <span class="type">size_t</span> len);</span><br><span class="line"></span><br><span class="line">@RET:成功返回<span class="number">0</span>。失败返回<span class="number">-1</span>，error返回标志和mmap一致；</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="comment">//在调用了munmap()后或者msync()时，才把内存中的相应内容写回磁盘文件，所写内容不能超过文件大小</span></span><br><span class="line"><span class="type">int</span> msync(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> flags );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///////////////ANSI</span></span><br><span class="line"><span class="comment">///////////////posix</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">char</span>* f_name,<span class="type">int</span> mode)</span></span><br><span class="line">@f_name：文件名</span><br><span class="line">@mode：O_RDONLY,O_WRONLY,O_EDWR </span><br><span class="line">@<span class="keyword">return</span>:-1错误;成功返回文件描述符</span><br><span class="line"></span><br><span class="line">creat()</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* buf, <span class="type">size_t</span> qty)</span></span><br><span class="line">@fd：从指定文件描述符fd映射的文件读取qty字节放到buf</span><br><span class="line">@buf：</span><br><span class="line">@qty:</span><br><span class="line">@<span class="keyword">return</span>:-1错误;成功返回numread</span><br><span class="line"></span><br><span class="line"><span class="title function_">write</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">@fd</span><br><span class="line">@<span class="keyword">return</span>:-1错误，0成功</span><br><span class="line"><span class="comment">///////////////winapi</span></span><br><span class="line"><span class="comment">///who</span></span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_ls</span><span class="params">(<span class="type">char</span>[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span><span class="comment">//字符串指针数组</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc == <span class="number">1</span>)&#123;<span class="comment">//只有1个参数，为指令本身；查看当前目录</span></span><br><span class="line">        do_ls(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(--argc)&#123;<span class="comment">//查看指定的一个或多个目录</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s : \n&quot;</span>, * ++argv);<span class="comment">//打印当前所查看的目录路径</span></span><br><span class="line">            do_ls(*argv);<span class="comment">//print环节</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_ls</span><span class="params">(<span class="type">char</span> dirname[])</span></span><br><span class="line">&#123;</span><br><span class="line">    DIR *dir_ptr;<span class="comment">//文件夹指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">direntp</span>;</span><span class="comment">//存放文件夹目录内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((dir_ptr = opendir(dirname)) == <span class="literal">NULL</span>)&#123;<span class="comment">//open环节</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ls1: Cannot open %s\n&quot;</span>,dirname);<span class="comment">//打开失败</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>((direntp = readdir(dir_ptr)) != <span class="literal">NULL</span>)&#123;<span class="comment">//while（readdir）</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,direntp -&gt; d_name);<span class="comment">//d_name:当前遍历子项的文件名，限制长度为256，包括字符串终止符’\0’</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> flag;</span><br><span class="line">        <span class="keyword">if</span>(( flag = closedir(dir_ptr)) == <span class="number">-1</span>)&#123;<span class="comment">//close环节</span></span><br><span class="line">            perror(<span class="string">&quot;ls1: Cannot close dir&quot;</span>);<span class="comment">//关闭失败</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zeinsshiri.github.io/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8%EF%BC%89/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Zeins_XvJin_Shiri">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zeins's Blog">
      <meta itemprop="description" content="在何处付出，便在何处收获">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Zeins's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8%EF%BC%89/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8%EF%BC%89/" class="post-title-link" itemprop="url">进程管理（多任务调度器）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-02-07 17:18:48" itemprop="dateCreated datePublished" datetime="2024-02-07T17:18:48+08:00">2024-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-02-08 16:31:56" itemprop="dateModified" datetime="2024-02-08T16:31:56+08:00">2024-02-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BD%AF%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">软件</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>编写的代码是存储在硬盘的静态文件，编译后生成二进制可执行文件；**<br>进程（运行中的程序Process）**：运行可执行文件后，其被装载到内存，接着 CPU 执行程序中的指令；可见进程会占用cpu和内存资源</p>
<p>多任务运行的形式：<br>1）多核cpu并行运行多任务<br>2）单核cpu并发（多任务分时运行）</p>
<p><img src="/image/image_qcX7R97Hjv.png"></p>
<p><img src="/image/image_2e7v2-j-HF.png"></p>
<p>进程管理提供：多任务并发&#x2F;并行的基础<br>1）进程资源维护：运行的程序要占有系统资源；由PCB数据结构维护进程数据：主要有）进程描述信息）进程状态及调度优先级信息）资源分配清单）断点现场暂存信息）</p>
<p>2）进程控制：任务的创建，切换，终止机制包括cpu调度、分配资源、进程间通信，及维护进程相关数据结构等操作。<br>2.2）进程调度：设计调度算法,合理分配cpu资源，提高cpu利用率，系统的吞吐量和响应时间;创建状态队列跟踪和管理进程状态；<br>2.3）进程通信与同步</p>
<p>3）多线程：设计调度算法,合理分配cpu资源，提高cpu利用率</p>
<h1 id="进程资源维护"><a href="#进程资源维护" class="headerlink" title="进程资源维护"></a>进程资源维护</h1><h2 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h2><p>1）<strong>进程描述信息：</strong><br>进程标识符PID<br>用户标识符UID：进程归属用户，主要为共享和保护服务；<br><strong>2）</strong>进程状态及调度优先级信息<strong>：</strong><br>进程当前状态，如 new、ready、running、waiting 或 blocked 等；<br>进程优先级：进程抢占 CPU 时的优先级；<br><strong>3）资源分配清单：</strong><br>有关内存地址空间或虚拟地址空间的信息，打开文件列表和所使用的 I&#x2F;O 设备信息（文件描述符表）<br><strong>4）</strong>断点现场暂存信息<strong>：</strong><br>CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">long</span> state; <span class="comment">//说明了该进程是否可以执行，还是可中断等信息</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> flags; <span class="comment">// flags 是进程号，在调用fork()时给出</span></span><br><span class="line">  <span class="type">int</span> sigpending; <span class="comment">// 进程上是否有待处理的信号</span></span><br><span class="line"> </span><br><span class="line">   <span class="type">mm_segment_t</span> addr_limit;  <span class="comment">//进程地址空间,区分内核进程与普通进程在内存存放的位置不同  //0-0xBFFFFFFF for user-thead    //0-0xFFFFFFFF for kernel-thread</span></span><br><span class="line">   <span class="comment">//调度标志,表示该进程是否需要重新调度,若非0,则当从内核态返回到用户态,会发生调度</span></span><br><span class="line">   <span class="keyword">volatile</span> <span class="type">long</span> need_resched;</span><br><span class="line">   <span class="type">int</span> lock_depth;    <span class="comment">//锁深度</span></span><br><span class="line">   <span class="type">long</span> nice;       <span class="comment">//进程的基本时间片</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//进程的调度策略,有三种,实时进程:SCHED_FIFO,SCHED_RR, 分时进程:SCHED_OTHER</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> policy;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>    <span class="comment">//进程内存管理信息</span></span><br><span class="line"> </span><br><span class="line">   <span class="type">int</span> processor;</span><br><span class="line">   <span class="comment">//若进程不在任何CPU上运行, cpus_runnable 的值是0，否则是1 这个值在运行队列被锁时更新</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> cpus_runnable, cpus_allowed;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">run_list</span>;</span>   <span class="comment">//指向运行队列的指针</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> sleep_time;   <span class="comment">//进程的睡眠时间</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//用于将系统中所有的进程连成一个双向循环链表, 其根是init_task</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">next_task</span>, *<span class="title">prev_task</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">active_mm</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">local_pages</span>;</span>      <span class="comment">//指向本地页面      </span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> allocation_order, nr_local_pages;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> *<span class="title">binfmt</span>;</span>      <span class="comment">//进程所运行的可执行文件的格式</span></span><br><span class="line">   <span class="type">int</span> exit_code, exit_signal;</span><br><span class="line">   <span class="type">int</span> pdeath_signal;           <span class="comment">//父进程终止时向子进程发送的信号</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> personality;</span><br><span class="line">   <span class="comment">//Linux可以运行由其他UNIX操作系统生成的符合iBCS2标准的程序</span></span><br><span class="line">   <span class="type">int</span> did_exec:<span class="number">1</span>; </span><br><span class="line">   <span class="type">pid_t</span> pid;          <span class="comment">//进程标识符,用来代表一个进程</span></span><br><span class="line">   <span class="type">pid_t</span> pgrp;        <span class="comment">//进程组标识,表示进程所属的进程组</span></span><br><span class="line">   <span class="type">pid_t</span> tty_old_pgrp;      <span class="comment">//进程控制终端所在的组标识</span></span><br><span class="line">   <span class="type">pid_t</span> session;             <span class="comment">//进程的会话标识</span></span><br><span class="line">   <span class="type">pid_t</span> tgid;</span><br><span class="line">   <span class="type">int</span> leader;    <span class="comment">//表示进程是否为会话主管</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_opptr</span>,*<span class="title">p_pptr</span>,*<span class="title">p_cptr</span>,*<span class="title">p_ysptr</span>,*<span class="title">p_osptr</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">thread_group</span>;</span>          <span class="comment">//线程链表</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">pidhash_next</span>;</span>    <span class="comment">//用于将进程链入HASH表</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> **<span class="title">pidhash_pprev</span>;</span></span><br><span class="line">   <span class="type">wait_queue_head_t</span> wait_chldexit;      <span class="comment">//供wait4()使用</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">vfork_done</span>;</span>         <span class="comment">//供vfork() 使用</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> rt_priority;       <span class="comment">//实时优先级，用它计算实时进程调度时的weight值</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">   <span class="comment">//it_real_value，it_real_incr用于REAL定时器，单位为jiffies, 系统根据it_real_value</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//设置定时器的第一个终止时间. 在定时器到期时，向进程发送SIGALRM信号，同时根据</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//it_real_incr重置终止时间，it_prof_value，it_prof_incr用于Profile定时器，单位为jiffies。</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//当进程运行时，不管在何种状态下，每个tick都使it_prof_value值减一，当减到0时，向进程发送</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//信号SIGPROF，并根据it_prof_incr重置时间.</span></span><br><span class="line">   <span class="comment">//it_virt_value，it_virt_value用于Virtual定时器，单位为jiffies。当进程运行时，不管在何种</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//状态下，每个tick都使it_virt_value值减一当减到0时，向进程发送信号SIGVTALRM，根据</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//it_virt_incr重置初值。</span></span><br><span class="line"> </span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> it_real_value, it_prof_value, it_virt_value;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> it_real_incr, it_prof_incr, it_virt_value;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">real_timer</span>;</span>        <span class="comment">//指向实时定时器的指针</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">tms</span> <span class="title">times</span>;</span>                      <span class="comment">//记录进程消耗的时间</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> start_time;          <span class="comment">//进程创建的时间</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//记录进程在每个CPU上所消耗的用户态时间和核心态时间</span></span><br><span class="line">   <span class="type">long</span> per_cpu_utime[NR_CPUS], per_cpu_stime[NR_CPUS]; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">   <span class="comment">//内存缺页和交换信息:</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//min_flt, maj_flt累计进程的次缺页数（Copy on　Write页和匿名页）和主缺页数（从映射文件或交换</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//设备读入的页面数）； nswap记录进程累计换出的页面数，即写到交换设备上的页面数。</span></span><br><span class="line">   <span class="comment">//cmin_flt, cmaj_flt, cnswap记录本进程为祖先的所有子孙进程的累计次缺页数，主缺页数和换出页面数。</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//在父进程回收终止的子进程时，父进程会将子进程的这些信息累计到自己结构的这些域中</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> min_flt, maj_flt, nswap, cmin_flt, cmaj_flt, cnswap;</span><br><span class="line">   <span class="type">int</span> swappable:<span class="number">1</span>; <span class="comment">//表示进程的虚拟地址空间是否允许换出</span></span><br><span class="line">   <span class="comment">//进程认证信息</span></span><br><span class="line">   <span class="comment">//uid,gid为运行该进程的用户的用户标识符和组标识符，通常是进程创建者的uid，gid</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//euid，egid为有效uid,gid</span></span><br><span class="line">   <span class="comment">//fsuid，fsgid为文件系统uid,gid，这两个ID号通常与有效uid,gid相等，在检查对于文件</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//系统的访问权限时使用他们。</span></span><br><span class="line">   <span class="comment">//suid，sgid为备份uid,gid</span></span><br><span class="line">   <span class="type">uid_t</span> uid,euid,suid,fsuid;</span><br><span class="line">   <span class="type">gid_t</span> gid,egid,sgid,fsgid;</span><br><span class="line">   <span class="type">int</span> ngroups;                  <span class="comment">//记录进程在多少个用户组中</span></span><br><span class="line">   <span class="type">gid_t</span> groups[NGROUPS];      <span class="comment">//记录进程所在的组</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//进程的权能，分别是有效位集合，继承位集合，允许位集合</span></span><br><span class="line">   <span class="type">kernel_cap_t</span> cap_effective, cap_inheritable, cap_permitted;</span><br><span class="line"> </span><br><span class="line">   <span class="type">int</span> keep_capabilities:<span class="number">1</span>;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim</span>[<span class="title">RLIM_NLIMITS</span>];</span>    <span class="comment">//与进程相关的资源限制信息</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">short</span> used_math;         <span class="comment">//是否使用FPU</span></span><br><span class="line">   <span class="type">char</span> comm[<span class="number">16</span>];                      <span class="comment">//进程正在运行的可执行文件名</span></span><br><span class="line">   <span class="type">int</span> link_count, total_link_ count;  <span class="comment">//文件系统信息</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//NULL if no tty 进程所在的控制终端，如果不需要控制终端，则该指针为空</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> locks;</span><br><span class="line">   <span class="comment">//进程间通信信息</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> *<span class="title">semundo</span>;</span>       <span class="comment">//进程在信号灯上的所有undo操作</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> *<span class="title">semsleeping</span>;</span>   <span class="comment">//当进程因为信号灯操作而挂起时，他在该队列中记录等待的操作</span></span><br><span class="line">   <span class="comment">//进程的CPU状态，切换时，要保存到停止进程的task_struct中</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> <span class="title">thread</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span>           <span class="comment">//文件系统信息</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span>    <span class="comment">//打开文件信息</span></span><br><span class="line">   <span class="type">spinlock_t</span> sigmask_lock;   <span class="comment">//信号处理函数</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">sig</span>;</span>   <span class="comment">//信号处理函数</span></span><br><span class="line">   <span class="type">sigset_t</span> blocked;                <span class="comment">//进程当前要阻塞的信号，每个信号对应一位</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> <span class="title">pending</span>;</span>      <span class="comment">//进程上是否有待处理的信号</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> sas_ss_sp;</span><br><span class="line">   <span class="type">size_t</span> sas_ss_size;</span><br><span class="line">   <span class="type">int</span> (*notifier)(<span class="type">void</span> *priv);</span><br><span class="line">   <span class="type">void</span> *notifier_data;</span><br><span class="line">   <span class="type">sigset_t</span> *notifier_mask;</span><br><span class="line">   u32 parent_exec_id;</span><br><span class="line">   u32 self_exec_id;</span><br><span class="line"> </span><br><span class="line">   <span class="type">spinlock_t</span> alloc_lock;</span><br><span class="line">   <span class="type">void</span> *journal_info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="状态队列"><a href="#状态队列" class="headerlink" title="状态队列"></a>状态队列</h2><p>多任务调度会使进程占有的系统资源状态发生变化：</p>
<table>
<thead>
<tr>
<th>状态3&#x2F;5&#x2F;7</th>
<th>cpu</th>
<th>虚拟内存</th>
<th>外存中是否由虚拟内存静态映像</th>
<th>使用到的设备</th>
</tr>
</thead>
<tbody><tr>
<td>运行态（<em>Running</em>）</td>
<td>1</td>
<td>1</td>
<td></td>
<td>占有</td>
</tr>
<tr>
<td>阻塞态（<em>Blocked</em>）</td>
<td>0</td>
<td>1</td>
<td></td>
<td>等待设备空闲才进入阻塞</td>
</tr>
<tr>
<td>就绪态（<em>Ready</em>）：随时可上cpu</td>
<td>0</td>
<td>1</td>
<td></td>
<td>设备空闲；内存已载入.text;相关数据结果创建完毕</td>
</tr>
<tr>
<td>创建态（<em>new</em>）</td>
<td>0</td>
<td>1&#x2F;0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>结束态（<em>Exit</em>）</td>
<td>1</td>
<td>1&#x2F;0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>阻塞挂起态：挂起前阻塞</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>就绪挂起态：挂起前就绪；进入内存可即刻运行</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td></td>
</tr>
</tbody></table>
<p>状态变迁：<br><em>NULL -&gt; 创建态</em>：<br><em>创建态 -&gt; 就绪态</em>：PCB创建完成并初始化后，一切就绪准备运行时，进入就绪队列<br><em>就绪态 -&gt; 运行态</em>：被os进程调度器选中，分配给 CPU 运行该进程；<br><em>运行态 -&gt; 结束态</em>：进程运行完&#x2F;出错&#x2F;exit系统调用;<br><em>运行态 -&gt; 就绪态</em>：分配的时间片用完，进入就绪队列，并从就绪队列选中另外一个进程运行；<br><em>运行态 -&gt; 阻塞态</em>：当某些资源正被其他进程占用，导致相关指令无法继续执行，进入阻塞队列等待；<br><em>阻塞态 -&gt; 就绪态</em>：等待事件完成时（请求的系统资源空闲时），从阻塞态变到就绪态；</p>
<p><em>阻塞态 -&gt; 挂起态</em>：大量阻塞态进程占用内存，导致浪费或sleep定时器系统调用&#x2F;ctrl+Z&#x20;<br><em>就绪态 -&gt; 挂起态</em>：大量<em>就绪态</em>进程占用内存<br>挂起态 <em>-&gt; 就绪态</em>：</p>
<p>进程状态被登记在PCB;且有7个状态队列跟踪并维护进程状态；<br>一般都为链表实现的队列：方便插入，删除<br>阻塞&#x2F;就绪队头指针→PCB1→PCB2→……<br>运行态PCB只需要一个指针管理</p>
<p><img src="/image/image_6-DOGlyRJC.png"></p>
<p><img src="/image/image_8cYzsyN6WX.png"></p>
<h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h1><p>任务的创建，切换，终止基于cpu调度、分配资源、进程间通信，原子操作等机制，以及需要维护进程相关数据结构。</p>
<p><a href="cpu%E8%B0%83%E5%BA%A6/cpu%E8%B0%83%E5%BA%A6.md" title="cpu调度">cpu调度</a></p>
<p><a href="%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1.md" title="进程通信">进程通信</a></p>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a><strong>创建</strong></h2><p>操作系统允许一个进程创建另一个进程，而且允许子进程继承父进程所拥有的资源。<br>1）创建PCB<br>2）为该进程分配运行时所必需资源<br>3）将 PCB 插入就绪队列</p>
<h2 id="终止"><a href="#终止" class="headerlink" title="终止"></a><strong>终止</strong></h2><p>进程的 3 种终止方式：正常结束、异常结束以及外界干预（信号 <code>kill</code> 掉）；<br>当子进程被终止时，其在父进程处继承的资源应当还给父进程。当父进程被终止时，该父进程的子进程就变为孤儿进程，会被 1 号进程收养，并由 1 号进程对它们完成状态收集工作。<br>1）查找进程 PCB,获得状态等信息；<br>2）若处于运行态，则立即终止，将 CPU 资源分配给其他进程；<br>3）若有子进程，则将子进程交给 1 号进程接管；<br>4）将系统资源都归还<br>5）将其从 PCB 所在队列中删除；</p>
<p>僵尸进程：进程终止时会关闭所有文件描述符，释放用户空间内存，但仍保留其PCB。内核保存了终止态和终止信号信息。父进程可调用wait&#x2F;waitpid获取这些信息，然后彻底清除掉这个进程。若父进程未对已终止的子进程进行清理，称为僵尸进程。正常情况下，僵尸进程会立刻被父进程清理；</p>
<p>进程退出状态可在Shell中用特殊变量<code>$?</code>查看，因为Shell是它的父进程，当它终止时Shell调用<code>wait</code>或<code>waitpid</code>得到它的退出状态同时彻底清除掉这个进程</p>
<h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a><strong>阻塞</strong></h2><p>当进程需要等待某一事件完成时，它可以调用阻塞语句把自己阻塞等待。而一旦被阻塞等待，它只能由另一个进程唤醒。<br>1）找到要阻塞进程UID对应的 PCB；<br>2）若为运行态，将现场信息暂存进PCB;然后将 CPU 资源分配给其他进程<br>3）将PCB 插入阻塞队列；</p>
<h2 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a><strong>唤醒</strong></h2><p>若某进程正在等待 I&#x2F;O 事件，需由别的进程发消息给它，则只有当该进程所期待的事件出现时，才由发现者进程用唤醒语句叫醒它。<br>1）在该事件的阻塞队列中找到相应进程的 PCB；<br>2）将其从阻塞队列中移出到就绪队列</p>
<h2 id="进程控制posix"><a href="#进程控制posix" class="headerlink" title="进程控制posix"></a>进程控制posix</h2><h3 id="fork-vfork"><a href="#fork-vfork" class="headerlink" title="fork&#x2F;vfork"></a>fork&#x2F;vfork</h3><p><img src="/image/image_rQkCd8oIqE.png"></p>
<p><img src="/image/image_MijhoSMrGy.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//创建一个子进程(除了少量数据，比如pid不一样，其他与原来进程一样)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">父进程调用fork创建一个子进程。子进程除了少量数据（eg:pid），可说是父进程的副本。</span></span><br><span class="line"><span class="comment">1）接来若父进程被调度执行：则父进程从fork函数返回并获取子进程的ID作为返回值；pid&gt;0</span></span><br><span class="line"><span class="comment">2)若子进程被调度执行，则子进程从fork函数返回并得到0作为返回值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">@RET:cpu调度父进程，fork返回子进程pid&gt;<span class="number">0</span>;cpu调度子进程，fork返回<span class="number">0</span>；发生错误返回负值，并设置errno:</span><br><span class="line"><span class="number">1</span>）当前进程数已达系统规定上限，这时errno的值被设置为EAGAIN。</span><br><span class="line"><span class="number">2</span>）系统内存不足，这时errno的值被设置为ENOMEM</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line">    <span class="type">pid_t</span> pid;         <span class="comment">//fork函数返回值</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)&#123;       <span class="comment">//fork失败</span></span><br><span class="line">        perror(<span class="string">&quot;fork failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;      </span><br><span class="line">        <span class="comment">//子进程执行逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//父进程执行逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">eg:循环创建<span class="number">2</span>^n个进程，最初只有一个进程，每经历一次循环进程数*<span class="number">2</span>；n次循环会产生<span class="number">2</span>^n个进程</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调度子进程时执行的逻辑</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">//调度父进程时执行的逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ----------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> vfork(<span class="type">void</span>);</span><br><span class="line"><span class="comment">/*vfork()不会创建并复制父进程的地址空间，而是和父进程共享</span></span><br><span class="line"><span class="comment">vfork()会阻塞父进程，只运行子进程运行</span></span><br><span class="line"><span class="comment">当子进程调用exec()或_exit()时，内核返回地址空间给父进程并唤醒它*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="exec"><a href="#exec" class="headerlink" title="exec~"></a>exec~</h3><p><img src="/image/image_AGgsufEUgw.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//系统调用execve（）替换当前进程的代码段，替换者为一个指定的程序，其参数包括路径、参数列表（argv）以及环境变量（envp）；只有execve是内核中的系统调用，其他5个都是调用execve的库函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接口差异体现在exec的后缀上;l表示命令行参数列表、p表示PATH环境变量、v表示使用参数数组、e使用环境变量数组</span></span><br><span class="line">(a）待执行程序：由文件名(filename）/由路径名（pathname）指定;</span><br><span class="line">(b）参数列表：一一列出/用一个指针数组引用;</span><br><span class="line">(c）把调用进程的环境传递给新程序/还是给新程序指定新的环境</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> execl(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/* (char  *) NULL */</span>);</span><br><span class="line"><span class="type">int</span> execlp(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/* (char  *) NULL */</span>);</span><br><span class="line"><span class="type">int</span> execle(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...</span><br><span class="line">               <span class="comment">/*, (char *) NULL, char * const envp[] */</span>);</span><br><span class="line"><span class="type">int</span> execv(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[]);</span><br><span class="line"><span class="type">int</span> execvp(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[]);</span><br><span class="line"><span class="type">int</span> execvpe(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[],<span class="type">char</span> *<span class="type">const</span> envp[]);</span><br><span class="line"></span><br><span class="line">@RET:execl成功调用后进程代码段被替换，自然接下来的代码就不会再执行，且无返回值；调用失败后返回<span class="number">-1</span>并设置errno值：</span><br><span class="line"><span class="number">1.</span> 找不到文件或者路径，此时errno为ENOENT。</span><br><span class="line"><span class="number">2.</span> 数组argv和envp(环境变量数组)没有以<span class="literal">NULL</span>结尾，此时errno为EFAULT。</span><br><span class="line"><span class="number">3.</span> 没有对应可执行文件的运行权限，此时errno为EACCES。</span><br><span class="line"><span class="comment">//由于只有错误返回值，只要返回了一定是出错了，直接在后面调用perror即可</span></span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">    execl(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">char</span> *argv[] = &#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    execv(<span class="string">&quot;/bin/ls&quot;</span>, argv);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用exec后，原来打开的文件描述符仍然是打开的[37]。利用这一点可以实现I/O重定向    </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="wait-waitpid-exit"><a href="#wait-waitpid-exit" class="headerlink" title="wait&#x2F;waitpid&#x2F;exit"></a>wait&#x2F;waitpid&#x2F;exit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*写一个僵尸进程：若父进程终止，子进程还存在（仍在运行或已是僵尸进程），则这些子进程的父进程改为init进程。init是系统中的一个特殊进程，通常程序文件是/sbin/init，进程id是1；</span></span><br><span class="line"><span class="comment">在系统启动时负责启动各种系统服务，之后就负责清理子进程，只要有子进程终止，init就会调用wait函数清理它*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pid_t</span> pid=fork();</span><br><span class="line">  <span class="keyword">if</span>(pid&lt;<span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(pid&gt;<span class="number">0</span>) &#123; <span class="comment">/* parent */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* child */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ps命令显示僵尸进程的状态为Z，在命令行一栏还显示&lt;defunct&gt;</span></span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="comment">//获取进程终止信息，并彻底彻底清除此进程</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>;</span><br><span class="line"></span><br><span class="line">@status:传出子进程的终止信息；不关心可设为null</span><br><span class="line">@options:options参数指定WNOHANG可使父进程不阻塞而立即返回<span class="number">0</span></span><br><span class="line">@pid:wait等待第一个终止的子进程，而waitpid可以通过pid参数指定等待哪一个子进程</span><br><span class="line">@ret:</span><br><span class="line"><span class="number">1</span>)（子进程已终止，正等待父进程读取其终止信息）:子进程终止信息写入status并立即返回,且返回清理掉的子进程id。</span><br><span class="line"><span class="number">2</span>)（子进程都还在运行）                    :父进程阻塞等待子进程终止;起到进程间同步的作用</span><br><span class="line"><span class="number">3</span>)（eg:没有任何子进程）                   :出错立即返回<span class="number">-1</span>并设置errno:</span><br><span class="line">ECHILD  没有子进程</span><br><span class="line">EINTER  收到中断信号signal，立即返回</span><br><span class="line"></span><br><span class="line">终止信息宏：        缩写              描述</span><br><span class="line">WIFEXITED  wait <span class="keyword">if</span> exited  子进程正常退出时返回真值</span><br><span class="line">WEXITSTATUS  wait <span class="built_in">exit</span> status  当上面宏为真时，返回子进程正常退出时状态</span><br><span class="line">WIFSIGNALED  wait <span class="keyword">if</span> signaled  子进程由于信号导致终止，返回真值</span><br><span class="line">WTERMSIG  wait <span class="built_in">terminate</span> signal  当上面宏为真时，返回终止子进程的信号类型</span><br><span class="line">WIFSTOPPED  wait <span class="keyword">if</span> stopped</span><br><span class="line">WSTOPSIG  wait stop signal</span><br><span class="line">WIFCONTINUED  wait <span class="keyword">if</span> continued</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="线程机制"><a href="#线程机制" class="headerlink" title="线程机制"></a>线程机制</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">export <span class="type">void</span> <span class="title function_">thread1</span><span class="params">()</span>&#123;<span class="comment">//线程1的函数</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      print(<span class="string">&quot;I&#x27;m thread 1&quot;</span>);</span><br><span class="line">      sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="type">void</span> <span class="title function_">thread2</span><span class="params">()</span>&#123;<span class="comment">//线程2的函数</span></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      print(<span class="string">&quot;I&#x27;m thread 2&quot;</span>);</span><br><span class="line">      sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主线程</span></span><br><span class="line">export <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  CreateThread(<span class="string">&quot;thread1&quot;</span>);<span class="comment">//开始线程1</span></span><br><span class="line">  CreateThread(<span class="string">&quot;thread2&quot;</span>);<span class="comment">//开始线程2</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) sleep(<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picx.zhimg.com/50/v2-c66e1ed28e6a703f1e85fb486beec4c9_720w.webp?source=1def8aca"></p>
<p><img src="/image/image_auTBkz7OIf.png"></p>
<p><img src="/image/image__qlpsuNRec.png"></p>
<p>多线程并发的过程：在并发的过程间来回切换执行；因为计算机执行速度很快,所以最终看起来,这些并发过程就像同时运行一样；这个机制（线程调度器）实现需要：<br>1）执行流（并发的过程）间来回跳转执行时，cpu的调度机制：时间片轮询，且只需现场保护私有的栈段及寄存器资源</p>
<p>2）并发过程的实例（线程）共享进程资源（其实就是共享上下文降低cpu调度切换上下文的开销）；但并发过程产生的中间数据不一样，需独立栈段及寄存器资源</p>
<p>3）需要某种数据结构维护用户注册的线程信息<strong>TCB</strong>：线程描述信息；断点线程暂存信息；时间片大小（每个来回切换执行多少指令）</p>
<p>4）线程阻塞调度机制：用户线程并发时任一线程调用阻塞syscall，则内核会认为是进程调用的从而让进程进入阻塞态；解决方案：<br>1.<em><strong>jacketing</strong></em>避免进程出现阻塞态：线程调用阻塞syscall时<em>检查 I&#x2F;O 设备是否忙，若忙不执行 I&#x2F;O 操作，转而调度其他线程，避免因等待 I&#x2F;O 设备造成进程阻塞</em><br>2.让调度器拥有调度线程的能力：则TCB要在内核空间中维护(为减少cpu变态频率线程私有数据也在内核空间维护)，线程控制操作也变成syscall；所以内核级线程有cpu变态开销</p>
<p>实现上述机制的线程模型：<br>1）运行于用户态的线程管理库实现；其优势是：无需用户态与内核态的切换，所以速度特别快；缺点：若一个线程阻塞，内核机制会让整个进程阻塞；时间片是在进程时间片的基础上再分的，故时间片较小；因完全运行在用户态，一个线程占据 CPU 使用权时，所在进程的其他线程无法打断当前运行线程；不支持线程并行；</p>
<p>2）运行于内核态的内核函数实现：TCB存储于内核空间，优点：线程阻塞不会令其余线程也阻塞；更大的时间片；支撑线程并行；缺点：并发操作由系统调用实现，cpu变态开销大</p>
<p>3）<strong>轻量级进程（</strong><em><strong>LightWeight Process</strong></em><strong>）</strong>：<strong>LWP存储</strong>执行流跳转时的现场信息，及调度所需信息；能共享进程虚拟地址空间；被一个内核线程管理；实现了在进程内进行用户态线程调度；线程阻塞及进程外线程调度和线程并行由内核线程调度器完成</p>
<p>原子操作，通信，锁</p>
<p><img src="/image/image_QTyH_maHC7.png"></p>
<h2 id="线程同步互斥"><a href="#线程同步互斥" class="headerlink" title="线程同步互斥"></a>线程同步互斥</h2><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><h1 id="并行-并发编程"><a href="#并行-并发编程" class="headerlink" title="并行&#x2F;并发编程"></a>并行&#x2F;并发编程</h1><p><a href="%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%82%E6%AD%A5/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%82%E6%AD%A5.md" title="多线程异步">多线程异步</a></p>

      
    </div>

    
    
    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/11/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/13/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2024-02 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Zeins_XvJin_Shiri</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">330k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:01</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">
    <!--由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动 -->
  </div>

<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("03/01/2023 10:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>
    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/zeinsshiri/" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"mhchem":false,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script src="/js/third-party/comments/livere.js"></script>

  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  

  
  
    <script src="/js/cursor/fireworks.js"></script>
  

  
  
<style>
#selectionCopyright {
    position: absolute;
    display: none;
    background: rgba(244,67,54,.7);
    color: #fff;
    border-radius: 6px;
    box-shadow: none;
    border: none;
    font-size: 14px;
}
#selectionCopyright a{
    color:#fff;
    border-color: #fff;
}
#selectionCopyright::before {
    content: "";
    width: 0;
    height: 0;
    border-style: solid;
    border-width: 6px 8px 6px 0;
    border-color: transparent rgba(244,67,54,.7) transparent transparent;
    position: absolute;
    left: -8px;
    top:50%;
    transform:translateY(-50%);
}
</style>

<button id="selectionCopyright" disabled="disabled">本文由Zeins原创并遵循CC4.0，转载请注明出处并链接回原文地址哟</button>

<script>
window.onload = function() {
    function selectText() {
        if (document.selection) { //IE浏览器下
            return document.selection.createRange().text; //返回选中的文字
        } else { //非IE浏览器下
            return window.getSelection().toString(); //返回选中的文字
        }
    }
    var content = document.getElementsByTagName("body")[0];
    var scTip = document.getElementById('selectionCopyright');

    content.onmouseup = function(ev) { //设定一个onmouseup事件
        var ev = ev || window.event;
        var left = ev.clientX;//获取鼠标相对浏览器可视区域左上角水平距离距离
        var top = ev.clientY;//获取鼠标相对浏览器可视区域左上角垂直距离距离
        var xScroll = Math.max(document.body.scrollLeft, document.documentElement.scrollLeft);//获取文档水平滚动距离
        var yScroll = Math.max(document.body.scrollTop, document.documentElement.scrollTop);//获取文档垂直滚动距离
        if (selectText().length > 0) {
            setTimeout(function() { //设定一个定时器
                scTip.style.display = 'inline-block';
                scTip.style.left = left + xScroll + 15 + 'px';//鼠标当前x值
                scTip.style.top = top + yScroll - 15 + 'px';//鼠标当前y值
            }, 100);
        } else {
            scTip.style.display = 'none';
        }
    };

    content.onclick = function(ev) {
        var ev = ev || window.event;
        ev.cancelBubble = true;
    };
    document.onclick = function() {
        scTip.style.display = 'none';
    };
};
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":290},"mobile":{"show":false},"react":{"opacityDefault":1,"opacityOnHover":1},"log":false,"tagMode":false});</script></body>
</html>


