<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%A6/%E5%B7%AE%E5%88%86%E6%96%B9%E7%A8%8B/</url>
    <content><![CDATA[<hr>
<h2 id="title-差分方程abbrlink-0date-2024-02-08-16-00-06categories-mathtags-math"><a href="#title-差分方程abbrlink-0date-2024-02-08-16-00-06categories-mathtags-math" class="headerlink" title="title: 差分方程abbrlink: 0date: 2024-02-08 16:00:06categories: mathtags: math"></a>title: 差分方程<br>abbrlink: 0<br>date: 2024-02-08 16:00:06<br>categories: math<br>tags: math</h2><p>$\begin{cases} F(t,y_{t},\Delta y_{t},…,\Delta^{n}y_{t})&#x3D;0 …①\ F(t,y_{t},y_{t+1},…,y_{t+n})&#x3D;0 …②\ \end{cases}$;阶数 为最大下标与最小下标之差</p>
<p><a href="https://zhuanlan.zhihu.com/p/385787482" title=" 差分方程基本理论 此文主要介绍差分方程的基本知识，并在之后的文章中借用到差分方程的理论。 一、差分方程中的基本概念 二、常见差分方程的解结构及常规类型的差分方程通解 一、差分方程中的基本概念(可以类比之我们熟悉的微分方程… https://zhuanlan.zhihu.com/p/385787482"> 差分方程基本理论 此文主要介绍差分方程的基本知识，并在之后的文章中借用到差分方程的理论。 一、差分方程中的基本概念 二、常见差分方程的解结构及常规类型的差分方程通解 一、差分方程中的基本概念(可以类比之我们熟悉的微分方程… https://zhuanlan.zhihu.com/p/385787482</a></p>
<p>$在\Delta x取极限时,微分dy等于线性主部f’(x_0)dx&#x3D;\frac{dy(x_0)}{dx}dx；当\Delta x&#x3D;1时，则差分\Delta y[x]&#x3D;y[x+1]-y[x]$；<br>二阶差分$\Delta^2 y[x]&#x3D;\Delta (\Delta y[x])&#x3D;\Delta(y[x+1]-y[x])&#x3D;y[x+2]-2y[x+1]+y[x]$<br>三阶差分$\Delta^3 y[x]&#x3D;\Delta(\Delta^2 y[x])$</p>
<p>差分算子性质：<br>1）线性：$\Delta(au_{t}+bv_{t})&#x3D;a\Delta u_{t}+b\Delta v_{t}$<br>2)$乘法性质：\Delta(u_{t}·v_{t})&#x3D;u_{t+1}·v_{t+1}-u_{t}·v_{t}<br>&#x3D;v_{t}·\Delta u_{t}+\color{red}{u_{t+1}}·\Delta v_{t}&#x3D;u_{t}·\Delta v_{t}+\color{red}{v_{t+1}}·\Delta u_{t}$<br>3)除法性质：$\Delta(\frac{u_{t}}{v_{t}})&#x3D;\frac{u_{t+1}}{v_{t+1}}-\frac{u_{t}}{v_{t}}&#x3D;\frac{v_{t}\Delta u_{t}-u_{t}\Delta v_{t}}{v_{t+1}v_{t}}$</p>
<h1 id="1-一阶常系数线性差分方程"><a href="#1-一阶常系数线性差分方程" class="headerlink" title="1 一阶常系数线性差分方程"></a>1 一阶常系数线性差分方程</h1><p>$y[x+1] - ay[x] &#x3D; f(x)$</p>
<h2 id="1-1-齐次-f-x-0"><a href="#1-1-齐次-f-x-0" class="headerlink" title="1.1 齐次$f(x)&#x3D;0$"></a>1.1 齐次$f(x)&#x3D;0$</h2><p>设$y[x]&#x3D;Ca^{ x}$;代入原方程；$Ca^{x+1}-Ca^{ x+1}&#x3D;0$；其通解为秩&#x3D;1的线性无关组</p>
<h2 id="1-2-非齐次-f-x-≠0"><a href="#1-2-非齐次-f-x-≠0" class="headerlink" title="1.2 非齐次$f(x)≠0$"></a>1.2 非齐次$f(x)≠0$</h2><p>设特解$y_1[x],y_2[x]$；则$y_1[x+1] - ay_1[x] -(y_2[x+1]-ay_2[x])&#x3D; f(x) - f(x)$⇒$y_1[x+1]-y_2[x+1]-a(y_1[x]-y_2[x])&#x3D;0$⇒$y_1[x]-y_2[x]&#x3D;Ca^x$</p>
<p>则通解$y[x]&#x3D;y^*[x]+Ca^x$<br>特解由f(x)的形式决定（注意维持线性无关性）：<br>$当f(x)&#x3D;C·p^{t}时设特解y^{<em>}&#x3D;\begin{cases} k·p^{t}(p\ne a)\ kt·p^{t}(p&#x3D;a)\ \end{cases}$$当f(x)&#x3D;p_{0}+p_{1}t+…+p_{m}t^{m}时,$$设特解为y^{</em>}&#x3D;\begin{cases} P_{0}+P_{1}t+…+P_{m}t^{m}(a\ne 1)\ t·(P_{0}+P_{1}t+…+P_{m}t^{m})(a&#x3D;1)\ \end{cases}$$当f(t)&#x3D;m^{t}(p_{1}cos\beta t+p_{2}sin\beta t)时,$$设特解为y^{*}&#x3D;\begin{cases}m^{t}(C_{1}cos\beta t+C_{2}sin\beta t) \quad m(cos\beta+sin\beta i)不是特征根时\  tm^{t}(C_{1}cos\beta t+C_{2}sin\beta t) \quad m(cos\beta+sin\beta i)是特征方程的根时\  \end{cases}$</p>
<h1 id="2-二阶常系数线性差分方程"><a href="#2-二阶常系数线性差分方程" class="headerlink" title="2 二阶常系数线性差分方程"></a>2 二阶常系数线性差分方程</h1><p>$y[x+2]+ay[x+1]+by[x]&#x3D;f(x)$</p>
<h2 id="2-1-齐次-f-x-0"><a href="#2-1-齐次-f-x-0" class="headerlink" title="2.1 齐次$f(x)&#x3D;0$"></a>2.1 齐次$f(x)&#x3D;0$</h2><p>设$特解y^*[x]&#x3D;\lambda^x$,带入原式：$\lambda^2+a\lambda+b&#x3D;0$;<br>$其通解为秩2的线性无关组合；通解为\begin{cases} y&#x3D;C_{1}\lambda^{t}<em>{1}+C</em>{2}\lambda^{t}<em>{2},\lambda</em>{1}与\lambda_{2}是两个不相等的实根\ y&#x3D;(C_{1}+C_{2}t)\lambda_{1}^{t},\lambda_{1}与\lambda_{2}是两个相等的实根\ y&#x3D;(C_{1}cos\theta t+C_{2}sin\theta t)r^{t},\lambda_{1,2}&#x3D;\alpha\pm\beta i\ 其中tan\theta&#x3D;\frac{\beta}{\alpha}(0&lt;\theta&lt;\pi),r&#x3D;\sqrt{\alpha^{2}+\beta^{2}} \end{cases}$</p>
<h2 id="2-2-非齐次-f-x-≠0"><a href="#2-2-非齐次-f-x-≠0" class="headerlink" title="2.2 非齐次$f(x)≠0$"></a>2.2 非齐次$f(x)≠0$</h2><p>设特解$y_1[x],y_2[x]$：$y_1[x+2]+ay_1[x+1]+by_1[x]-(y_2[x+2]+ay_2[x+1]+by_2[x])&#x3D;f(x)-f(x)$⇒<br>$y_1[x+2]-y_2[x+2]+a(y_1[x+1]-y_2[x+1])+b(y_1[x]-y_2[x])&#x3D;0$⇒<br>通解$y[x]&#x3D;y_0[x]+y^*[x]$</p>
<p>$当f(x)&#x3D;C·p^{t}时设特解y^{<em>}&#x3D;\begin{cases} k·p^{t}(p不是特征根)\ kt·p^{t}(p是特征方程的单根)\ kt^{2}·p^{t}(p是特征方程的重根)\ \end{cases}$$当f(x)&#x3D;p_{0}+p_{1}t+…+p_{m}t^{m}时,$$设特解y^{</em>}&#x3D;\begin{cases} P_{0}+P_{1}t+…+P_{m}t^{m}(1+a+b\ne 0)\ t·(P_{0}+P_{1}t+…+P_{m}t^{m})(1+a+b&#x3D;0且a\ne-2)\ t^{2}·(P_{0}+P_{1}t+…+P_{m}t^{m})(a&#x3D;-2且b&#x3D;1)\ \end{cases}$$当f(t)&#x3D;m^{t}(p_{1}cos\beta t+p_{2}sin\beta t)时,$$设特解为y^{*}&#x3D;\begin{cases}m^{t}(C_{1}cos\beta t+C_{2}sin\beta t) \quad m(cos\beta+sin\beta i)不是特征根时\  tm^{t}(C_{1}cos\beta t+C_{2}sin\beta t) \quad m(cos\beta+sin\beta i)是特征方程的单根时\  t^{2}m^{t}(C_{1}cos\beta t+C_{2}sin\beta t)\quad m(cos\beta+sin\beta i)是特征方程的重根时\ \end{cases}$</p>
]]></content>
  </entry>
  <entry>
    <title>数字图像处理</title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/259666524" title="图像算法原理与实践——绪论 本系列文章是写给程序员的数字图像处理教程，从最基础的知识来讲解数字图像处理专业知识，通过最基本的编码方式来实践相应的处理算法，从而使得大家掌握基础的图像处理知识。 关于图像处理知识，在高校课程中，比… https://zhuanlan.zhihu.com/p/259666524">图像算法原理与实践——绪论 本系列文章是写给程序员的数字图像处理教程，从最基础的知识来讲解数字图像处理专业知识，通过最基本的编码方式来实践相应的处理算法，从而使得大家掌握基础的图像处理知识。 关于图像处理知识，在高校课程中，比… https://zhuanlan.zhihu.com/p/259666524</a></p>
<p>前提：图像数字化<br>图像算法分为三个层次：<br><strong>1）图像处理</strong>：主要是针对图像中的像素级别的数据进行加工。例如：<br>1.图像增强（增强图像的特征或者提取出某些特定的信息）、<br>2.图像复原（对由于各种原因导致质量下降的图像进行修复和改善，以尽可能恢复图像的原始质量。这些原因可能包括传感器噪声、压缩失真、光学畸变等）。<br>2）<strong>图像分析</strong>：通常是从图像中提取出感兴趣的目标对象，然后对目标进行加工。例如：图像分割、特征提取、特征比对、形状分析、目标跟踪、人脸检测、形态学等，这一类都属于图像分析算法。这一类算法将目标对象提取出来以后，需要有单独的描述方式，不再是底层的仅仅像素表示方式。<br>3）<strong>图像理解</strong>：是更高层次的图像的加工算法。例如：压缩感知、3D成像、双目或多目景物重建、场景知识表达等。这一类算法侧重于更高层面的图像的理解和应用。</p>
<p><img src="https://pic4.zhimg.com/80/v2-04d4c1b64674bfd364a3ac9df43a5a9b_1440w.webp"></p>
<p>人的视觉系统</p>
<p><img src="/image/image_HieJjk_eOl.png"></p>
<p>图像处理系统主要由三大部分组成：</p>
<ul>
<li>图像数字化设备，包括数码相机、数码摄像机或手机等</li>
<li>图像处理设备，包括计算机和存储系统</li>
<li>图像输出设备，包括打印机，也可以输出到Internet上的其他设备</li>
</ul>
<h1 id="图像数学表示"><a href="#图像数学表示" class="headerlink" title="图像数学表示"></a>图像数学表示</h1><p>图像每点都包含了空间，亮度，颜色，时间等信息特征;故每个图像元素都能表示为<br>$I&#x3D;f(x,y,z,\lambda,t)；I为光强；xyz为空间坐标；\lambda为波长；t为时间$<br>图像$I&#x3D;{f(x,y,z,\lambda,t)}$为函数f的集合；<br>特别地，静止二维单色图像为$I&#x3D;{f(x,y)}$</p>
<p>人眼&#x2F;传感器输入的图像一般由物体反射光形成，故函数$  I&#x3D;f(x,y) $可由入射分量和反射分量表示：<br>$ I&#x3D;f(x,y)&#x3D;i(x,y)∗r(x,y);<br> $$0&lt;i(x,y)&lt;∞ ;$$反射分量 0&lt;r(x,)&lt;1.0 由反射物体的反射率确定$</p>
<h1 id="离散化："><a href="#离散化：" class="headerlink" title="离散化："></a>离散化：</h1><p>模拟图像：参数是模拟量，典型代表是由光学透镜系统获取的图像，如人物照片、景物照片、图形、X光照片等<br>离散化实现了计算机对图像的存储&#x2F;传输&#x2F;处理<br>数字图像：模拟图像像素所含信息离散化得到：<br>1） 采样：图像是二维分布的信息，在 x 轴和 y 轴两个方向上进行n*m次均匀取样（也可根据特定算法进行）；图像分割成了$N\times M$块区域（像素）；像素数量决定了空间分辨率；采样越少，图像清晰度越低，类似马赛克效应</p>
<p><img src="/image/image_2qga6Ynp08.png"></p>
<p><img src="/image/image_EQwp9wOnXs.png"></p>
<p>每个像素都有一个二维坐标（整数）（x，y）;而在图像批处理运算时；f(x,y)经常构成一个M×N实数矩阵</p>
<p><img src="/image/image_wSOQZlxqzy.png"></p>
<p>2）量化：将连续的波长或光强度信息转换为离散数字表示</p>
<ol>
<li>确定量化级别：量化前要确定图像的亮度级别或颜色级别。对于灰度图像，通常使用8位表示，即256个级别；（量化越少，图像的灰度值分割越少，图像对比度越明显，但是会减少图像的细节信息，故对于有大量细节的图像需要较多的灰度级。）<br>对于彩色图像的每个通道（如RGB），也使用8位表示。</li>
<li>线性量化：线性量化是最简单常见的量化方式。它将连续的波长域或光强度范围均匀分割；然后把每个小区间映射到某个整数区间对应量化级别。例如，在灰度图像中，亮度范围从0到255（8位）被分割为256个区间，每个区间对应一个灰度级别。</li>
</ol>
<p>2.1非统一的图像的采样：<br>1）在灰度级变化尖锐的区域，用细腻的采样 &#x20;<br>2）在灰度级比较平滑的区域，用粗糙的采样<br>3.二进制存储：将映射后的量化级别转换为数字表示，通常使用二进制存储。对于8位表示，使用8个二进制位表示像素的亮度或颜色值</p>
<p><img src="/image/image_pmkJphksDF.png"></p>
<p><img src="/image/image_-59G_vTET8.png"></p>
<p><img src="/image/image_bBA0VRWzfA.png"></p>
<p><a href="%E5%B8%B8%E8%A7%81%E9%87%8F%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%88%E5%83%8F%E7%B4%A0%E8%8A%82%E7%82%B9%EF%BC%89/%E5%B8%B8%E8%A7%81%E9%87%8F%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%88%E5%83%8F%E7%B4%A0%E8%8A%82%E7%82%B9%EF%BC%89.md" title="常见量化方式（像素节点）">常见量化方式（像素节点）</a></p>
<p><strong>归一化表示</strong>：<br>虽然像素颜色信息存储时离散化为整数存储；但在进行图像算法处理时，得还原成模拟量；256个整数集合映射到[0,1]连续区间：<br><strong>整数值 &#x3D; (int)(浮点值*255);</strong> 例如： 0.73 颜色值保存到字节中就是 0xBA(186)<br><strong>浮点值 &#x3D; (float)(整数值 &#x2F; 255.0);</strong></p>
<p>图像的质量<br>0.分辨率：图像中存储的信息量，是每英寸图像内有多少个像素点<br>1.层次：表示图像实际拥有的灰度级的数量，如具有32种不同取值的图像可称该图像具有32个层次。图像数据的实际层次越高，视觉效果越好。<br>2.对比度:是指一幅图像中灰度反差的大小；对比度&#x3D;最大亮度&#x2F;最小亮度<br>3.清晰度： 与清晰度相关的主要因素：亮度、对比度、尺寸大小、细微层次、颜色饱和度<br>4.锐度：<br>空间和灰度分辨率<br>空间分辨率是图像中可分辨的最小细节的度量。<br>灰度分辨率是指在灰度级可分辨的最小变化。灰度分辨率指的则是用于量化灰度的比特数，比如通常一幅图是256级的图像有8比特灰度分辨率</p>
<p><a href="https://zhuanlan.zhihu.com/p/546259316" title="基础概念扫盲(八)：图像的对比度，饱和度、亮度 本文介绍图像的一些基本属性，在一般的图像处理中都会涉及到。 建议收藏+点赞！！！图像的亮度图像的亮度是指图像像素的大小，像素值越大，图像在该像素点越明亮，否则越暗。 对于灰度图像来说，每个像素点只有1个… https://zhuanlan.zhihu.com/p/546259316">基础概念扫盲(八)：图像的对比度，饱和度、亮度 本文介绍图像的一些基本属性，在一般的图像处理中都会涉及到。 建议收藏+点赞！！！图像的亮度图像的亮度是指图像像素的大小，像素值越大，图像在该像素点越明亮，否则越暗。 对于灰度图像来说，每个像素点只有1个… https://zhuanlan.zhihu.com/p/546259316</a></p>
<h1 id="图像存储格式-数据组织"><a href="#图像存储格式-数据组织" class="headerlink" title="图像存储格式(数据组织)"></a>图像存储格式(数据组织)</h1><p><a href="%E5%9B%BE%E5%83%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE%E5%83%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.md" title="图像数据结构">图像数据结构</a></p>
<p>常见的图像存储格式：.bmp； .jpg；.jpeg；.png；.gif；.webp；.tiff；.psd 等；其中大部分格式将像素数据经过压缩后保存，只有BMP格式是支持原始图像数据保存的；<br>格式具有不同的特点和优劣，可以根据存储容量、访问速度、可靠性等选择使用</p>
<p><a href="bmp/bmp.md" title="bmp">bmp</a></p>
<h1 id="像素间的关系"><a href="#像素间的关系" class="headerlink" title="像素间的关系"></a>像素间的关系</h1><p><a href="%E5%83%8F%E7%B4%A0%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/%E5%83%8F%E7%B4%A0%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.md" title="像素间的关系">像素间的关系</a></p>
<h1 id="图像滤波"><a href="#图像滤波" class="headerlink" title="图像滤波"></a>图像滤波</h1><p>1）硬件去噪</p>
<p><a href="%E7%A9%BA%E9%97%B4%E5%9F%9F%E6%BB%A4%E6%B3%A2%E5%99%A8/%E7%A9%BA%E9%97%B4%E5%9F%9F%E6%BB%A4%E6%B3%A2%E5%99%A8.md" title="空间域滤波器">空间域滤波器</a></p>
<p><a href="%E9%A2%91%E5%9F%9F%E6%BB%A4%E6%B3%A2%E5%99%A8%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%9F/%E9%A2%91%E5%9F%9F%E6%BB%A4%E6%B3%A2%E5%99%A8%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%9F.md" title="频域滤波器？？？？">频域滤波器？？？？</a></p>
<p>4）时域去噪</p>
<h1 id="形态学处理"><a href="#形态学处理" class="headerlink" title="形态学处理"></a>形态学处理</h1><p><a href="%E8%85%90%E8%9A%80%E3%80%81%E8%86%A8%E8%83%80%E3%80%81%E5%BC%80%E8%BF%90%E7%AE%97%E3%80%81%E9%97%AD%E8%BF%90%E7%AE%97/%E8%85%90%E8%9A%80%E3%80%81%E8%86%A8%E8%83%80%E3%80%81%E5%BC%80%E8%BF%90%E7%AE%97%E3%80%81%E9%97%AD%E8%BF%90%E7%AE%97.md" title="腐蚀、膨胀、开运算、闭运算">腐蚀、膨胀、开运算、闭运算</a></p>
<h1 id="图像特征工程"><a href="#图像特征工程" class="headerlink" title="图像特征工程"></a>图像特征工程</h1><p>数据清洗：处理缺失值、异常值和重复值。<br>特征选择：选择对目标变量有重要影响的特征，剔除无关的特征，以减少数据维度和提高模型效率。<br>特征提取：从原始数据中提取新的特征，如文本特征抽取、图像特征提取等。<br>特征转换：对特征进行变换，例如对数变换、标准化、归一化等，以符合模型的假设和要求<br>特征构建：创建新的特征，结合领域知识和数据分析，以提高模型的表现。</p>
<p><a href="%E5%9B%BE%E5%83%8F%E7%89%B9%E5%BE%81%EF%BC%9F%EF%BC%9F/%E5%9B%BE%E5%83%8F%E7%89%B9%E5%BE%81%EF%BC%9F%EF%BC%9F.md" title="图像特征？？">图像特征？？</a></p>
<h1 id="图像增强（改变视觉效果）"><a href="#图像增强（改变视觉效果）" class="headerlink" title="图像增强（改变视觉效果）"></a>图像增强（改变视觉效果）</h1><p><a href="%E9%80%9A%E9%81%93%E5%8F%98%E6%8D%A2/%E9%80%9A%E9%81%93%E5%8F%98%E6%8D%A2.md" title="通道变换">通道变换</a></p>
<p><a href="%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%A4%84%E7%90%86/%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%A4%84%E7%90%86.md" title="空间域直方图处理">空间域直方图处理</a></p>
<h1 id="图像校正（改变位置，形状，大小）"><a href="#图像校正（改变位置，形状，大小）" class="headerlink" title="图像校正（改变位置，形状，大小）"></a>图像校正（改变位置，形状，大小）</h1><p><a href="%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%EF%BC%9F/%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%EF%BC%9F.md" title="几何变换？">几何变换？</a></p>
<p><a href="%E5%A4%9A%E5%B8%A7%E5%9B%BE%E5%83%8F%E4%B8%8B%E7%9A%84%E9%80%9A%E9%81%93%E5%8F%98%E6%8D%A2%EF%BC%88%E5%9B%BE%E5%B1%82%E6%B7%B7%E5%90%88%E6%93%8D%E4%BD%9C%EF%BC%89/%E5%A4%9A%E5%B8%A7%E5%9B%BE%E5%83%8F%E4%B8%8B%E7%9A%84%E9%80%9A%E9%81%93%E5%8F%98%E6%8D%A2%EF%BC%88%E5%9B%BE%E5%B1%82%E6%B7%B7%E5%90%88%E6%93%8D%E4%BD%9C%EF%BC%89.md" title="多帧图像下的通道变换（图层混合操作）">多帧图像下的通道变换（图层混合操作）</a></p>
<h1 id="图像复原"><a href="#图像复原" class="headerlink" title="图像复原"></a>图像复原</h1><p><a href="%E5%99%AA%E5%A3%B0%E6%A8%A1%E5%9E%8B%EF%BC%9F/%E5%99%AA%E5%A3%B0%E6%A8%A1%E5%9E%8B%EF%BC%9F.md" title="噪声模型？">噪声模型？</a></p>
<h1 id="图像分割"><a href="#图像分割" class="headerlink" title="图像分割"></a>图像分割</h1><p><strong>基于特定工具的图像分割</strong>，<strong>基于遗传算法的图像分割</strong>，<strong>基于深度学习的图像分割</strong></p>
<p><a href="%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2.md" title="阈值分割">阈值分割</a></p>
<p><a href="%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E5%88%86%E5%89%B2/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E5%88%86%E5%89%B2.md" title="边缘检测分割">边缘检测分割</a></p>
<h1 id="形状分析"><a href="#形状分析" class="headerlink" title="形状分析"></a>形状分析</h1><p><a href="%E8%BD%AE%E5%BB%93%E6%A3%80%E6%B5%8B%EF%BC%8C%E6%8F%90%E5%8F%96%EF%BC%8C%E8%BF%BD%E8%B8%AA%EF%BC%8C%E8%BF%9E%E6%8E%A5/%E8%BD%AE%E5%BB%93%E6%A3%80%E6%B5%8B%EF%BC%8C%E6%8F%90%E5%8F%96%EF%BC%8C%E8%BF%BD%E8%B8%AA%EF%BC%8C%E8%BF%9E%E6%8E%A5.md" title="轮廓检测，提取，追踪，连接">轮廓检测，提取，追踪，连接</a></p>
<h1 id="图像匹配"><a href="#图像匹配" class="headerlink" title="图像匹配"></a>图像匹配</h1><p>特征比对</p>
<h1 id="目标跟踪"><a href="#目标跟踪" class="headerlink" title="目标跟踪"></a>目标跟踪</h1><h1 id="图像识别"><a href="#图像识别" class="headerlink" title="图像识别"></a>图像识别</h1><p><a href="%E8%BF%90%E5%8A%A8%E6%A3%80%E6%B5%8B/%E8%BF%90%E5%8A%A8%E6%A3%80%E6%B5%8B.md" title="运动检测">运动检测</a></p>
<p><a href="%E8%BE%B9%E7%BC%98%E8%BF%BD%E8%B8%AA/%E8%BE%B9%E7%BC%98%E8%BF%BD%E8%B8%AA.md" title="边缘追踪">边缘追踪</a></p>
]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>软件</title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<p><a href="%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80.md" title="编程语言">编程语言</a></p>
<p><a href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&%E7%AE%97%E6%B3%95.md" title="数据结构&amp;算法">数据结构&amp;算法</a></p>
<p><a href="%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F.md" title="编程范式">编程范式</a></p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="业务逻辑层"><a href="#业务逻辑层" class="headerlink" title="业务逻辑层"></a>业务逻辑层</h3><p>基于下层提供的接口组织代码，对<strong>用户行为&#x2F;外部系统输入</strong>设计<strong>系统响应</strong></p>
<p><a href="%E5%B7%A5%E7%A8%8B%E8%90%BD%E5%9C%B0%E6%96%B9%E6%B3%95%E8%AE%BA/%E5%B7%A5%E7%A8%8B%E8%90%BD%E5%9C%B0%E6%96%B9%E6%B3%95%E8%AE%BA.md" title="工程落地方法论">工程落地方法论</a></p>
<h3 id="系统功能接口层"><a href="#系统功能接口层" class="headerlink" title="系统功能接口层"></a>系统功能接口层</h3><p>进行参数检测，屏蔽硬件&#x2F;内核差异，提供符合某种标准的接口，从而调用正确的系统功能接口</p>
<p><a href="%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md" title="设计模式">设计模式</a></p>
<h3 id="系统功能层（自己写库或直接调用三方库）"><a href="#系统功能层（自己写库或直接调用三方库）" class="headerlink" title="系统功能层（自己写库或直接调用三方库）"></a>系统功能层（自己写库或直接调用三方库）</h3><p>实现产品系统功能，封装数据结构和算法，适配各硬件&#x2F;内核平台，给出对应接口</p>
<p><a href="GUI%E7%BC%96%E7%A8%8B/GUI%E7%BC%96%E7%A8%8B.md" title="GUI编程">GUI编程</a></p>
<p><a href="%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8.md" title="安全">安全</a></p>
<p><a href="%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B.md" title="系统编程">系统编程</a></p>
<p><a href="%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.md" title="网络编程">网络编程</a></p>
<p><a href="%E7%BC%96%E8%AF%91%E5%99%A8%E5%8E%9F%E7%90%86&%E8%AE%BE%E8%AE%A1/%E7%BC%96%E8%AF%91%E5%99%A8%E5%8E%9F%E7%90%86&%E8%AE%BE%E8%AE%A1.md" title="编译器原理&amp;设计">编译器原理&amp;设计</a></p>
<h2 id="框架层"><a href="#框架层" class="headerlink" title="框架层"></a>框架层</h2><p>根据产品领域提供通用的软件结构和开发，测试，部署工具集</p>
<p><a href="lvgl/lvgl.md" title="lvgl">lvgl</a></p>
<p><a href="AWTK/AWTK.md" title="AWTK">AWTK</a></p>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p><a href="%E6%95%B0%E6%8D%AE%E5%BA%93&%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93&%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.md" title="数据库&amp;大规模数据处理">数据库&amp;大规模数据处理</a></p>
<p><a href="%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C.md" title="网络">网络</a></p>
<p><a href="%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE.md" title="大数据">大数据</a></p>
<p><a href="%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F.md" title="分布式">分布式</a></p>
<h2 id="操作系统层"><a href="#操作系统层" class="headerlink" title="操作系统层"></a>操作系统层</h2><p>实现内核功能，封装内核功能服务接口</p>
<p><a href="OS/OS.md" title="OS">OS</a></p>
<h2 id="驱动层"><a href="#驱动层" class="headerlink" title="驱动层"></a>驱动层</h2><p>实现硬件功能，封装硬件功能服务接口</p>
<p><a href="%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91.md" title="驱动开发">驱动开发</a></p>
<h2 id="硬件抽象层：将硬件的控制-状态寄存器封装为二进制接口"><a href="#硬件抽象层：将硬件的控制-状态寄存器封装为二进制接口" class="headerlink" title="硬件抽象层：将硬件的控制&#x2F;状态寄存器封装为二进制接口"></a>硬件抽象层：将硬件的控制&#x2F;状态寄存器封装为二进制接口</h2><h2 id="Tool"><a href="#Tool" class="headerlink" title="Tool"></a>Tool</h2><h3 id="build-Toolchain"><a href="#build-Toolchain" class="headerlink" title="build-Toolchain"></a>build-Toolchain</h3><p><a href="GNU%20binutils/GNU%20binutils.md" title="GNU binutils">GNU binutils</a></p>
<p><a href="gcc/gcc.md" title="gcc">gcc</a></p>
<p><a href="makefile/makefile.md" title="makefile">makefile</a></p>
<p><a href="cmake/cmake.md" title="cmake">cmake</a></p>
<h3 id="debugger"><a href="#debugger" class="headerlink" title="debugger"></a>debugger</h3><p><a href="gdb/gdb.md" title="gdb">gdb</a></p>
<h3 id="version-control"><a href="#version-control" class="headerlink" title="version control"></a>version control</h3><p><a href="git-repo-Sourcetree/git-repo-Sourcetree.md" title="git/repo/Sourcetree">git&#x2F;repo&#x2F;Sourcetree</a></p>
<h3 id="editor"><a href="#editor" class="headerlink" title="editor"></a>editor</h3><p><a href="vi/vi.md" title="vi">vi</a></p>
<p>编程是抽象+元结构构建系统还是数据结构+算法？</p>
<p>硬件视角：存储单元和运算单元提供了最基本的代数结构</p>
<p>架构视角：指令集定义了汇编层面上的代数结构</p>
<p>编译器视角：高级语言定义了这个层面的代数结构</p>
<p>业务层视角：基本算法和自定义数据结构定义了代数结构</p>
<p>而业务编写要做的就是把现实问题抽象为黑箱模型编写算法；定义数据结构</p>
<p>1】系统设计：根据信号间的相互作用画出系统框图</p>
<p>2】建立模型</p>
<p><img src="/image/image_N5oCvImrjM.png"></p>
<p><img src="/image/image_kdNOgEo-Dm.png"></p>
<p><img src="/image/image_AI3Njvo4W3.png"></p>
<p><img src="/image/image_i-xdrMAbJK.png"></p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>傅里叶分析</title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%A6/%E5%82%85%E9%87%8C%E5%8F%B6%E5%88%86%E6%9E%90/%E5%82%85%E9%87%8C%E5%8F%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="三角函数的正交性："><a href="#三角函数的正交性：" class="headerlink" title="三角函数的正交性："></a>三角函数的正交性：</h1><p>三角函数系${sin(nx+\frac{k\pi}{2});n,k∈Z}$&#x3D;${1,\mathrm{<del>cosx</del>,<del>sinx</del>,<del>cos2x</del>,<del>sin2x</del>,<del>\ldots</del>,<del>cosnx</del>,<del>sinnx</del>,~\ldots}}$中任取两元素（任意两个三角函数）:<br>$f(x)&#x3D;{f(x);x∈[-\pi,\pi]},g(x)&#x3D;{g(x);x∈[-\pi,\pi]}$<br>两函数内积（即向量各分量的线性组合）$ \lim_{\lambda  \to +\infty}\sum_{x&#x3D;-\pi}^{\pi-\frac{1}{\lambda } } f(x)g(x)\frac{1}{\lambda }  $为0;<br>其所有情况：<br>$  \begin{aligned}&amp;\int_{-\pi}^{\pi}\sin mx\cdot\cos nxdx:&#x3D;:0\\&amp;\int_{-\pi}^{\pi}\cos mx\cdot\cos nxdx:&#x3D;:0\\&amp;\int_{-\pi}^{\pi}\sin mx\cdot\sin nxdx:&#x3D;:0\end{aligned} $；（n≠m）<br>if  n&#x3D;m，存在$\int_{-\pi}^{\pi}\cos mx\cdot\cos nxdx:≠:0$⇒故取n≠m情况；<br>综上：任意两个不同的三角函数在$[-\pi,\pi]$上正交;</p>
<h1 id="周期函数在一个周期上的积分与起点无关："><a href="#周期函数在一个周期上的积分与起点无关：" class="headerlink" title="周期函数在一个周期上的积分与起点无关："></a>周期函数在一个周期上的积分与起点无关：</h1><p>$要证\int_a^{a+T}f(x)\mathrm{<del>d}x&#x3D;\int_0^Tf(x)\mathrm{</del>d}x$<br>⇒$\int_a^{a+T}f(x)\mathrm{~d}x$&#x3D;$ \int_a^0f(x)\mathrm{d}x+\int_0^Tf(x)\mathrm{d}x+\int_T^{a+T}f(x)\mathrm{d}x<br> $；要证$\int_a^0f(x)\mathrm{d}+\int_T^{a+T}f(x)\mathrm{d}x&#x3D;0$<br>⇒令x&#x3D;u+T;$\int_a^0f(x)\mathrm{dx}+\int_0^{a}f(u+T)\mathrm{d}u&#x3D;$$\int_a^0f(x)\mathrm{dx}-\int_a^{0}f(u)\mathrm{d}u&#x3D;0$</p>
<h1 id="傅里叶级数"><a href="#傅里叶级数" class="headerlink" title="傅里叶级数"></a>傅里叶级数</h1><p>将时域上周期为T的函数  分解为  整数倍角频率$n\omega&#x3D;n\frac{2\pi}{T}$三角波（谐波）的叠加（频域函数，甚至复频域）；</p>
<p>强版本：周期为$2\pi$ 的周期函数展开为傅里叶级数:&#x20;<br>$f(x)&#x3D;\sum_{n&#x3D;0}^{+\infty}a_{n}\cos nx+\sum_{n&#x3D;0}^{+\infty}b_{n}\sin nx&#x3D;$$\frac{a’<em>{0}}{2}+\sum</em>{n&#x3D;1}^{\infty}(a_{n}\cos nx+b_{n}\sin nx)$;($a’<em>0&#x3D;2a_0$)<br>利用三角函数正交性消项获得系数：<br>1）$\int</em>{-\pi}^{\pi} f(x)dx$&#x3D;$\int_{-\pi}^{\pi}\frac{a’<em>{0}}{2}dx+\sum</em>{n&#x3D;1}^{+\infty}\int_{-\pi}^{\pi}a_{n}\cos nxdx+\sum_{n&#x3D;1}^{+\infty}\int_{-\pi}^{\pi}b_{n}\sin nxdx$<br>⇒$a’<em>0&#x2F;2&#x3D;\frac{1}{2\pi}$$\int</em>{-\pi}^{\pi} f(x)dx$ &#x20;</p>
<p>2)$\int_{-\pi}^{\pi} f(x)cosmxdx$&#x3D;$\int_{-\pi}^{\pi}\frac{a’<em>{0}}{2}cosmxdx+\sum</em>{n&#x3D;1}^{+\infty}\int_{-\pi}^{\pi}a_{n}\cos nx\cdot cosmxdx+\sum_{n&#x3D;1}^{+\infty}\int_{-\pi}^{\pi}b_{n}\sin nxcosmxdx$<br>⇒$\int_{-\pi}^{\pi} f(x)cosmxdx&#x3D;\int_{-\pi}^{\pi}\sum_{n&#x3D;1}^{+\infty}a_{n}\cos nx\cdot cosmxdx$;(n≠0的项的积分都为0)<br>⇒$\int_{-\pi}^{\pi} f(x)cosnxdx&#x3D;\int_{-\pi}^{\pi}a_{n}\cos nx\cdot cosnxdx$<br>⇒$\int_{-\pi}^{\pi} f(x)cosnxdx&#x3D;\int_{-\pi}^{\pi}a_{n}\frac{1+cos2x}{2}dx$<br>⇒$a_n&#x3D;\frac{1}{\pi}\int_{-\pi}^{\pi} f(x)cosnxdx$</p>
<p>3）$b_n&#x3D;\frac{1}{\pi}\int_{-\pi}^{\pi} f(x)sinnxdx$</p>
<p>放宽条件的弱版本：周期为T ∈R的周期函数展开为傅里叶级数:<br>周期T的g(t)由周期$2\pi$的 f(t)函数拉伸了$\frac{T}{2\pi}$倍；同相位自变量变换因子$\omega$&#x3D;$\frac{2\pi}{T}$：g(t)$:&#x3D;$ f($\frac{2\pi}{T}$t)<br>$g(t)&#x3D;f($$\frac{2\pi}{T}$$t$)&#x3D;$\sum_{n&#x3D;0}^{+\infty}a_{n}\cos n\frac{2\pi}{T}t+\sum_{n&#x3D;0}^{+\infty}b_{n}\sin n\frac{2\pi}{T}t$&#x3D;$\frac{a’<em>{0}}{2}+\sum</em>{n&#x3D;1}^{\infty}(a_{n}\cos n\frac{2\pi}{T}t+b_{n}\sin n\frac{2\pi}{T}t)$<br>利用三角函数正交性消项获得系数：<br>1)$ a’<em>0&#x2F;2&#x3D;\frac{1}{2T}\int</em>{-T&#x2F;2}^{T&#x2F;2} g(t)dt  $&#x3D;$ \frac{1}{2T}\int_{0}^{T} g(t)dt  $<br>2)$a_n&#x3D;\frac{1}{T}\int_{-T&#x2F;2}^{T&#x2F;2} g(t)cosn\frac{2\pi}{T}tdt&#x3D;\frac{1}{T}\int_{0}^{T} g(t)cosn\frac{2\pi}{T}tdt$<br>3)$b_n&#x3D;\frac{1}{T}\int_{-T&#x2F;2}^{T&#x2F;2} g(t)sinn\frac{2\pi}{T}tdt&#x3D;\frac{1}{T}\int_{0}^{T} g(t)sinn\frac{2\pi}{T}tdt$</p>
<p>证明：参考苏云答案以及信号与系统</p>
<p><a href="https://www.zhihu.com/question/40663709" title="傅里叶级数为什么会收敛到原函数？ - 知乎 不好意思问题太初级了，可耻匿了，希望知乎各位大神解答一下，实在理解不了啊。高数可怎么办呢？ https://www.zhihu.com/question/40663709">傅里叶级数为什么会收敛到原函数？ - 知乎 不好意思问题太初级了，可耻匿了，希望知乎各位大神解答一下，实在理解不了啊。高数可怎么办呢？ https://www.zhihu.com/question/40663709</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/378399611" title="如何理解一致收敛？ 原回答：如何理解函数列的一致收敛？ 要说 一致收敛就要和普遍的逐点收敛（或者在某个点收敛）作一下对比了。其实把这个问题拆开来讲也很简单： 先约定前 n 项和为： S_n(x)= \sum^{n}_{k=1} u_k(x) 单点收敛对定… https://zhuanlan.zhihu.com/p/378399611">如何理解一致收敛？ 原回答：如何理解函数列的一致收敛？ 要说 一致收敛就要和普遍的逐点收敛（或者在某个点收敛）作一下对比了。其实把这个问题拆开来讲也很简单： 先约定前 n 项和为： S_n(x)&#x3D; \sum^{n}_{k&#x3D;1} u_k(x) 单点收敛对定… https://zhuanlan.zhihu.com/p/378399611</a></p>
<p>傅里叶级数的复数形式：<br>$g(t)&#x3D;$$\frac{a’<em>{0}}{2}+\sum</em>{n&#x3D;1}^{\infty}(a_{n}\cos n\frac{2\pi}{T}t+b_{n}\sin n\frac{2\pi}{T}t)$&#x3D;$\frac{a’<em>{0}}{2}$+$\sum</em>{n&#x3D;1}^{+\infty}(a_{n}\frac{e^{jn\frac{2\pi}{T}t}+e^{-jn\frac{2\pi}{T}t}}{2}+b_{n}\frac{e^{jn\frac{2\pi}{T}t}-e^{-jn\frac{2\pi}{T}t}}{2j})$<br>=$\frac{a’<em>{0}}{2}$+$\sum</em>{n&#x3D;1}^{+\infty}(a_{n}\frac{e^{jn\frac{2\pi}{T}t}+e^{-jn\frac{2\pi}{T}t}}{2}-jb_{n}\frac{e^{jn\frac{2\pi}{T}t}-e^{-jn\frac{2\pi}{T}t}}{2})$&#x3D;$\frac{a’<em>{0}}{2}$+$<br> \sum</em>{n&#x3D;1}^{+\infty}\frac{a_{n}-jb_{n}}{2}e^{jn\frac{2\pi}{T}t}+<br> \sum_{n&#x3D;1}^{+\infty}\frac{a_{n}+jb_{n}}{2}e^{-jn\frac{2\pi}{T}t}  $<br>令n&#x3D;-n：<br>=$\sum_{n&#x3D;0}^{0}\frac{a’<em>{0}}{2}e^{jn\frac{2\pi}{T}t}+$$ $$\sum</em>{n&#x3D;1}^{+\infty}\frac{a_{n}-jb_{n}}{2}e^{jn\frac{2\pi}{T}t}+ \sum_{n&#x3D;-1}^{-\infty}\frac{a_{-n}+jb_{-n}}{2}e^{jn\frac{2\pi}{T}t}$<br>=$\sum_{-\infty}^{+\infty}C_ne^{jn\frac{2\pi}{T}t}$</p>
<p>$C_n&#x3D;\begin{cases}<br>\\frac{a’<em>{0}}{2}&#x3D;\frac{1}{2T}\int</em>{0}^{T} g(t)dt ;n&#x3D;0\<br>\\frac{a_{n}-jb_{n}}{2}&#x3D;\frac{1}{T}\int_{0}^{T} g(t)(cosn\frac{2\pi}{T}t- jsinn\frac{2\pi}{T}t)dt&#x3D;\frac{1}{T}\int_{0}^{T} g(t)e^{-jn\frac{2\pi}{T}t}dt;n∈Z^+\<br>\\frac{a_{-n}+jb_{-n}}{2}&#x3D;\frac{1}{T}\int_{0}^{T} g(t)(cosn\frac{2\pi}{T}t- jsinn\frac{2\pi}{T}t)dt&#x3D;\frac{1}{T}\int_{0}^{T} g(t)e^{-jn\frac{2\pi}{T}t}dt;n∈Z^-<br>\end{cases}$<br>⇒<br>$C_n&#x3D;\frac{1}{T}\int_{0}^{T} g(t)e^{-jn\omega t}dt$<br>g(t)&#x3D;$\sum_{n&#x3D;-\infty}^{+\infty}C_ne^{jn\omega t}$&#x3D;$….+C_0+C_1e^{j1\omega t}+C_2e^{j2\omega t}+…..C_ne^{jn\omega t}+……$&#x3D;$g(\omega)$</p>
<p>非周期函数(T→$\infty$,$\omega→0$)的傅里叶级数：<br>$g(t)&#x3D;\sum_{-\infty}^{+\infty}(\frac{\omega}{2\pi}\int_{-\infty}^{+\infty} g(t)e^{-jn\omega t}dt)e^{jn\omega t}$&#x3D;$\frac{1}{2\pi}\int _{-\infty}^{+\infty}<br>[\int _{-\infty}^{+\infty} g(t)e^{-jn\omega t}dt]e^{jn\omega t}</p>
<p>d\omega$&#x3D;$\frac{1}{2\pi}\int _{-\infty}^{+\infty}<br>F(\omega)e^{jn\omega t}</p>
<p>d\omega$<br>$F(\omega)&#x3D;\int _{-\infty}^{+\infty} g(t)e^{-jn\omega t}dt$;这个式子称为傅里叶变换($s&#x3D;jn\omega$ 为拉氏变换)<br> $F^{-1}(\omega)&#x3D;g(t)&#x3D;\frac{1}{2\pi}\int _{-\infty}^{+\infty}<br>F(\omega)e^{jn\omega t}</p>
<p>d\omega$;称为傅里叶逆变换</p>
<p><img src="/image/image_5VixB9uxF7.png"></p>
<p>物理角度</p>
<p><img src="/image/image_YyTKVkW4xX.png"></p>
<h1 id="傅里叶算子性质（对T相同输入函数）"><a href="#傅里叶算子性质（对T相同输入函数）" class="headerlink" title="傅里叶算子性质（对T相同输入函数）"></a>傅里叶算子性质（对T相同输入函数）</h1><p>$x(t)\overset{FS}{\operatorname*{\longleftrightarrow}}\sum_{n&#x3D;-\infty}^{+\infty}C_ne^{jn\frac{2\pi}{T}t}&#x3D;\sum_{n&#x3D;-\infty}^{+\infty}(\frac{1}{T}\int_{0}^{T} x(t)e^{-jn\frac{2\pi}{T}t}dt)e^{jn\frac{2\pi}{T}t}$;<br>对于相同T的不同输入函数：$C_n取决于x(t)$，其余部分的形式对任意x(t)都是相同的；简化描述为：$x(t)\overset{FS}{\operatorname*{\longleftrightarrow}}C_n$</p>
<h2 id="线性"><a href="#线性" class="headerlink" title="线性"></a>线性</h2><p>input输入函数的线性组合；output输入响应的线性组合：$Ax(t)+By(t)\longleftrightarrow Aa_{k}+Bb_{k}$<br>简单验证：$C_n&#x3D;\frac{1}{T}\int_{0}^{T} [Ax(t)+By(t)]e^{-jn\frac{2\pi}{T}t}dt&#x3D;Aa_{k}+Bb_{k}$</p>
<h2 id="时移"><a href="#时移" class="headerlink" title="时移"></a>时移</h2><p>$x(t)\overset{FS}{\operatorname*{\longleftrightarrow}}C_n$；发生时移则：$x(t-t_0)\overset{FS}{\longleftrightarrow}C_ne^{-jn\frac{2\pi}{T}t_0}$<br>验证：$C’<em>n&#x3D;\frac{1}{T}\int</em>{0}^{T} x(t-t_0)e^{-jn\frac{2\pi}{T}t}dt$;令$\tau &#x3D;t-t_0$:$C’<em>n&#x3D;\frac{1}{T} \int</em>{0}^{T} x(\tau)e^{-jn\frac{2\pi}{T}(\tau +t_0)}d\tau$&#x3D;$C_ne^{-jn\frac{2\pi}{T}t_0}$</p>
<h2 id="时间反转"><a href="#时间反转" class="headerlink" title="时间反转"></a>时间反转</h2><p>$x(-t)\longleftrightarrow C_{-n}$:<br>$C’<em>n&#x3D;\frac{1}{T}\int</em>{0}^{T} x(-t)e^{-jn\frac{2\pi}{T}t}dt$:令$\tau &#x3D;-t$：$C’<em>n&#x3D;-\frac{1}{T} \int</em>{0}^{-T} x(\tau)e^{-jn\frac{2\pi}{T}(-\tau)}d\tau$&#x3D;$C’<em>n&#x3D;\frac{1}{T} \int</em>{0}^{T} x(\tau)e^{j(-n)\frac{2\pi}{T}\tau}d\tau$&#x3D;$C_{-n}$</p>
<h2 id="时域尺度变换-周期发生变化"><a href="#时域尺度变换-周期发生变化" class="headerlink" title="时域尺度变换(周期发生变化)"></a>时域尺度变换(周期发生变化)</h2><p>$x(at)\overset{FS}{\operatorname*{\longleftrightarrow}}C_n$;其周期为$\frac{T}{a}$:<br>验证：$C’<em>n&#x3D;\frac{1}{T}\int</em>{0}^{T} x(at)e^{-jn\frac{2\pi}{T}t}dt$;令$\tau &#x3D;at$:$C’<em>n&#x3D;\frac{1}{aT} \int</em>{0}^{aT} x(\tau)e^{-jn\frac{2\pi}{T}(tau&#x2F;a)}d\tau$&#x3D;$\frac{1}{T} \int_{0}^{T} x(\tau)e^{-jn\frac{2a\pi}{T}(tau&#x2F;a)}d\tau$&#x3D;$C_n$</p>
<h2 id="相乘"><a href="#相乘" class="headerlink" title="相乘"></a>相乘</h2><p>周期为T的输入：<br>$x(t)y(t)\longleftrightarrow\sum_{l&#x3D;-\infty}^{\infty}a_lb_{n-l}&#x3D;a_n*b_n$<br>验证：$C’<em>n&#x3D;\frac{1}{T}\int</em>{0}^{T} x(t)y(t)e^{-jn\frac{2\pi}{T}t}dt&#x3D;\frac{1}{T}\int_{0}^{T} (\sum_{l&#x3D;-\infty}^{+\infty}a_le^{jl\frac{2\pi}{T}\text{t}})y(t)e^{-jn\frac{2\pi}{T}t}dt&#x3D;\sum_{l&#x3D;-\infty}^{+\infty}a_l\frac{1}{T}\int_{0}^{T}y(t)e^{-j(n-l)\frac{2\pi}{T}t}dt&#x3D;\sum_{l&#x3D;-\infty}^{+\infty}a_lb_{n-l}$</p>
<h2 id="微分"><a href="#微分" class="headerlink" title="微分"></a>微分</h2><p>$\frac{dx(t)}{dt}\overset{FS}{\operatorname*{\longleftrightarrow}}jn\omega_0C_n$<br>证：$ x(t)&#x3D;$$   \sum_{n&#x3D;-\infty}^{+\infty}C_ne^{jn\frac{2\pi}{T}\text{t}}  $;两边乘d&#x2F;dt<br>⇒$ dx(t)&#x2F;dt&#x3D;$$   \sum_{n&#x3D;-\infty}^{+\infty}jn\omega C_ne^{jn\frac{2\pi}{T}\text{t}}  $</p>
<h2 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h2><p>$\int_{-\infty}^tx(t)dt\longleftrightarrow\frac1{jn\omega_0}C_n$;要$a_0$&#x3D;0,否则变换结果不收敛<br>？？？？？？？？？？？？</p>
<h2 id="共轭"><a href="#共轭" class="headerlink" title="共轭"></a>共轭</h2><p>$x^*(t)\longleftrightarrow C_{-n}^*$<br>证：$ x(t)&#x3D;$$   \sum_{n&#x3D;-\infty}^{+\infty}C_ne^{jn\frac{2\pi}{T}\text{t}}  $;两边共轭<br>⇒$ x^*(t)&#x3D;$$   \sum_{n&#x3D;-\infty}^{+\infty}C^*<em>ne^{-jn\frac{2\pi}{T}\text{t}}  $;令n&#x3D;-n<br>⇒$ x^*(t)&#x3D;$$   \sum</em>{n&#x3D;-\infty}^{+\infty}C^*_{-n}e^{jn\frac{2\pi}{T}\text{t}}  $</p>
<p>若x(t)是实函数:x(t)&#x3D;$x^*(t)$$C_n&#x3D;C^*_{-n}$<br>若x(t)&#x3D;x(-t)是偶实函数：$C_n&#x3D;C^*_{-n}&#x3D;C_{-n}&#x3D;C^*_{n}$⇒$C_n是实偶函数$<br>若x(t)&#x3D;-x(-t)是奇实函数：$C_n&#x3D;C^*_{-n}&#x3D;-C_{-n}&#x3D;-C^*_{n}$⇒$C_n是纯虚奇函数$</p>
<h2 id="频移"><a href="#频移" class="headerlink" title="频移"></a>频移</h2><h2 id="周期卷积"><a href="#周期卷积" class="headerlink" title="周期卷积"></a>周期卷积</h2><h2 id="周期信号的帕斯瓦尔定理"><a href="#周期信号的帕斯瓦尔定理" class="headerlink" title="周期信号的帕斯瓦尔定理"></a>周期信号的帕斯瓦尔定理</h2><p>$\frac{1}{T}\int_{T}\mid x(t)\mid^{2}\mathrm{d}t&#x3D;\sum_{k&#x3D;-\infty}^{+\infty}\mid a_{k}\mid^{2}$</p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>微分方程</title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%A6/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/592540581" title=" 一阶线性微分方程浅谈·中文版 一、可分离变量类在以前的学习中，我们已经知道了形似 \frac{\mathrm{d} y}{\mathrm{d} x} = f(x) g(y) 的一阶微分方程可以通过分离变量的方式求解： \int \frac{1}{g(y)}dy = \int f(x)dx .一个简单的例子是： \f… https://zhuanlan.zhihu.com/p/592540581"> 一阶线性微分方程浅谈·中文版 一、可分离变量类在以前的学习中，我们已经知道了形似 \frac{\mathrm{d} y}{\mathrm{d} x} &#x3D; f(x) g(y) 的一阶微分方程可以通过分离变量的方式求解： \int \frac{1}{g(y)}dy &#x3D; \int f(x)dx .一个简单的例子是： \f… https://zhuanlan.zhihu.com/p/592540581</a></p>
<h1 id="一阶线性微分"><a href="#一阶线性微分" class="headerlink" title="一阶线性微分"></a>一阶线性微分</h1><h2 id="可分离变量类"><a href="#可分离变量类" class="headerlink" title="可分离变量类"></a>可分离变量类</h2><p>形如$\frac{\mathrm{d}y}{\mathrm{d}x}&#x3D;f(x)g(y)：略$</p>
<h2 id="直接分部积分法"><a href="#直接分部积分法" class="headerlink" title="直接分部积分法"></a>直接分部积分法</h2><p>一阶微分方程拥有显式的分部积分关系：$u\frac{\mathrm{d}v}{\mathrm{d}x}+v\frac{\mathrm{d}u}{\mathrm{d}x}&#x3D;\frac{\mathrm{d}}{\mathrm{d}x}(uv)&#x3D;f(x)$；两边同时积分$\int u\frac{\mathrm{d}v}{\mathrm{d}x}+\int v\frac{\mathrm{d}u}{\mathrm{d}x}&#x3D;uv&#x3D;\int f(x)$；即根据$uv&#x3D;\int f(x)$解出y的值（u,v是y的函数）<br>ex:$x^3\frac{\mathrm{d}y}{\mathrm{d}x}+3x^2y&#x3D;sinx$<br>解：$\begin{aligned}<br>&amp;u&#x3D;x^3\text{, }v&#x3D;y\text{,则: }uv&#x3D;x^3y&#x3D;\int sinxdx&#x3D;-cosx+c\mathrm{~.} \<br>&amp;\text{得:}\quad y&#x3D;-\frac{cosx}{x^3}+\frac c{x^3}.<br>\end{aligned}$</p>
<h2 id="「凑」分部积分法"><a href="#「凑」分部积分法" class="headerlink" title="「凑」分部积分法"></a>「凑」分部积分法</h2><p>形如$\frac{\mathrm{d}y}{\mathrm{d}x}+f(x)y&#x3D;g(x)$的1阶微分方程的分部积分关系不是显式的；<br>令$h(x)\frac{\mathrm{d}y}{\mathrm{d}x}+h(x)f(x)y&#x3D;g(x)h(x)$；存在（1）$u’(x)&#x3D;h’(x)&#x3D;h(x)f(x)$关系;<br>根据（1），$e^{\int f(x)dx}&#x3D;h(x)$<br>⇒$ e^{\int f(x)dx} \frac{\mathrm{d} y}{\mathrm{d} x} + e^{\int f(x)dx}  f(x)y&#x3D;g(x) e^{\int f(x)dx}  $<br>根据分部积分$uv&#x3D;\int g(x)h(x)$<br>⇒$e^{\int f(x)dx}y&#x3D;\int g(x)e^{\int f(x)dx}$<br>⇒$ y&#x3D;\frac{\int g(x) e^{\int f(x)dx}dx}{e^{\int f(x)dx}}  $&#x20;<br>此类方程的步骤总结为：</p>
<p><img src="/image/image_35_L_NUHnZ.png"></p>
<h1 id="二阶线性微分"><a href="#二阶线性微分" class="headerlink" title="二阶线性微分"></a>二阶线性微分</h1><p>微分算子是线性算子：$ \forall k\in R,\frac{\mathrm{d} }{\mathrm{d} x} (\sum_{i&#x3D;1}^{n} k_i\cdot f_{i}(x))&#x3D;\sum_{i&#x3D;1}^{n} k_i\frac{\mathrm{d}  f_{i}(x)}{\mathrm{d} x}  $</p>
<h2 id="常系数齐次微分-a-frac-mathrm-d-2y-mathrm-d-x-2-b-frac-mathrm-d-y-mathrm-d-x-cy-0；a≠0"><a href="#常系数齐次微分-a-frac-mathrm-d-2y-mathrm-d-x-2-b-frac-mathrm-d-y-mathrm-d-x-cy-0；a≠0" class="headerlink" title="常系数齐次微分$a\frac{\mathrm{d} ^2y}{\mathrm{d} x^2} +b\frac{\mathrm{d} y}{\mathrm{d} x} +cy&#x3D;0；a≠0$"></a>常系数齐次微分$a\frac{\mathrm{d} ^2y}{\mathrm{d} x^2} +b\frac{\mathrm{d} y}{\mathrm{d} x} +cy&#x3D;0；a≠0$</h2><p>（1）解向量组的秩为2？？？？？<br>（2）特解$y_1&#x3D;A$$e^{kx}$(猜的)；另一解$y_2$必须要与$y_1$线性无关才能构成通解：$\frac{y_1}{y_2}必不能为常数$</p>
<p>1）令$y&#x3D;e^{kx}\quad,\quad\frac{\mathrm{d}y}{\mathrm{d}x}&#x3D;ke^{kx}\quad,\quad\frac{\mathrm{d}^2y}{\mathrm{d}x^2}&#x3D;k^2e^{kx}$；待定系数<br>⇒$ ak^2e^{kx}+bke^{kx}+ce^{kx}&#x3D;0  $<br>⇒$e^{kx}(ak^2+bk+c)&#x3D;0$&#x20;<br>解出特征根(系数)：<br>$\Delta &gt; 0$：含有两个实根（$\alpha$，$\beta$）：得到$y_1&#x3D;e^{\alpha x}$和$y_2&#x3D;e^{\beta x}$：$ {\color{Red} y \color{Red} &#x3D; \color{Red} A \color{Red} e^{\color{Red}\alpha \color{Red} x} \color{Red} + \color{Red} B \color{Red} e^{\color{Red}\beta \color{Red} x} }  $（需$\frac{e^{\alpha x}}{e^{\beta x}} \ne c$）；$A,B\in R$$\Delta &#x3D;0$：含重根$y_{1}&#x3D;e^{\alpha x}$；（$\frac{e^{\alpha x}}{e^{\alpha x}} &#x3D;1$显然不行）<br><strong>设</strong>$\frac{y_2}{y_1}&#x3D; \varphi(x)$<strong>：寻找另一线性无关解</strong>${y_2}&#x3D; \varphi(x) {y_1}&#x3D; \varphi(x)e^{kx}$：<br>待定系数：$e^{kx}(a {\varphi}’’(x)+2ak {\varphi}’(x)+ak^2 {\varphi}(x)+b {\varphi}’(x)+bk {\varphi}(x) +c{\varphi}(x))&#x3D;0$<br>⇒解特征方程$(ak^2+bk+c) {\varphi}(x)+(2ak+b) {\varphi}’(x)+a {\varphi}’’(x)&#x3D;0$<br>⇒$(2ak+b) {\varphi}’(x)+a {\varphi}’’(x)&#x3D;0$；k是根知道可消<br>⇒${\varphi}’’(x)&#x3D;0$<br>⇒${\varphi}’(x)&#x3D;\int{\varphi}’’(x)dx&#x3D;c_1$<br>⇒${\varphi}(x)&#x3D;\int{\varphi}’(x)dx&#x3D;c_1x+c_2$<br>⇒$y_2&#x3D; (c_1x+c_2)y_1&#x3D; (c_1x+c_2)e^{\alpha x}$<br>随便代个数给$c_1,c_2$⇒$y_2&#x3D;xe^{\alpha x}$<br>⇒${y}&#x3D;Ay_1+By_2&#x3D;Ae^{\alpha x}+Bxe^{\alpha x} {&#x3D;} {(} { A} {  +} {B} {x} {)} {e}^{\alpha{x}}$</p>
<p>$\Delta &lt; 0$:有两个不同的共轭虚根系数$p+qi$，$p-qi$：<br>$y_1&#x3D;e^{(p+qi)x}&#x3D; e^{px}\cdot e^{iqx}$&#x3D;$e^{px}(cosqx+isinqx)$$y_2&#x3D;e^{px}\cdot e^{-iqx}&#x3D;e^{px}(cosqx-isinqx)$<br>到这一步其实就可以了，但还可以构造两个形式更好的线性无关解：<br>$y_3&#x3D;\frac{1}{2}(y_1+y_2)&#x3D;e^{px}cosqx$$y_4&#x3D;\frac{1}{2i}(y_1-y_2)&#x3D;e^{px}sinqx$$y&#x3D;Ay_3+By_4&#x3D;Ae^{px}cosqx+Be^{px}sinqx&#x3D;(Acosqx+Bsinqx)e^{px}$</p>
<p><img src="/image/image_n3XJO4DZTx.png"></p>
<h2 id="常系数非齐次微分-a-frac-mathrm-d-2y-mathrm-d-x-2-b-frac-mathrm-d-y-mathrm-d-x-cy-f-x-；a≠0"><a href="#常系数非齐次微分-a-frac-mathrm-d-2y-mathrm-d-x-2-b-frac-mathrm-d-y-mathrm-d-x-cy-f-x-；a≠0" class="headerlink" title="常系数非齐次微分$a\frac{\mathrm{d} ^2y}{\mathrm{d} x^2} +b\frac{\mathrm{d} y}{\mathrm{d} x} +cy&#x3D;f(x)；a≠0$"></a>常系数非齐次微分$a\frac{\mathrm{d} ^2y}{\mathrm{d} x^2} +b\frac{\mathrm{d} y}{\mathrm{d} x} +cy&#x3D;f(x)；a≠0$</h2><p>尝试从齐次方程解推广到非齐：<br>1）假设有特解$y_1$使之成立：$a\frac{\mathrm{d} ^2}{\mathrm{d} x^2}y_{1} +b\frac{\mathrm{d} }{\mathrm{d} x} y_{1}+cy_{1}&#x3D;f(x)$<br>令$a\frac{\mathrm{d} ^2y}{\mathrm{d} x^2} +b\frac{\mathrm{d} y}{\mathrm{d} x} +cy$-$a\frac{\mathrm{d} ^2}{\mathrm{d} x^2}y_{1} +b\frac{\mathrm{d} }{\mathrm{d} x} y_{1}+cy_{1}&#x3D;f(x)$$-f(x)$构造齐次方程<br>⇒$a\frac{\mathrm{d} ^2}{\mathrm{d} x^2}(y-y_{1}) +b\frac{\mathrm{d} }{\mathrm{d} x} (y-y_{1}) +c(y-y_{1}) &#x3D;0$；可见齐次解$y_{2}&#x3D;y-y_{1}$与通解的关系<br>y的解为齐次解$y_2$+特解$y_1$<br>2）对于特解：前辈们一个个试出来了。。。。</p>
<p><img src="/image/image_yMFKIdz2rV.png"></p>
<p>知道特解的形式后，可以用待定系数法，将特解回代到原方程中，得到未知的系数；</p>
<p>还有一种情况要注意：特解与齐次解的某一项线性相关（必与齐次解线性相关），那么给特解乘个x</p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>bmp</title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/bmp/bmp/</url>
    <content><![CDATA[<p>采用位映射存储格式，图像深度可选：1bit、4bit、8bit及24bit；不采用其他任何压缩，因此，BMP文件所占用的空间很大。<br>BMP文件存储数据时，图像的扫描方式是按<strong>从左到右</strong>、<strong>从下到上</strong>的顺序。由于BMP文件格式是Windows环境中交换与图有关的数据的一种标准</p>
<h2 id="BMP文件格式详解（bmp类）"><a href="#BMP文件格式详解（bmp类）" class="headerlink" title="BMP文件格式详解（bmp类）"></a>BMP文件格式详解（bmp类）</h2><p><img src="https://pic3.zhimg.com/80/v2-9d5e4746d52dc9eb9887cfe76e595a3a_1440w.webp"></p>
<p>BMP文件由四个部分构成：</p>
<p>（1）<strong>BMP文件头</strong>(bmp file header)：固定占用14字节,用于标识文件格式和一些基本信息。</p>
<ul>
<li>文件类型（2字节）：标识文件为BMP格式，通常为”BM”。</li>
<li>文件大小（4字节）：指定整个BMP文件的大小，以字节为单位。</li>
<li>保留字段（4字节）：保留字段，通常设置为0。</li>
<li>数据偏移量（4字节）：指定图像像素数据相对于文件起始位置的偏移量。</li>
</ul>
<p>（2）<strong>位图信息头</strong>(bitmap information)：提供图像数据的尺寸、位平面数、压缩方式、颜色索引等信息</p>
<ul>
<li>信息头大小（4字节）：指定信息头的大小。</li>
<li>图像宽度（4字节）：图像的宽度，以像素为单位。</li>
<li>图像高度（4字节）：图像的高度，以像素为单位。</li>
<li>颜色平面数（2字节）：总为1。</li>
<li>颜色位深度（2字节）：指定每个像素的位深度，即用于表示颜色的比特数。</li>
<li>压缩类型（4字节）：指定图像数据的压缩类型，常见的有无压缩、RLE压缩等。</li>
<li>图像大小（4字节）：指定图像数据的大小，以字节为单位。若使用无压缩存储，通常为0。</li>
<li>水平分辨率（4字节）：图像的水平分辨率，以像素每米为单位。</li>
<li>垂直分辨率（4字节）：图像的垂直分辨率，以像素每米为单位。</li>
<li>使用的颜色数（4字节）：图像实际使用的调色板中的颜色数目。若为0，则表示使用了所有颜色。</li>
<li>重要颜色数（4字节）：对图像产生重要影响的颜色数目。若为0，则表示所有调色板项都重要。</li>
</ul>
<p><del>（3）~~~~<strong>调色板</strong>~~~~(color palette)：可选，如使用索引来表示图像，调色板就是索引与其对应的颜色的映射表，在使用 256位彩色、16位彩色等情况下用到</del></p>
<p>（4）<strong>位图数据</strong>(bitmap data)：存放图像的像素数据；存放顺序从左到右、从下到上的顺序存放。<br>每一行像素数据需要保证4字节对齐，不对齐的需要补充空字节，这个是BMP文件格式本身要求的。对于RGBA 32位色彩格式来说没有任何问题，但是对于Gray或者RGB格式的数据 ，有时一行像素需要补充一些空字节。</p>
<p><img src="/image/image_oTHOVehBMU.png"></p>
<p><img src="/image/image_1HPal6m-Nq.png"></p>
<p><img src="/image/image_qXlIlM0XdP.png"></p>
<h2 id="BMP文件读写操作（bmp方法）"><a href="#BMP文件读写操作（bmp方法）" class="headerlink" title="BMP文件读写操作（bmp方法）"></a>BMP文件读写操作（bmp方法）</h2><p>考虑到调色板格式的色彩格式现在几乎不再使用，因此我们代码中也不考虑这种情况。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Bmp file structure</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XBMP_FILEHDR_LEN        14</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tag_XBmpFileHeader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint16_t</span>      bfType;</span><br><span class="line">  <span class="type">uint32_t</span>      bfSize;</span><br><span class="line">  <span class="type">uint16_t</span>      bfReserved1;</span><br><span class="line">  <span class="type">uint16_t</span>      bfReserved2;</span><br><span class="line">  <span class="type">uint32_t</span>      bfOffBits;</span><br><span class="line">&#125;XBMPFILE_HEADER, *LPXBMPFILE_HEADER;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XBMP_INFOHDR_LEN        40</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tag_XBMPINFO_HEADER</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span>      biSize;</span><br><span class="line">  <span class="type">int32_t</span>        biWidth;</span><br><span class="line">  <span class="type">int32_t</span>        biHeight;</span><br><span class="line">  <span class="type">uint16_t</span>      biPlanes;</span><br><span class="line">  <span class="type">uint16_t</span>      biBitCount;</span><br><span class="line">  <span class="type">uint32_t</span>      biCompression;</span><br><span class="line">  <span class="type">uint32_t</span>      biSizeImage;</span><br><span class="line">  <span class="type">int32_t</span>        biXPelsPerMeter;</span><br><span class="line">  <span class="type">int32_t</span>        biYPelsPerMeter;</span><br><span class="line">  <span class="type">uint32_t</span>      biClrUsed;</span><br><span class="line">  <span class="type">uint32_t</span>      biClrImportant;</span><br><span class="line">&#125; XBMPINFO_HEADER, *LPXBMPINFO_HEADER;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XBMP_RGBQUAD_LEN        4</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">tag_XBmp_RGBQUAD</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint8_t</span>        rgbBlue; </span><br><span class="line">  <span class="type">uint8_t</span>        rgbGreen;</span><br><span class="line">  <span class="type">uint8_t</span>        rgbRed;</span><br><span class="line">  <span class="type">uint8_t</span>        rgbReserved;</span><br><span class="line">&#125; XBMP_RGBQUAD, *LPXBMP_XBMP_RGBQUAD;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">XImage::LoadFromBmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* bmp_file_path)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (bmp_file_path == nullptr)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> XERR_INVALID_PARAM;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  FILE* file_handler = fopen(bmp_file_path, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (file_handler == nullptr)</span><br><span class="line">  &#123;</span><br><span class="line">    XOS_ERROR(TAG_IMGENG, <span class="string">&quot;&lt;XImage.LoadFromBmp&gt; fail to fopen(), file=%s&quot;</span>, bmp_file_path);</span><br><span class="line">    <span class="keyword">return</span> XERR_FILE_OPEN;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 判断位图文件头结构BITMAPFILEHEADER</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  XBMPFILE_HEADER  sFileHdr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="type">uint8_t</span> szBuffer[<span class="number">255</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">  fread(szBuffer, <span class="number">1</span>, XBMP_FILEHDR_LEN, file_handler);</span><br><span class="line">  sFileHdr.bfType = ((<span class="type">uint32_t</span>)szBuffer[<span class="number">0</span>] | (<span class="type">uint32_t</span>)szBuffer[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0x4D42</span> != sFileHdr.bfType)</span><br><span class="line">  &#123;</span><br><span class="line">    XOS_ERROR(TAG_IMGENG, <span class="string">&quot;&lt;XImage.LoadFromBmp&gt; not BM flag, file=%s&quot;</span>, bmp_file_path);</span><br><span class="line">    fclose(file_handler);</span><br><span class="line">    <span class="keyword">return</span> XERR_UNSUPPORTED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 读取位图信息头结构变量，读取位图信息头进内存， 存放在变量head中  </span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  XBMPINFO_HEADER  sInfoHdr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">  XBMP_RGBQUAD*  pColorTab = XNULL;</span><br><span class="line">  <span class="built_in">memset</span>(szBuffer, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">  fread(szBuffer, <span class="number">1</span>, XBMP_INFOHDR_LEN, file_handler);</span><br><span class="line">  sInfoHdr.biSize    = ((<span class="type">uint32_t</span>)szBuffer[<span class="number">0</span>]) | ((<span class="type">uint32_t</span>)szBuffer[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>) | ((<span class="type">uint32_t</span>)szBuffer[<span class="number">2</span>] &lt;&lt; <span class="number">16</span>) | ((<span class="type">uint32_t</span>)szBuffer[<span class="number">3</span>] &lt;&lt; <span class="number">24</span>);</span><br><span class="line">  sInfoHdr.biWidth  = ((<span class="type">uint32_t</span>)szBuffer[<span class="number">4</span>]) | ((<span class="type">uint32_t</span>)szBuffer[<span class="number">5</span>] &lt;&lt; <span class="number">8</span>) | ((<span class="type">uint32_t</span>)szBuffer[<span class="number">6</span>] &lt;&lt; <span class="number">16</span>) | ((<span class="type">uint32_t</span>)szBuffer[<span class="number">7</span>] &lt;&lt; <span class="number">24</span>);</span><br><span class="line">  sInfoHdr.biHeight  = ((<span class="type">uint32_t</span>)szBuffer[<span class="number">8</span>]) | ((<span class="type">uint32_t</span>)szBuffer[<span class="number">9</span>] &lt;&lt; <span class="number">8</span>) | ((<span class="type">uint32_t</span>)szBuffer[<span class="number">10</span>] &lt;&lt; <span class="number">16</span>) | ((<span class="type">uint32_t</span>)szBuffer[<span class="number">11</span>] &lt;&lt; <span class="number">24</span>);</span><br><span class="line">  sInfoHdr.biPlanes  = ((<span class="type">uint32_t</span>)szBuffer[<span class="number">12</span>]) | ((<span class="type">uint32_t</span>)szBuffer[<span class="number">13</span>] &lt;&lt; <span class="number">8</span>);</span><br><span class="line">  sInfoHdr.biBitCount = ((<span class="type">uint32_t</span>)szBuffer[<span class="number">14</span>]) | ((<span class="type">uint32_t</span>)szBuffer[<span class="number">15</span>] &lt;&lt; <span class="number">8</span>);</span><br><span class="line">  sInfoHdr.biCompression  = ((<span class="type">uint32_t</span>)szBuffer[<span class="number">16</span>]) | ((<span class="type">uint32_t</span>)szBuffer[<span class="number">17</span>] &lt;&lt; <span class="number">8</span>) | ((<span class="type">uint32_t</span>)szBuffer[<span class="number">18</span>] &lt;&lt; <span class="number">16</span>) | ((<span class="type">uint32_t</span>)szBuffer[<span class="number">19</span>] &lt;&lt; <span class="number">24</span>);</span><br><span class="line">  sInfoHdr.biSizeImage  = ((<span class="type">uint32_t</span>)szBuffer[<span class="number">20</span>]) | ((<span class="type">uint32_t</span>)szBuffer[<span class="number">21</span>] &lt;&lt; <span class="number">8</span>) | ((<span class="type">uint32_t</span>)szBuffer[<span class="number">22</span>] &lt;&lt; <span class="number">16</span>) | ((<span class="type">uint32_t</span>)szBuffer[<span class="number">23</span>] &lt;&lt; <span class="number">24</span>);</span><br><span class="line">  sInfoHdr.biXPelsPerMeter= ((<span class="type">uint32_t</span>)szBuffer[<span class="number">24</span>]) | ((<span class="type">uint32_t</span>)szBuffer[<span class="number">25</span>] &lt;&lt; <span class="number">8</span>) | ((<span class="type">uint32_t</span>)szBuffer[<span class="number">26</span>] &lt;&lt; <span class="number">16</span>) | ((<span class="type">uint32_t</span>)szBuffer[<span class="number">27</span>] &lt;&lt; <span class="number">24</span>);</span><br><span class="line">  sInfoHdr.biYPelsPerMeter= ((<span class="type">uint32_t</span>)szBuffer[<span class="number">28</span>]) | ((<span class="type">uint32_t</span>)szBuffer[<span class="number">29</span>] &lt;&lt; <span class="number">8</span>) | ((<span class="type">uint32_t</span>)szBuffer[<span class="number">30</span>] &lt;&lt; <span class="number">16</span>) | ((<span class="type">uint32_t</span>)szBuffer[<span class="number">31</span>] &lt;&lt; <span class="number">24</span>);</span><br><span class="line">  sInfoHdr.biClrUsed    = ((<span class="type">uint32_t</span>)szBuffer[<span class="number">32</span>]) | ((<span class="type">uint32_t</span>)szBuffer[<span class="number">33</span>] &lt;&lt; <span class="number">8</span>) | ((<span class="type">uint32_t</span>)szBuffer[<span class="number">34</span>] &lt;&lt; <span class="number">16</span>) | ((<span class="type">uint32_t</span>)szBuffer[<span class="number">35</span>] &lt;&lt; <span class="number">24</span>);</span><br><span class="line">  sInfoHdr.biClrImportant  = ((<span class="type">uint32_t</span>)szBuffer[<span class="number">36</span>]) | ((<span class="type">uint32_t</span>)szBuffer[<span class="number">37</span>] &lt;&lt; <span class="number">8</span>) | ((<span class="type">uint32_t</span>)szBuffer[<span class="number">38</span>] &lt;&lt; <span class="number">16</span>) | ((<span class="type">uint32_t</span>)szBuffer[<span class="number">39</span>] &lt;&lt; <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//获取图像宽、高、每像素所占位数等信息 </span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="type">int32_t</span> bmp_width  = sInfoHdr.biWidth;</span><br><span class="line">  <span class="type">int32_t</span> bmp_height = sInfoHdr.biHeight;</span><br><span class="line">  PXL_FORMAT bmp_pxl_format = PXL_FORMAT_NONE;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">8</span> == sInfoHdr.biBitCount)</span><br><span class="line">  &#123;</span><br><span class="line">    bmp_pxl_format = PXL_FORMAT_8BIT_GRAY;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">24</span> == sInfoHdr.biBitCount)</span><br><span class="line">  &#123;</span><br><span class="line">    bmp_pxl_format = PXL_FORMAT_24BIT_BGR;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">32</span> == sInfoHdr.biBitCount)</span><br><span class="line">  &#123;</span><br><span class="line">    bmp_pxl_format = PXL_FORMAT_32BIT_BGRA;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    XOS_ERROR(TAG_IMGENG, <span class="string">&quot;&lt;XImage.LoadFromBmp&gt; unknown pixel format, biBitCount=%d, file=%s&quot;</span>,</span><br><span class="line">              sInfoHdr.biBitCount, bmp_file_path);</span><br><span class="line">    fclose(file_handler);</span><br><span class="line">    <span class="keyword">return</span> XERR_UNSUPPORTED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">8</span> == sInfoHdr.biBitCount)  <span class="comment">// 灰度图像有颜色表，且颜色表表项为256色</span></span><br><span class="line">  &#123;</span><br><span class="line">    XOS_ERROR(TAG_IMGENG, <span class="string">&quot;&lt;XImage.LoadFromBmp&gt; not support color 8bit, file=%s&quot;</span>, bmp_file_path);</span><br><span class="line">    fclose(file_handler);</span><br><span class="line">    <span class="keyword">return</span> XERR_UNSUPPORTED;  <span class="comment">// 目前不支持</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分配内存空间</span></span><br><span class="line">  Allocate(bmp_pxl_format, bmp_width, bmp_height);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 逐行读取像素数据, 注意: .bmp文件中像素数据时先存放最后一行,然后逐步到第一行, 是反向的</span></span><br><span class="line">  <span class="type">uint8_t</span>* pixel_line = (<span class="type">uint8_t</span>*)(image_data_ + (height_ - <span class="number">1</span>) * line_bytes_);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int32_t</span> i = <span class="number">0</span>; i &lt; height_; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    fread(pixel_line, <span class="number">1</span>, line_bytes_, file_handler);</span><br><span class="line">    pixel_line -= line_bytes_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fclose(file_handler);</span><br><span class="line">  <span class="keyword">return</span> XOK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">XImage::SaveToBmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* save_bmp_file)</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE* file_handler = fopen(save_bmp_file, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (file_handler == nullptr)</span><br><span class="line">  &#123;</span><br><span class="line">    XOS_ERROR(TAG_IMGENG, <span class="string">&quot;&lt;XImage.SaveToBmp&gt; fail to fopen(), file=%s&quot;</span>, save_bmp_file);</span><br><span class="line">    <span class="keyword">return</span> XERR_FILE_OPEN;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// YUV图像数据直接保存原始数据</span></span><br><span class="line">  <span class="keyword">if</span> (pxl_format_ &amp; PXL_FORMAT_TYPE_YUV)</span><br><span class="line">  &#123;</span><br><span class="line">    fwrite(image_data_, <span class="number">1</span>, image_bytes_, file_handler);</span><br><span class="line">    fclose(file_handler);</span><br><span class="line">    <span class="keyword">return</span> XOK;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写入文件头信息</span></span><br><span class="line">  <span class="type">int32_t</span>  bit_count  = pixel_bytes_ * <span class="number">8</span>;</span><br><span class="line">  <span class="type">uint16_t</span> temp_16bit = <span class="number">0x4D42</span>;</span><br><span class="line">  <span class="type">uint32_t</span> temp_32bit = static_cast&lt;<span class="type">uint32_t</span>&gt;(<span class="number">54</span> + line_bytes_ * height_);</span><br><span class="line">  <span class="keyword">if</span> (bit_count == <span class="number">8</span>)</span><br><span class="line">    temp_32bit += XBMP_RGBQUAD_LEN * <span class="number">256</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (bit_count == <span class="number">16</span>)</span><br><span class="line">    temp_32bit += <span class="number">16</span>;</span><br><span class="line">  fwrite(&amp;temp_16bit, <span class="number">1</span>, <span class="number">2</span>, file_handler);</span><br><span class="line">  fwrite(&amp;temp_32bit, <span class="number">1</span>, <span class="number">4</span>, file_handler);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写入bitmap信息</span></span><br><span class="line">  temp_16bit = <span class="number">0</span>;</span><br><span class="line">  temp_32bit = <span class="number">54</span>;</span><br><span class="line">  <span class="keyword">if</span> (bit_count == <span class="number">8</span>)</span><br><span class="line">    temp_32bit += XBMP_RGBQUAD_LEN * <span class="number">256</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (bit_count == <span class="number">16</span>)</span><br><span class="line">    temp_32bit += <span class="number">16</span>;</span><br><span class="line">  fwrite(&amp;temp_16bit, <span class="number">1</span>, <span class="number">2</span>, file_handler);</span><br><span class="line">  fwrite(&amp;temp_16bit, <span class="number">1</span>, <span class="number">2</span>, file_handler);</span><br><span class="line">  fwrite(&amp;temp_32bit, <span class="number">1</span>, <span class="number">4</span>, file_handler);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">8</span> == bit_count)</span><br><span class="line">  &#123;</span><br><span class="line">    XBMPINFO_HEADER bi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    bi.biSize = <span class="number">40</span>;</span><br><span class="line">    bi.biWidth = width_;</span><br><span class="line">    bi.biHeight = height_;</span><br><span class="line">    bi.biBitCount = (<span class="type">uint16_t</span>)bit_count;</span><br><span class="line">    bi.biPlanes = <span class="number">1</span>;</span><br><span class="line">    fwrite(&amp;bi, <span class="number">1</span>, XBMP_INFOHDR_LEN, file_handler);</span><br><span class="line"></span><br><span class="line">    XBMP_RGBQUAD rgb[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      rgb[i].rgbBlue = (XBYTE)i;</span><br><span class="line">      rgb[i].rgbGreen = (XBYTE)i;</span><br><span class="line">      rgb[i].rgbRed = (XBYTE)i;</span><br><span class="line">      rgb[i].rgbReserved = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fwrite(rgb, <span class="number">1</span>, XBMP_RGBQUAD_LEN * <span class="number">256</span>, file_handler);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">uint32_t</span>    biSize = <span class="number">40</span>;</span><br><span class="line">    <span class="type">int32_t</span>      biWidth = width_;</span><br><span class="line">    <span class="type">int32_t</span>      biHeight = height_;</span><br><span class="line">    <span class="type">uint16_t</span>    biPlanes = <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint16_t</span>    biBitCount = bit_count;</span><br><span class="line">    <span class="type">uint32_t</span>    biCompression = (bit_count == <span class="number">16</span>) ? <span class="number">3</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span>    biSizeImage = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int32_t</span>      biXPelsPerMeter = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int32_t</span>      biYPelsPerMeter = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span>    biClrUsed = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span>    biClrImportant = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    fwrite(&amp;biSize, <span class="number">1</span>, <span class="number">4</span>, file_handler);</span><br><span class="line">    fwrite(&amp;biWidth, <span class="number">1</span>, <span class="number">4</span>, file_handler);</span><br><span class="line">    fwrite(&amp;biHeight, <span class="number">1</span>, <span class="number">4</span>, file_handler);</span><br><span class="line">    fwrite(&amp;biPlanes, <span class="number">1</span>, <span class="number">2</span>, file_handler);</span><br><span class="line">    fwrite(&amp;biBitCount, <span class="number">1</span>, <span class="number">2</span>, file_handler);</span><br><span class="line">    fwrite(&amp;biCompression, <span class="number">1</span>, <span class="number">4</span>, file_handler);</span><br><span class="line">    fwrite(&amp;biSizeImage, <span class="number">1</span>, <span class="number">4</span>, file_handler);</span><br><span class="line">    fwrite(&amp;biXPelsPerMeter, <span class="number">1</span>, <span class="number">4</span>, file_handler);</span><br><span class="line">    fwrite(&amp;biYPelsPerMeter, <span class="number">1</span>, <span class="number">4</span>, file_handler);</span><br><span class="line">    fwrite(&amp;biClrUsed, <span class="number">1</span>, <span class="number">4</span>, file_handler);</span><br><span class="line">    fwrite(&amp;biClrImportant, <span class="number">1</span>, <span class="number">4</span>, file_handler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bit_count == <span class="number">16</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">uint32_t</span> mask[<span class="number">16</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">      mask[<span class="number">0</span>] = <span class="number">0xF800</span>;</span><br><span class="line">      mask[<span class="number">1</span>] = <span class="number">0x7E0</span>;</span><br><span class="line">      mask[<span class="number">2</span>] = <span class="number">0x1F</span>;</span><br><span class="line">      mask[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">      fwrite(mask, <span class="number">1</span>, <span class="number">16</span>, file_handler);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span>* pixel_line = image_data_ + (height_ - <span class="number">1</span>) * line_bytes_;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int32_t</span> i = <span class="number">0</span>; i &lt; height_; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    fwrite(pixel_line, <span class="number">1</span>, line_bytes_, file_handler);</span><br><span class="line">    pixel_line -= line_bytes_;</span><br><span class="line">  &#125;</span><br><span class="line">  fclose(file_handler);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> XOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>线性系统分析(信号与系统)</title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%EF%BC%88%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%EF%BC%89/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90(%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F)/</url>
    <content><![CDATA[<p><a href="%E7%B3%BB%E7%BB%9F%E8%BE%93%E5%85%A5%E4%BF%A1%E5%8F%B7/%E7%B3%BB%E7%BB%9F%E8%BE%93%E5%85%A5%E4%BF%A1%E5%8F%B7.md" title="系统输入信号">系统输入信号</a></p>
<p><a href="%E7%BA%BF%E6%80%A7%E6%97%B6%E4%B8%8D%E5%8F%98%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E6%80%A7%E6%97%B6%E4%B8%8D%E5%8F%98%E7%B3%BB%E7%BB%9F.md" title="线性时不变系统">线性时不变系统</a></p>
<h1 id="系统性质"><a href="#系统性质" class="headerlink" title="系统性质"></a>系统性质</h1><p>1）连续&#x2F;离散时间系统：<br>连续时间输入得到连续时间输出$x(t)\to y(t)$<br>离散时间输入得到离散时间输出$x[n]\to y[n]$</p>
<p><img src="/image/image_iPmEzHcBtN.png"></p>
<p>2)系统间的关系:<br>1.（串）级联<br>2.并联<br>3.互联（串并联）<br>4.反馈互联：反馈实则体现一种记忆性</p>
<p><img src="/image/image_NU38kNHKgB.png"></p>
<p><img src="/image/image_lbXUKHGrr5.png"></p>
<p><img src="/image/image_ATIZ_FIvzU.png"></p>
<p>反馈环节：<br>1）当前时刻输出取决于上一时刻输出或当前时刻的变化率；体现一种记忆性<br>2）噪声反馈可以改成积分器形式</p>
<p><img src="/image/image_Ci4hZ9uaDQ.png"></p>
<p><img src="/image/image_2_lmqIQV3L.png"></p>
<p><img src="/image/image_LSorOT3NuY.png"></p>
<p><img src="/image/image_XXrUwIwlpg.png"></p>
<p><img src="/image/image_f7khiOCt9e.png"></p>
<p>3）记忆性：系统输出是否只取决于该时刻输入<br>记忆性系统（需要记忆过往的信息）：y(t)&#x3D;x(t-k)；比如$y[n]&#x3D;\sum_{k&#x3D;-\infty}^{n}x[k]&#x3D;y[n-1]+x[n]$需要存储所有过往的输入或上一个输出<br>无记忆系统（只取决于该时刻输入）：$y(t)&#x3D;K\cdot x(t)$<br>4)可逆性：若系统可逆则必存在一个逆系统；x→y是一个双射</p>
<p><img src="/image/image_Sqo0TbABi2.png"></p>
<p>应用：加密传输算法必须保证可逆<br>4）因果性：系统任何时刻输出都是由现在和过去的的输入决定的<br>后验系统：y[n]&#x3D;x[n]-x[n+1]；可由果溯因<br>5）稳定性：对于系统$y(t)&#x3D;f(x(t))$;有界输入有界输出，则稳定；反之有界输入，输出无界则不稳定<br>6）时不变性：$y(t)&#x3D;f(x(t))$；若输入产生时移$t-t_0;则其输出也产生时移y(t-t_0)$<br>7)线性：若输入是一个线性组合$ x[n]&#x3D;\sum_{k}a_{k}x_{k}[n]&#x3D;a_{1}x_{1}[n]+a_{2}x_{2}[n]+a_{3}x_{3}[n]+\cdots<br> $；<br>那么输出是输入各分量的响应的线性组合$ y[n]&#x3D;\sum_{k}a_{k}y_{k}[n]&#x3D;a_{1}y_{1}[n]+a_{2}y_{2}[n]+a_{3}y_{3}[n]+\cdots  $</p>
<p><a href="%E6%96%B0%E9%A1%B5%E9%9D%A2/%E6%96%B0%E9%A1%B5%E9%9D%A2.md" title="新页面">新页面</a></p>
<p><a href="%E6%96%B0%E9%A1%B5%E9%9D%A2_1/%E6%96%B0%E9%A1%B5%E9%9D%A2.md" title="新页面">新页面</a></p>
<p><a href="%E6%96%B0%E9%A1%B5%E9%9D%A2_2/%E6%96%B0%E9%A1%B5%E9%9D%A2.md" title="新页面">新页面</a></p>
<p><a href="%E6%96%B0%E9%A1%B5%E9%9D%A2_3/%E6%96%B0%E9%A1%B5%E9%9D%A2.md" title="新页面">新页面</a></p>
<p><a href="%E6%96%B0%E9%A1%B5%E9%9D%A2_4/%E6%96%B0%E9%A1%B5%E9%9D%A2.md" title="新页面">新页面</a></p>
<p><a href="%E6%96%B0%E9%A1%B5%E9%9D%A2_5/%E6%96%B0%E9%A1%B5%E9%9D%A2.md" title="新页面">新页面</a></p>
<p><a href="%E6%96%B0%E9%A1%B5%E9%9D%A2_6/%E6%96%B0%E9%A1%B5%E9%9D%A2.md" title="新页面">新页面</a></p>
<p><a href="%E6%96%B0%E9%A1%B5%E9%9D%A2_7/%E6%96%B0%E9%A1%B5%E9%9D%A2.md" title="新页面">新页面</a></p>
<p><a href="%E6%96%B0%E9%A1%B5%E9%9D%A2_8/%E6%96%B0%E9%A1%B5%E9%9D%A2.md" title="新页面">新页面</a></p>
<p><a href="%E6%96%B0%E9%A1%B5%E9%9D%A2_9/%E6%96%B0%E9%A1%B5%E9%9D%A2.md" title="新页面">新页面</a></p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>像素间的关系</title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%83%8F%E7%B4%A0%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/%E5%83%8F%E7%B4%A0%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h1 id="相邻像素（相邻性）"><a href="#相邻像素（相邻性）" class="headerlink" title="相邻像素（相邻性）"></a>相邻像素（相邻性）</h1><p><img src="/image/image_hpxr4LbDph.png"></p>
<p>像素p(x,y)的4邻域$N_4(p)$&#x3D;{$(x+1,y);(x-1,y);(x,y+1);(x,y-1)$}</p>
<p><img src="/image/image_Q7D2fzKXgy.png"></p>
<p>像素p(x,y)的D邻域$N_d(p)$&#x3D;{$(x+1，y+1);(x+1,y-1);(x-1,y+1);(x-1,y-1)$}</p>
<p><img src="/image/image_CfNzLqxHHI.png"></p>
<p>像素p(x,y)的8邻域$N_8(p)$&#x3D;$N_d(p)$+$N_4(p)$；是4邻域的点+D邻域的点</p>
<h1 id="连通像素（连通性）"><a href="#连通像素（连通性）" class="headerlink" title="连通像素（连通性）"></a>连通像素（连通性）</h1><p>具有相同灰度值的两个像素点p和q，如果 $ q \subset N_4(p)  $则两点4连通</p>
<p><img src="/image/image_LyC27LLnL7.png"></p>
<p>同理8连通</p>
<p><img src="/image/image_cXtIB-iLu4.png"></p>
<p>相同值的像素p和q，满足如下条件之一则为m连通；表示即4连通和D连通的混合连通</p>
<p>1)$ q \subset N_4(p)  $<br>2)$ q \subset N_d(p)  $且$N_4(p) \cap N_d(p) &#x3D; \phi$</p>
<p>通路的定义：像素p：(x,y)到像素q：(s,t)的通路，是不同像素的序列$(x0,y0),(x1,y1),…,(xn,yn)$<br>其中，$(x0,y0)&#x3D;(x,y),(xn,yn)&#x3D;(s,t)$,$(xi,yi)和(xi−1,yi−1)$是邻接的，$1≤i≤n，n$是路径的长度。<br>如果$(x0,y0)&#x3D;(xn,yn)$,则该通路是闭合通路。</p>
<p>连通性在后续用于图像分割的时候比较有用，通常在检测到图像中一个对象后，将对象边缘提取出来，需要用到连通性的处理</p>
<h1 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h1><p>距离或测度必须满足三个条件： &#x20;<br>$ 1.D(p,q)≥0（D(p,q)&#x3D;0,当且仅当p&#x3D;q）   $$ 2.D(p,q)&#x3D;D(q,p)   $$ 3.D(p,z)≤D(p,q)+D(q,z)   $<br>则称D是距离函数或度量</p>
<p>设像素$（x,y）;（s,t）$</p>
<p><strong>1、欧式距离</strong>：就是2D平面上的距离$D_e(p,q) &#x3D; \sqrt{(x-s)^2+(y-t)^2}$</p>
<p><strong>2、D4距离(直角距离):</strong>  实际开发过程中，欧式距离计算比较复杂，简化成D4距离可以大大简化计算量<br>$D_4(p,q) &#x3D; \left| x-s \right| +  \left|y-t\right|$</p>
<p><img src="/image/image_iLzXBxQlQs.png"></p>
<p><strong>3、D8距离</strong>: 在X和Y两个方向上只取距离最长的一个坐标差$D_8(p,q) &#x3D;max( \left| x-s \right| ,  \left|y-t\right|)$</p>
<p><img src="/image/image_7UKS0YgfJB.png"></p>
]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>概率</title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87/%E6%A6%82%E7%8E%87/</url>
    <content><![CDATA[<h1 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h1><p><a href="%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88.md" title="排列组合">排列组合</a></p>
<h1 id="对随机的描述"><a href="#对随机的描述" class="headerlink" title="对随机的描述"></a>对随机的描述</h1><p><strong>随机现象：</strong>发生前不能预先推论得到结果；发生后，得到可能结果之一;<br><strong>随机试验</strong>:<br>(1) 可在<strong>相同条件下重复</strong>进行;<br>(2) <strong>结果不止一个</strong>,且所有可能事先已知;（<strong>随机变量&#x2F;随机事件事先已知</strong>）<br>(3) 一次试验出现一个结果，且<strong>试验前不能确定会出现哪个结果。（每次试验结果都是随机现象</strong>）<br><strong>（对于黑箱系统，每次输入都是1次随机试验）</strong>；</p>
<p><strong>概率系统</strong>：随机事件映射到实数子集[0,1]<br>场域：概率空间的<strong>结构</strong>由三元组的三个参数决定 (Ω,F,P)<br>（1） Ω <strong>样本空间</strong>，随机试验结果（基本事件&#x2F;样本点）所构成集合；其可能1）有限的&#x2F;无穷的2）可列的&#x2F;不可列<br>（2）F <strong>事件域</strong>，事件的集合，<strong>事件</strong>是样本空间Ω的子集<br>（3） P 原始<strong>概率函数</strong>，该函数 P:F→[0,1] 将事件空间中每个事件映射到实数子集[0,1]</p>
<p><a href="%E9%9B%86%E5%90%88%E8%AE%BA%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E7%9A%84%E9%9A%8F%E6%9C%BA%E7%8E%B0%E8%B1%A1/%E9%9B%86%E5%90%88%E8%AE%BA%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E7%9A%84%E9%9A%8F%E6%9C%BA%E7%8E%B0%E8%B1%A1.md" title="集合论语言描述的随机现象">集合论语言描述的随机现象</a></p>
<h1 id="概率第一性描述"><a href="#概率第一性描述" class="headerlink" title="概率第一性描述"></a>概率第一性描述</h1><p><strong>概率的自然语言描述：随机试验结果（随机事件）对应的可能性</strong></p>
<p>概率函数<strong>频率定义</strong>：<strong>频率稳定值（频率极限）****n次独立试验</strong>下(相同条件重复n次随机试验 **)<strong>；E为 Ω 中随机事件；n(E)为E事件发生次数；则</strong>比值n(E)&#x2F;n为事件E发生的频率,记为Fn(E)**<br>**公设：<br>1)频率波动性：**对于同一个试验, 不同的试验序列其频率不同;<br><strong>2）频率稳定性：当n足够大时，事件E的频率n(E)&#x2F;n在稳定值P(E)邻域内摆动且逐渐稳定</strong></p>
<p><img src="/image/image_PmbwbdLniC.png"></p>
<p>适用于：<br>1）概率分布函数的<strong>模型和</strong>参数是<strong>确定的</strong>；其<strong>输出不确定性源于系统误差与偶然测量误差</strong><br>2）<strong>可反复试验</strong>3）<strong>试验次数n足够大</strong>4）每次试验不会影响下次试验，系统始终一样</p>
<p>概率函数贝叶斯定义：</p>
<p>归纳出的概率函数<strong>公理</strong>化定义：<br>从样本集 Ω 到 R 的子集 [0,1] 的一个满足可数可加性的映射<br>1)非负性2）规范性3）互斥事件可列可加性</p>
<p><img src="/image/image_JzbOiz32x1.png"></p>
<p>这几条公理统一已有概率定义；通过公理化定义为起点推导出尽可能多的命题;（好吧，第一性定义大多来源于合理假设+后验修正+归纳各种假设形成统一的公理性定义）</p>
<p>公理演绎的基本推论：籍着互斥事件的可列可加性</p>
<p><img src="/image/image_BJWEXKAS1D.png"></p>
<p><img src="/image/image_wzXXWELrdk.png"></p>
<p>非互斥并集概率的性质：</p>
<p><img src="/image/image_8da0SBqflM.png"></p>
<p><img src="/image/image_bH57jBjTKd.png"></p>
<h1 id="条件概率及其基本推论"><a href="#条件概率及其基本推论" class="headerlink" title="条件概率及其基本推论"></a>条件概率及其基本推论</h1><p>.<strong>条件概率：</strong> 设试验E的样本空间为Ω, A, B是事件,则在B发生条件下A发生的概率, 称条件概率P(A|B)；</p>
<p><strong>如此样本空间从全空间</strong>Ω<strong>缩小到B；事件A包含的样本点从A缩小到（A∩B）；P(A|B)的概率空间（B,F,P(AB)&#x2F;P(B)）</strong></p>
<p>A的条件概率与A的全空间概率关系：<br>设（Ω,F,P）；事件A,B∈事件域F；且P（B）&gt;0;则P（A|B）&#x3D;P(AB)&#x2F;P(B)<br>即<strong>AB在B样本中的概率&#x3D;AB在Ω样本中的概率&#x2F;B在Ω样本中的概率</strong>；</p>
<p><img src="/image/image_utvnkbV28u.png"></p>
<p>条件概率<strong>满足概率公理</strong>；足以作为一个<strong>论证起点</strong></p>
<p><img src="/image/image_NoqzV29nu7.png"></p>
<p>**⇒乘法定理(交集概率)**：P(AB)&#x3D;P(A|B)P(B)  前提P(B)&gt;0</p>
<p><img src="/image/image_PpHrC8o8s6.png"></p>
<p><strong>⇒全概率公式</strong>:<strong>由因推果，已知A事件在各原因&#x2F;前提Ci下发生，由Ci导致A发生的条件概率P(A|Ci)以及因素本身的概率，推断A事件发生的概率</strong>（<strong>互斥因素Ci</strong>的 概率分布和Ci<strong>所导致结果A|Ci的条件分布⇒结果A概率</strong>)</p>
<p><img src="/image/image_n6jkQHvRSw.png"></p>
<p><img src="/image/image_7l9BQXsZ9d.png"></p>
<p><img src="/image/image_X3klBAdXsS.png"></p>
<p><strong>⇒Bayes公式</strong>：<strong>由果溯因，已知A事件在各原因&#x2F;前提Ci下发生，由结果概率P(A)，各因素Bi导致A发生的条件概率P(A|Bi)及Bi本身概率，推断结果A发生是由Bi导致的概率P（Bi|A）</strong>（即先验⇒后验；<strong>由以往观测结果{互斥因素bi分布P(bi),P(A),条件分布P(A|Bi)}⇒是由各因素导致的概率）</strong></p>
<p><img src="/image/image_Iihsk_Y5Ew.png"></p>
<p><img src="/image/image_y28yYzLtqF.png"></p>
<p><img src="/image/image_9IO4thJNga.png"></p>
<h1 id="独立事件"><a href="#独立事件" class="headerlink" title="独立事件"></a>独立事件</h1><p>设A为第一次取得红，B第二次取得红；（A,B）为n次试验取得双红事件</p>
<p><img src="/image/image_x6S58biDVs.png"></p>
<p><strong>独立事件：A的概率&#x3D;A在B条件下的概率；则A,B相互独立（</strong>俗称为B发生不影响A发生的概率,比如有放回的n次试验是独立的，每次试验各事件的概率分布不变<strong>）<br>定义</strong>：若有<strong>P(A)P(B)&#x3D;P(AB)****&lt;&#x3D;&gt;P(A)</strong>&#x3D;P(AB)&#x2F;P(B)<strong>&#x3D;P(A|B)&#x20;<br>&lt;&#x3D;&gt;P(B)</strong>&#x3D;P(AB)&#x2F;P(B)&#x3D;<strong>P(B|A)*<em><strong>则称A，B互为独立事件，即A</strong>在Ω样本中的</em>*概率</strong>&#x3D;<strong>AB在B</strong>样本空间中的概率;<br>基本上样本空间的事件可以一层层叠上去的就是互相独立的：</p>
<p><img src="/image/image__BQRdFuwVl.png"></p>
<p><img src="/image/image_LXgsxBfK6J.png"></p>
<p><img src="/image/image_XH7nfrP1RO.png"></p>
<p>n阶推广：<strong>A1A2独立时；有P(A1A2)&#x3D;P(A1)P(A2)</strong><br>⇒{A1…An}两两独立时，任意部分都是相互独立的：设k∈Z,(<strong>1&lt;k≤n</strong>)，使得<strong>任意的k个Ajk的排列</strong>都满足</p>
<p><img src="/image/image_JMxb5ZaDKg.png"></p>
<p><img src="/image/image_A6Q74vdQ5r.png"></p>
<h1 id="随机变量-基本事件编号"><a href="#随机变量-基本事件编号" class="headerlink" title="随机变量(基本事件编号)"></a>随机变量(基本<strong>事件编号</strong>)</h1><p><img src="/image/image_aKDOY5hdwJ.png"></p>
<p><strong>随机试验结果到实数子集的映射</strong>（映射无非研究定义域&#x2F;映射规则&#x2F;值域）；<br>**定义域（<strong>样本空间Ω</strong>）：**1)有限&#x2F;无穷   2）可列&#x2F;不可列   3）怎么数<br><strong>映射规则</strong>：你说了算，ex：设晴天&#x3D;0，雨天&#x3D;1，多云&#x3D;2<br><strong>值域（</strong>实数子集<strong>）</strong>：<br>1）映射到某区间内有限&#x2F;可列个数：离散型随机变量<br>2）映射到某区间内无穷&#x2F;不可列个数：连续型</p>
<h1 id="概率分布"><a href="#概率分布" class="headerlink" title="概率分布"></a>概率分布</h1><p>离散分布的随机变量</p>
<p><strong>（样本点概率）PMF质量函数:  即随机变量X&#x3D;xk时的分布律函数</strong></p>
<p>$$<br>P(X&#x3D;x_{k})&#x3D;p(x_{k})<br>$$</p>
<p><strong>（随机事件概率）CDF累积分布函数：(-∞,b]上随机变量的概率求和</strong></p>
<p>$$<br>P(-∞＜X\leq b)&#x3D;F( b) \overset{def}{&#x3D;}\sum_{-∞}^{b} p(x_{k})</p>
<p>$$</p>
<p>$$<br>P(a＜X\leq b)&#x3D;P((-∞,b]- (-∞,a])&#x3D;F(b)-F(a) \overset{def}{&#x3D;}\sum_{-∞}^{b} p(x_{k})-\sum_{-∞}^{a} p(x_{k})<br>$$</p>
<p>连续随机变量</p>
<p><strong>（随机事件概率）CDF分布函数：(-∞,b]上随机变量的概率积分</strong></p>
<p>$$<br>P(-∞＜X\leq b)&#x3D;F( b) \overset{def}{&#x3D;}\sum_{x&#x3D;-∞}^{b} p(x)&#x3D;\lim_{\bigtriangleup x \to 0} \sum_{x&#x3D;-∞}^{b} f(x_{})\bigtriangleup x&#x3D;\int\limits_{}^{b}f(x)dx<br>$$</p>
<p>$$<br>P(a＜X\leq b)&#x3D;P((-∞,b]- (-∞,a])&#x3D;F(b)-F(a) \overset{def}{&#x3D;}\sum_{-∞}^{b} p(x_{k})-\sum_{-∞}^{a} p(x_{k})&#x3D;\int\limits_{a}^{b}f(x)dx<br>$$</p>
<p><strong>（样本点概率）由PDF密度函数刻画:  即随机变量X&#x3D;xk时</strong>f(xk)；有累积分布差分取极限定义</p>
<p>$$<br>由所积微分（点的概率）p(x)&#x3D;\lim_{\bigtriangleup x \to 0} F(xi+\bigtriangleup x)-F(xi)&#x3D;\lim_{\bigtriangleup x \to 0}f(x)\bigtriangleup x<br>$$</p>
<p>$$<br>&#x3D;&gt;f(x)&#x3D;\lim_{\Delta x \to 0} \frac{P(x\le X\le x+\Delta x )}{\Delta x}&#x3D; \lim\limits_{\Delta x \to 0^+} \frac{F(x + \Delta x) - F(x)} {\Delta x}&#x3D;F’(x);概率密度恰好是CDF的导数<br>$$</p>
<p><strong>对于连续区间对应的值；由于有无穷个点；<br>1）无穷个值（即使很小）求和等于无穷，与总面积是一个常数矛盾；<br>2）总面积是一个常数；那么单个点的值不就应该是无穷小吗，与单个点的值是常数矛盾<br>所以，连续区间上的无穷求和以及单点的值的原始定义肯定有问题；事实上，和式F(x)&#x3D;∑y(xi)是有界的，其值在极限值（稳定值）的邻域内摆动并逐渐稳定，如此定义积分；自然地xi处所积微分f(xi)&#x2F;n(即单点的值y(xi));y(xi)&#x3D;F(xi+1&#x2F;n)-F(xi);可定义一个积分的逆运算F’(xi)&#x3D;f(xi);由y(xi)&#x3D;F(xi+1&#x2F;n)-F(xi)&#x3D;f(xi)&#x2F;n⇒F’(xi)&#x3D;f(xi)&#x3D;F(xi+1&#x2F;n)-F(xi)&#x2F;1&#x2F;n称为导数</strong></p>
<p>不懂的性质：</p>
<p><img src="/image/image_4I4TKsOmBu.png"></p>
<p><a href="%E5%B8%B8%E8%A7%81%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/%E5%B8%B8%E8%A7%81%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83.md" title="常见概率分布">常见概率分布</a></p>
<p><strong>随机变量的函数的分布</strong>:已知随机变量X的分布,求Y&#x3D;g(X)的分布<br>离散随机变量：<br>ex:</p>
<p><img src="/image/image_od5uPQGK2s.png"></p>
<p><img src="/image/image_0CDLqxtQw7.png"></p>
<p>显然由下两行可治理出Y的PMF:</p>
<p><img src="/image/image_zZZpFMSjZK.png"></p>
<p>离散随机变量：</p>
<p><img src="/image/image_1lmcwezfxu.png"></p>
<p><strong>多维随机变量</strong>:基本事件的概率与多类随机变量要素相关（ex:合格率取决于加工精度X和光滑度Y）<br>Def:随机事件的样本点$\omega$拥有多个随机分量要素$X_i(\omega)$;形成多维随机变量$X(\omega)&#x3D;(X_1(\omega),……,X_n(\omega))记为X&#x3D;(X_1,……,X_n)$<br>联合分布函数：$F(\mathrm{x},\mathrm{y})&#x3D;P{(X\leq\mathrm{x})\cap(Y\leq\mathrm{y})}\overset{\Delta}{\operatorname*{&#x3D;}}P{X\leq\mathrm{x},Y\leq\mathrm{y}}$$\begin{aligned}<br>&amp;\begin{aligned}P{\mathrm{x}_1&lt;X\leq\mathrm{x}_2;\mathrm{y}_1&lt;Y\leq\mathrm{y}_2}\end{aligned}<br>&amp;\begin{aligned}&amp;&#x3D;F(\mathrm{x}_2,\mathrm{y}_2)-F(\mathrm{x}_1,\mathrm{y}_2)-F(\mathrm{x}_2,\mathrm{y}_1)+F(\mathrm{x}_1,\mathrm{y}_1)\end{aligned}<br>\end{aligned}$</p>
<p><img src="/image/image_GjWBmAKWdX.png"></p>
<p>此块区域上累积分布概率</p>
<p><img src="/image/image_m4_dxfqVjY.png"></p>
<p>二维离散随机变量的联合分布律（样本点概率）$p_{ij}$形如：</p>
<p><img src="/image/image_HzAE0K5j2M.png"></p>
<p>二维连续随机变量的联合概率密度：<br>$F(\mathrm{x},\mathrm{y})&#x3D;\int_{-\infty}^\mathrm{y}\int_{-\infty}^\mathrm{x}\mathrm{f(u},\mathrm{v})\mathrm{du}\mathrm{dv}$⇒$f(x,y)&#x3D;\frac{\partial^2\mathbf{F(x,y)}}{\partial\mathbf{x\partial y}}$</p>
<p>二维随机变量的边缘分布函数：<br>$\begin{aligned}<br>F_X(\mathrm{x})&amp; &#x3D;P{X\leq\mathrm{x}}<br>&amp;&#x3D;P{X\leq\mathrm{x},Y&lt;+\infty}&#x3D;F(\mathrm{x},+\infty)<br>\end{aligned}$$\begin{aligned}<br>F_{Y}(y)&amp; &#x3D;P\left(Y\leq y\right)<br>&amp;&#x3D;P\big(X&lt;+\infty,Y\leq y\big)<br>&amp;&#x3D;F(+\infty,y)<br>\end{aligned}$</p>
<p><img src="/image/image_dcHof-P_DZ.png"></p>
<p><img src="/image/image_xHNGEL6qb7.png"></p>
<p>二维离散随机变量的边缘分布列：<br>$\begin{aligned}<br>P(X&#x3D;x_i)&amp; \begin{aligned}&#x3D;P(X&#x3D;x_i,Y&lt;+\infty)\end{aligned}<br>&amp;\begin{aligned}&amp;&#x3D;P(X&#x3D;x_i,Y&#x3D;y_1)+P(X&#x3D;x_i,Y&#x3D;y_2)+\cdots\end{aligned}<br>&amp;&#x3D;\sum_jp_{ij}<br>\end{aligned}$<br>二维连续随机变量的边缘概率密度：<br>$F_X(x)&#x3D;F(x,+\infty)&#x3D;\int_{-\infty}^{x}[\int_{-\infty}^{+\infty}\mathrm{f(x,y)dy]dx}$⇒$\int_{-\infty}^{+\infty} f(x,y)dy&#x3D;\frac{\partial\mathbf{F(x,y)}}{\partial\mathbf{x}}$$;(x,y)∈G$且连续</p>
<h1 id="随机变量数字特征"><a href="#随机变量数字特征" class="headerlink" title="随机变量数字特征"></a>随机变量数字特征</h1><p>衡量多个数据的平均水平<br>1）衡量单个数据的平均水平：算术平均（按数据出现次数平均数据总和）<br>2）衡量总体的平均水平：加权平均（$\sum$频率*数据）</p>
<h4 id="期望：-xA-xA-1）随机变量的加权平均（概率作为“权数”，表征数据重要程度）-xA-2）加权和相等的一致分布样本的随机变量取值（随机变量取值相同的一致分布，将其随机变量取值作为“随机试验能得到某个一致可能”的预期，常用于衡量收益）"><a href="#期望：-xA-xA-1）随机变量的加权平均（概率作为“权数”，表征数据重要程度）-xA-2）加权和相等的一致分布样本的随机变量取值（随机变量取值相同的一致分布，将其随机变量取值作为“随机试验能得到某个一致可能”的预期，常用于衡量收益）" class="headerlink" title="期望：&#xA;&#xA;1）随机变量的加权平均（概率作为“权数”，表征数据重要程度）&#xA;2）加权和相等的一致分布样本的随机变量取值（随机变量取值相同的一致分布，将其随机变量取值作为“随机试验能得到某个一致可能”的预期，常用于衡量收益）"></a><strong>期望：</strong>&#xA;&#xA;1）随机变量的加权平均（概率作为“权数”，表征数据重要程度）&#xA;2）<strong>加权和相等的一致分布样本的随机变量取值</strong>（随机变量取值相同的一致分布，<strong>将其随机变量取值作为“随机试验能得到某个一致可能”的预期</strong>，常用于衡量收益）</h4><p>离散随机变量X：<br>随机变量X的样本分布律为P{X&#x3D;xi}&#x3D;pi；<br><strong>找一随机变量</strong>E(X)<strong>取值一致的离散一致分布样本</strong>；<br>两者加权累加式相等（要求累加式绝对收敛）：</p>
<p>$$<br>E(X)&#x3D;\sum_{i&#x3D;1}^{n}  x_{i} p_{i}&#x3D;\frac{E(X)}{n} \cdot n</p>
<p>$$</p>
<p>连续随机变量</p>
<p>$$<br>\lim_{n \to \infty} \frac{\color{Red}E(X)}{n} \cdot n&#x3D;\sum_{-\infty}^{+\infty}x_{i}P(x_{i})&#x3D;\lim_{\Delta x  \to 0}\sum_{-\infty}^{+\infty}x_{i}P(x_{i}+\Delta x)&#x3D;\lim_{\Delta x  \to 0}\sum_{-\infty}^{+\infty}  x_{i} [F(x_{i}+\Delta x)-F(x_{i})]&#x3D;\lim_{\Delta x  \to 0}\sum_{-\infty}^{+\infty}  F^{-1}(y_{i}) [y_{i+\Delta x}-y_{i}])<br>$$</p>
<p>$$<br>&#x3D;\int_{-\infty}^{+\infty}F^{-1}(y) dy&#x3D;\int_{-\infty}^{+\infty}F^{-1}(F(x)) dF(x)&#x3D;\int_{-\infty}^{+\infty}x F’(x)dx\color{red}&#x3D;\int_{-\infty}^{+\infty}x f(x)dx<br>$$</p>
<p>可见连续随机变量的分布函数F(x)在x处可导；且定义式绝对收敛，那么期望存在</p>
<p>统一定义，mark，不理解</p>
<p><img src="/image/image_H1QGkqgXiq.png"></p>
<p>期望性质*</p>
<h4 id="中位数"><a href="#中位数" class="headerlink" title="中位数"></a>中位数</h4><h4 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h4><h4 id="标准差"><a href="#标准差" class="headerlink" title="标准差"></a>标准差</h4><h4 id="矩"><a href="#矩" class="headerlink" title="矩"></a>矩</h4><h4 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h4><h4 id="相关系数"><a href="#相关系数" class="headerlink" title="相关系数"></a>相关系数</h4><h4 id="众数"><a href="#众数" class="headerlink" title="众数"></a>众数</h4><p>公理化定义：<br><strong>陪域的每个元素x</strong>∈R，<strong>都能作为</strong>某个基本事件w组成的集合（<strong>事件域子集</strong>）<strong>的边界</strong><br>设(Ω,F,P)；定义Ω上的函数X:Ω→R;<br><strong>{w∈Ω：X(w)≤x}∈F</strong>；那么影射到的这个子集就是(0,x]∈事件域</p>
<p>确定性事件：存在<strong>必然性命题</strong>，要么真要么假；但由于推论的条件信息不足，或系统误差和统计误差；并不能给出这个确定性命题的限定，只能给出可能命题；此时只能籍由重复实验的频率（频率概率）作为置信度归纳出最有可能的选项；（比如g的测量，g的值是恒定的）</p>
<p>随机性事件：随机性命题具有内禀的客观随机性；我们需要得到这个概率分布去接近客观概率（主观概率）</p>
<p>有自由意志参与时通常认为事件就具有客观随机性；而有倾向的意志导致某些事件的发生具有必然性；这引起了第一性讨论：某些事物的第一性显然与人没关系，是固有规律决定的；而某些事物，比如历史事件的发生因为有大量人的参与，在发生前就具有偶然性，由参与者的意志倾向决定</p>
<h1 id="排列组合-1"><a href="#排列组合-1" class="headerlink" title="排列组合"></a>排列组合</h1><p>（事件域的子集）</p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>阈值分割</title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%83%8F%E7%B4%A0%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/</url>
    <content><![CDATA[<h2 id="二值分割"><a href="#二值分割" class="headerlink" title="二值分割"></a><strong>二值分割</strong></h2><p>适合背景简单的图像内容，如绿幕抠图等简单的前后景分离</p>
<p><img src="/image/image_WeKxaO1Pa_.png"></p>
<p>当像素点的RGB与背景绿色值 (0x00, 0x00, 0xFF) 间的差距小于一定阈值，则判断该像素点为背景像素，否则为前景像素<br>$\sqrt((r-r_{back})^2+(g-g_{back})^2+(b-b_{back})^2)$&lt;阈值⇒背景<br>在实际工程化开发中，可以将 sqrt() 开平方计算拿掉，直接调大阈值范围，这样可以大大加快计算性能</p>
<h2 id="分水岭算法"><a href="#分水岭算法" class="headerlink" title="分水岭算法"></a>分水岭算法</h2><p>很多时候前后景像素的色彩差异值没有这么大，此时就需要对图像内容本身做分割处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>几何变换？</title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%EF%BC%9F/%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%EF%BC%9F/</url>
    <content><![CDATA[<p>把$f(x,y)→f(x’,y’)$;只需要对像素的x,y值进行处理</p>
<h1 id="位置变换"><a href="#位置变换" class="headerlink" title="位置变换"></a>位置变换</h1><h2 id="平移变换"><a href="#平移变换" class="headerlink" title="平移变换"></a>平移变换</h2><p>$\begin{bmatrix}1&amp;&amp;0&amp;&amp;\Delta x\0&amp;&amp;1&amp;&amp;\Delta y\0&amp;&amp;0&amp;&amp;1\end{bmatrix}\begin{bmatrix}x\y\1\end{bmatrix}&#x3D;\begin{bmatrix}x+\Delta x\y+\Delta y\1\end{bmatrix}$</p>
<p><img src="/image/image_zlszowubxI.png"></p>
<h2 id="旋转变换？？"><a href="#旋转变换？？" class="headerlink" title="旋转变换？？"></a>旋转变换？？</h2><p>$\begin{bmatrix}Cos\theta&amp;&amp;-Sin\theta&amp;&amp;0\Sin\theta&amp;&amp;Cos\theta&amp;&amp;0\0&amp;&amp;0&amp;&amp;1\end{bmatrix}\begin{bmatrix}x\y\1\end{bmatrix}&#x3D;\begin{bmatrix}Cos\theta<em>x-Sin\theta</em>y\Sin\theta<em>x+Cos\theta</em>y\1\end{bmatrix}$；<br>$x_1&#x3D;rcos(\alpha+\beta)&#x3D;r(cos\alpha cos\beta-sin\alpha sin\beta)&#x3D;xcos\beta-ysin\beta$$y_1&#x3D;rsin(\alpha+\beta)&#x3D;r(sin\alpha cos\beta+sin\beta cos\alpha)&#x3D;ycos\beta+xsin\beta$<br>锚点旋转变换：<a href="https://zhuanlan.zhihu.com/p/390518158" title="https://zhuanlan.zhihu.com/p/390518158">https://zhuanlan.zhihu.com/p/390518158</a></p>
<h1 id="形状变换"><a href="#形状变换" class="headerlink" title="形状变换"></a>形状变换</h1><h2 id="缩放变换"><a href="#缩放变换" class="headerlink" title="缩放变换"></a>缩放变换</h2><p>$\begin{bmatrix}Sx&amp;&amp;0&amp;&amp;0\0&amp;&amp;Sy&amp;&amp;0\0&amp;&amp;0&amp;&amp;1\end{bmatrix}\begin{bmatrix}x\y\1\end{bmatrix}&#x3D;\begin{bmatrix}Sx<em>x\Sy</em>y\1\end{bmatrix}$；放大后分辨率变高；怎么填充？；缩小时对哪些像素使用模板？</p>
<p><img src="/image/image_wYhsM2jelp.png"></p>
<h2 id="水平镜像"><a href="#水平镜像" class="headerlink" title="水平镜像"></a>水平镜像</h2><p>$\begin{bmatrix}fWidth-x\\y\\1\end{bmatrix}&#x3D;\begin{bmatrix}-1&amp;0&amp;fWidth\\0&amp;1&amp;0\\0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}x\\y\\1\end{bmatrix}$</p>
<h2 id="垂直镜像"><a href="#垂直镜像" class="headerlink" title="垂直镜像"></a>垂直镜像</h2><p>$\begin{bmatrix}x\\fHeith-y\\1\end{bmatrix}&#x3D;\begin{bmatrix}1&amp;0&amp;fWidth\\0&amp;-1&amp;fHeith\\0&amp;0&amp;1\end{bmatrix}\begin{bmatrix}x\\y\\1\end{bmatrix}$</p>
<h2 id="错切变换？？"><a href="#错切变换？？" class="headerlink" title="错切变换？？"></a>错切变换？？</h2><p><img src="/image/image_OXHTU2InX9.png"></p>
<p>$\begin{bmatrix}1&amp;&amp;d_y&amp;&amp;0\d_x&amp;&amp;1\0&amp;&amp;0&amp;&amp;1\end{bmatrix}\begin{bmatrix}x\y\1\end{bmatrix}&#x3D;\begin{bmatrix}x+y<em>d_y\y+x</em>d_x\1\end{bmatrix}$</p>
<h1 id="颜色插值？？？"><a href="#颜色插值？？？" class="headerlink" title="颜色插值？？？"></a>颜色插值？？？</h1>]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>噪声模型？</title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%99%AA%E5%A3%B0%E6%A8%A1%E5%9E%8B%EF%BC%9F/%E5%99%AA%E5%A3%B0%E6%A8%A1%E5%9E%8B%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="图像退化模型"><a href="#图像退化模型" class="headerlink" title="图像退化模型"></a>图像退化模型</h2><p><a href="https://www.wolai.com/kmtG2gVsCfVfhfBbhDMXF9" title="傅里叶分析">傅里叶分析</a><br>设：g为实际图像，f为无损图像，h为损失函数，n为噪声函数<br>空域：$g(x,y)&#x3D;f(x,y)\cdot h(x,y)+n(x,y)$<br>频域：$G(u,v)&#x3D;F(u,v)*H(u,v)+H(u,v)$<br>损失函数：压缩，信号在传输或处理过程中遇到非线性系统，采样误差，拍摄时手持的抖动或者聚焦不对造成模糊、镜头畸变导致的失真造成</p>
<h2 id="n-x-y-噪声模型"><a href="#n-x-y-噪声模型" class="headerlink" title="n(x,y)噪声模型"></a>n(x,y)噪声模型</h2><p><a href="https://zhuanlan.zhihu.com/p/433168055" title="https://zhuanlan.zhihu.com/p/433168055">https://zhuanlan.zhihu.com/p/433168055</a></p>
<p>补了概率和线性系统分析再来</p>
]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>图像数据结构</title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%9B%BE%E5%83%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE%E5%83%8F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>通常图像数据在内存中是连续分布；<br>假设图像缓冲区起始地址为 image_data_，每个像素使用 pixel_bytes_个字节来表示颜色值，图像大小(width_* height _)：<br>则任意像素点 (x, y) 的颜色值数据地址为：$image_data_ + (y*width_<em>pixel_bytes_) + (x</em>pixel_bytes_)$ <em>。这里pixel__bytes</em> 大小根据不同的色彩格式有不同。对于8位灰度图像是1；对于RGB 24位真彩图像是3。（说明：实际计算时可能需要考虑像素行4字节对齐，公式会稍有调整）</p>
<p>通常表示一张图像有四个属性：<br>像素格式(pxl_format)<br>宽度(width)；高度(height)<br>图像数据(image__data)<br>为计算方便，通常还要包括两个属性：<br>像素占用字节数(<em>pixel_bytes</em>)<br>&#x20;行像素占用字节数(line_bytes)&#x3D;width * pixel_bytes</p>
<p>为方便内存管理和放到GPU处理，通常图像<strong>行数据四字节对齐</strong>。既：确保一行像素的字节数可被四整除，如果不能整除则每一行增加几个冗余数据来保存。</p>
<p>例如：对于 320*<em>240 宽高大小的RGB图像，一行像素字节数 line_bytes &#x3D; 320</em>4&#x3D;1280，正好可以被四整除。 而对于 274<em>240 宽高大小的RGB图像，line_bytes &#x3D; 274</em>3 + 2 &#x3D; 824字节，这里一行像素最后要补充2个字节，确保一行像素字节数能被四整除。这样一来对于任意像素点 (x, y) 的颜色值数据地址计算就有调整：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LINE_BYTES(width, bitcount) ((((int32_t)(width) * (bitcount) + 31) &gt;&gt; 5) * 4)</span></span><br></pre></td></tr></table></figure>

<p>$line_bytes_ &#x3D; LINE_BYTES(width, 32);$</p>
<p>$image_data_ + (y<em>line_bytes_) + (x</em>pixel_bytes_)$</p>
<p><strong>常用像素枚举类定义</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief Pixel format</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PXL_FORMAT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  PXL_FORMAT_NONE          = <span class="number">0x00000</span>,</span><br><span class="line"></span><br><span class="line">  PXL_FORMAT_TYPE_RGB      = <span class="number">0x10000</span>,      <span class="comment">///&lt; RGB type </span></span><br><span class="line">  PXL_FORMAT_32BIT_RGBA     = <span class="number">0x10001</span>,      <span class="comment">///&lt; 32bit RGBA</span></span><br><span class="line">  PXL_FORMAT_32BIT_BGRA      = <span class="number">0x10002</span>,      <span class="comment">///&lt; 32bit BGRA</span></span><br><span class="line">  PXL_FORMAT_24BIT_RGB      = <span class="number">0x10003</span>,      <span class="comment">///&lt; 24bit RGB</span></span><br><span class="line">  PXL_FORMAT_24BIT_BGR      = <span class="number">0x10004</span>,      <span class="comment">///&lt; 24bit BGR</span></span><br><span class="line">  PXL_FORMAT_8BIT_GRAY      = <span class="number">0x10005</span>,      <span class="comment">///&lt; 8bit  Gray</span></span><br><span class="line">  PXL_FORMAT_8BIT_BIVALENT  = <span class="number">0x10006</span>,      <span class="comment">///&lt; 8bit  bivalent (0x00 or 0xFF)</span></span><br><span class="line"></span><br><span class="line">  PXL_FORMAT_TYPE_YUV       = <span class="number">0x20000</span>,      <span class="comment">///&lt; YUV type </span></span><br><span class="line">  PXL_FORMAT_YUV420      = <span class="number">0x20001</span>,      <span class="comment">///&lt; YUV 420</span></span><br><span class="line">  PXL_FORMAT_NV21           = <span class="number">0x20002</span>,      <span class="comment">///&lt; NV21</span></span><br><span class="line">  PXL_FORMAT_NV12      = <span class="number">0x20003</span>,      <span class="comment">///&lt; NV21</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>图像数据模型类定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief XImage class</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XImage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">XImage</span>();</span><br><span class="line">  <span class="built_in">XImage</span>(PXL_FORMAT pxl_format, <span class="type">int32_t</span> width, <span class="type">int32_t</span> height);</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">XImage</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int32_t</span> <span class="title">Allocate</span><span class="params">(PXL_FORMAT pxl_format, <span class="type">int32_t</span> width, <span class="type">int32_t</span> height)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span>    <span class="title">Release</span><span class="params">( )</span></span>;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span>  <span class="title">IsValid</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">PXL_FORMAT  <span class="title">GetPxlFormat</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int32_t</span>  <span class="title">GetWidth</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int32_t</span>  <span class="title">GetHeight</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int32_t</span>  <span class="title">GetPxlBytyes</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int32_t</span>       <span class="title">GetLineBytes</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int32_t</span>       <span class="title">GetImgBytes</span><span class="params">( )</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">uint8_t</span>*      <span class="title">GetImgBuffer</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断两个图像数据是否具有相同的参数</span></span><br><span class="line">  <span class="function"><span class="type">bool</span>    <span class="title">IsSameParameter</span><span class="params">(<span class="type">const</span> XImage&amp; comparing_img)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int32_t</span>        <span class="title">Convert</span><span class="params">(PXL_FORMAT target_pxl_format, XImage&amp; target_img)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  PXL_FORMA  pxl_format_   = PXL_FORMAT::PXL_FORMAT_NONE;</span><br><span class="line">  <span class="type">int32_t</span>    width_     = <span class="number">0</span>;     <span class="comment">///&lt; image width</span></span><br><span class="line">  <span class="type">int32_t</span>    height_     = <span class="number">0</span>;    <span class="comment">///&lt; image height</span></span><br><span class="line">  <span class="type">int32_t</span>    line_bytes_   = <span class="number">0</span>;    <span class="comment">///&lt; bytes of one line pixle, it&#x27;s aligned by 4 bytes</span></span><br><span class="line">  <span class="type">int32_t</span>    pixel_bytes_  = <span class="number">0</span>;    <span class="comment">///&lt; bytes per each pixel</span></span><br><span class="line">  <span class="type">int32_t</span>    image_bytes_  = <span class="number">0</span>;    <span class="comment">///&lt; total bytes of current image</span></span><br><span class="line">  std::unique_ptr&lt;<span class="type">uint8_t</span>[]&gt; image_data_ptr_ = <span class="literal">nullptr</span>;  <span class="comment">///&lt; smart pointer of image data</span></span><br><span class="line">  <span class="type">uint8_t</span>*   image_data_   = <span class="literal">nullptr</span>;    <span class="comment">///&lt; image data</span></span><br><span class="line">  <span class="type">bool</span>       image_valid_  = <span class="literal">false</span>;      <span class="comment">///&lt; whether image is valid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图像数据的分配和释放</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LINE_BYTES(width, bitcount)  ((((XLONG)(width) * (bitcount) + 31) &gt;&gt; 5) * 4)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int32_t</span>  <span class="title">XImage::Allocate</span><span class="params">(PXL_FORMAT pxl_format, <span class="type">int32_t</span> width, <span class="type">int32_t</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (pxl_format)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> PXL_FORMAT_32BIT_RGBA:</span><br><span class="line">    <span class="keyword">case</span> PXL_FORMAT_32BIT_BGRA:</span><br><span class="line">    &#123;</span><br><span class="line">      pxl_format_  = pxl_format;</span><br><span class="line">      width_      = width;  </span><br><span class="line">      height_      = height;</span><br><span class="line">      pixel_bytes_    = <span class="number">4</span>;</span><br><span class="line">      line_bytes_  = <span class="built_in">LINE_BYTES</span>(width, <span class="number">32</span>);  <span class="comment">// 这里一定四字节对齐</span></span><br><span class="line">      image_bytes_    = line_bytes_ * height_;</span><br><span class="line">      image_data_ptr_ = std::<span class="built_in">make_unique</span>&lt;<span class="type">uint8_t</span>[]&gt;(image_bytes_);</span><br><span class="line">      image_data_  = image_data_ptr_.<span class="built_in">get</span>();</span><br><span class="line">      <span class="built_in">memset</span>(image_data_, <span class="number">0</span>, image_bytes_);</span><br><span class="line">      image_valid_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> PXL_FORMAT_24BIT_RGB:</span><br><span class="line">    <span class="keyword">case</span> PXL_FORMAT_24BIT_BGR:</span><br><span class="line">    &#123;</span><br><span class="line">      pxl_format_  = pxl_format;</span><br><span class="line">      width_      = width;  </span><br><span class="line">      height_      = height;</span><br><span class="line">      pixel_bytes_    = <span class="number">3</span>;</span><br><span class="line">      line_bytes_  = <span class="built_in">LINE_BYTES</span>(width, <span class="number">24</span>);</span><br><span class="line">      image_bytes_    = line_bytes_ * height_;    <span class="comment">// 这里要注意四字节对齐的</span></span><br><span class="line">      image_data_ptr_ = std::<span class="built_in">make_unique</span>&lt;<span class="type">uint8_t</span>[]&gt;(image_bytes_);</span><br><span class="line">      image_data_      = image_data_ptr_.<span class="built_in">get</span>();</span><br><span class="line">      <span class="built_in">memset</span>(image_data_, <span class="number">0</span>, image_bytes_);</span><br><span class="line">      image_valid_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> PXL_FORMAT_8BIT_GRAY:</span><br><span class="line">    <span class="keyword">case</span> PXL_FORMAT_8BIT_BIVALENT:</span><br><span class="line">    &#123;</span><br><span class="line">      pxl_format_  = pxl_format;</span><br><span class="line">      width_      = width;  </span><br><span class="line">      height_      = height;</span><br><span class="line">      pixel_bytes_    = <span class="number">1</span>;</span><br><span class="line">      line_bytes_  = <span class="built_in">LINE_BYTES</span>(width, <span class="number">8</span>);</span><br><span class="line">      image_bytes_    = line_bytes_ * height_;    <span class="comment">// 这里要注意四字节对齐的</span></span><br><span class="line">      image_data_ptr_ = std::<span class="built_in">make_unique</span>&lt;<span class="type">uint8_t</span>[]&gt;(image_bytes_);</span><br><span class="line">      image_data_  = image_data_ptr_.<span class="built_in">get</span>();</span><br><span class="line">      <span class="built_in">memset</span>(image_data_, <span class="number">0</span>, image_bytes_);</span><br><span class="line">      image_valid_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> PXL_FORMAT_YUV420:</span><br><span class="line">    <span class="keyword">case</span> PXL_FORMAT_NV21:</span><br><span class="line">    <span class="keyword">case</span> PXL_FORMAT_NV12:</span><br><span class="line">    &#123;</span><br><span class="line">      pxl_format_  = pxl_format;</span><br><span class="line">      width_      = (width / <span class="number">2</span> + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">      height_      = (height / <span class="number">2</span> + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">      line_bytes_  = width;</span><br><span class="line">      image_bytes_    = width_ * height_ * <span class="number">3</span> / <span class="number">2</span>;    </span><br><span class="line">      image_data_ptr_ = std::<span class="built_in">make_unique</span>&lt;<span class="type">uint8_t</span>[]&gt;(image_bytes_);</span><br><span class="line">      image_data_  = image_data_ptr_.<span class="built_in">get</span>();</span><br><span class="line">      <span class="built_in">memset</span>(image_data_, <span class="number">0</span>, image_bytes_);</span><br><span class="line">      image_valid_ = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">XOS_ERROR</span>(TAG_IMGENG, <span class="string">&quot;&lt;XImage.Allocate&gt; pixel format not support, pxl_format=%d&quot;</span>, pxl_format);</span><br><span class="line">      image_valid_ = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> XERR_INVALID_PARAM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> XOK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">XImage::Release</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pxl_format_ = PXL_FORMAT_NONE;</span><br><span class="line">  width_ = <span class="number">0</span>;  </span><br><span class="line">  height_ = <span class="number">0</span>;</span><br><span class="line">  line_bytes_ = <span class="number">0</span>;</span><br><span class="line">  pixel_bytes_ = <span class="number">0</span>;</span><br><span class="line">  image_data_ptr_.<span class="built_in">reset</span>( );</span><br><span class="line">  image_data_ = <span class="literal">nullptr</span>;</span><br><span class="line">  image_valid_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">XImage::IsSameParameter</span><span class="params">(<span class="type">const</span> XImage&amp; comparing_img)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((pxl_format_ == comparing_img.pxl_format_)</span><br><span class="line">      &amp;&amp; (width_ == comparing_img.width_)</span><br><span class="line">      &amp;&amp; (height_ == comparing_img.height_))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RGB图像格式的转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PIXEL_TRAVERSAL_BEGIN                      \</span></span><br><span class="line"><span class="meta">  &#123;                                                    \</span></span><br><span class="line"><span class="meta">    int32_t i, j;                                    \</span></span><br><span class="line"><span class="meta">    uint8_t* pSrcLine = image_data_;              \</span></span><br><span class="line"><span class="meta">    uint8_t* pDstLine = target_img.image_data_;    \</span></span><br><span class="line"><span class="meta">    for (i = 0; i &lt; height_; i++)                    \</span></span><br><span class="line"><span class="meta">    &#123;                                                                              \</span></span><br><span class="line"><span class="meta">      uint8_t* pSrcData = pSrcLine;                \</span></span><br><span class="line"><span class="meta">      uint8_t* pDstData = pDstLine;                \</span></span><br><span class="line"><span class="meta">      for (j = 0; j &lt; width_; j++)                                \</span></span><br><span class="line"><span class="meta">      &#123;                                                                            \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIXEL_TRAVERSAL_END                               \</span></span><br><span class="line"><span class="meta">        pSrcData += pixel_bytes_;                  \</span></span><br><span class="line"><span class="meta">        pDstData += target_img.pixel_bytes_;     \</span></span><br><span class="line"><span class="meta">      &#125;                                                \</span></span><br><span class="line"><span class="meta">      pSrcLine += line_bytes_;                      \</span></span><br><span class="line"><span class="meta">      pDstLine += target_img.line_bytes_;          \</span></span><br><span class="line"><span class="meta">    &#125;                                                  \</span></span><br><span class="line"><span class="meta">  &#125;                                                    \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIXEL_24BIT_TO_32BIT              \</span></span><br><span class="line"><span class="meta">  pDstData[0] = pSrcData[0];              \</span></span><br><span class="line"><span class="meta">  pDstData[1] = pSrcData[1];              \</span></span><br><span class="line"><span class="meta">  pDstData[2] = pSrcData[2];              \</span></span><br><span class="line"><span class="meta">  pDstData[3] = 0xFF;                     \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIXEL_32BIT_TO_24BIT              \</span></span><br><span class="line"><span class="meta">  pDstData[0] = pSrcData[0];              \</span></span><br><span class="line"><span class="meta">  pDstData[1] = pSrcData[1];              \</span></span><br><span class="line"><span class="meta">  pDstData[2] = pSrcData[2];              \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIXEL_CHGRB_24BIT_TO_24BIT        \</span></span><br><span class="line"><span class="meta">  pDstData[0] = pSrcData[2];              \</span></span><br><span class="line"><span class="meta">  pDstData[1] = pSrcData[1];              \</span></span><br><span class="line"><span class="meta">  pDstData[2] = pSrcData[0];              \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIXEL_CHGRB_32BIT_TO_32BIT        \</span></span><br><span class="line"><span class="meta">  pDstData[0] = pSrcData[2];              \</span></span><br><span class="line"><span class="meta">  pDstData[1] = pSrcData[1];              \</span></span><br><span class="line"><span class="meta">  pDstData[2] = pSrcData[0];              \</span></span><br><span class="line"><span class="meta">  pDstData[3] = pSrcData[3];              \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIXEL_CHGRB_24BIT_TO_32BIT        \</span></span><br><span class="line"><span class="meta">  pDstData[0] = pSrcData[2];              \</span></span><br><span class="line"><span class="meta">  pDstData[1] = pSrcData[1];              \</span></span><br><span class="line"><span class="meta">  pDstData[2] = pSrcData[0];              \</span></span><br><span class="line"><span class="meta">  pDstData[3] = 0xFF;                     \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIXEL_CHGRB_32BIT_TO_24BIT        \</span></span><br><span class="line"><span class="meta">  pDstData[0] = pSrcData[2];                    \</span></span><br><span class="line"><span class="meta">  pDstData[1] = pSrcData[1];                    \</span></span><br><span class="line"><span class="meta">  pDstData[2] = pSrcData[0];                    \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIXEL_RGB_TO_GRAY                 \</span></span><br><span class="line"><span class="meta">  uint32_t  R = pSrcData[0] * 77;         \</span></span><br><span class="line"><span class="meta">  uint32_t  G = pSrcData[1] * 151;        \</span></span><br><span class="line"><span class="meta">  uint32_t  B = pSrcData[2] * 28;          \</span></span><br><span class="line"><span class="meta">  uint32_t  gray = (R + G + B) &gt;&gt; 8;       \</span></span><br><span class="line"><span class="meta">  pDstData[0] = (uint8_t)gray;              \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIXEL_BGR_TO_GRAY                 \</span></span><br><span class="line"><span class="meta">  uint32_t  R = pSrcData[2] * 77;          \</span></span><br><span class="line"><span class="meta">  uint32_t  G = pSrcData[1] * 151;        \</span></span><br><span class="line"><span class="meta">  uint32_t  B = pSrcData[0] * 28;          \</span></span><br><span class="line"><span class="meta">  uint32_t  gray = (R + G + B) &gt;&gt; 8;     \</span></span><br><span class="line"><span class="meta">  pDstData[0] = (uint8_t)gray;              \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIXEL_GRAY_TO_24BIT           \</span></span><br><span class="line"><span class="meta">  pDstData[0] = pSrcData[0];              \</span></span><br><span class="line"><span class="meta">  pDstData[1] = pSrcData[0];              \</span></span><br><span class="line"><span class="meta">  pDstData[2] = pSrcData[0];              \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIXEL_GRAY_TO_32BIT           \</span></span><br><span class="line"><span class="meta">  pDstData[0] = pSrcData[0];              \</span></span><br><span class="line"><span class="meta">  pDstData[1] = pSrcData[0];              \</span></span><br><span class="line"><span class="meta">  pDstData[2] = pSrcData[0];              \</span></span><br><span class="line"><span class="meta">  pDstData[3] = 0xFF;                         \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIXEL_RGB_TO_BIVALENT           \</span></span><br><span class="line"><span class="meta">  uint32_t  R = pSrcData[0] * 77;            \</span></span><br><span class="line"><span class="meta">  uint32_t  G = pSrcData[1] * 151;          \</span></span><br><span class="line"><span class="meta">  uint32_t  B = pSrcData[2] * 28;            \</span></span><br><span class="line"><span class="meta">  uint32_t  gray = (R + G + B) &gt;&gt; 8;        \</span></span><br><span class="line"><span class="meta">  pDstData[0] = (uint8_t)((gray &gt; 32) ? 0xFF : 0x00);  \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIXEL_BGR_TO_BIVALENT               \</span></span><br><span class="line"><span class="meta">  uint32_t  R = pSrcData[2] * 77;             \</span></span><br><span class="line"><span class="meta">  uint32_t  G = pSrcData[1] * 151;            \</span></span><br><span class="line"><span class="meta">  uint32_t  B = pSrcData[0] * 28;              \</span></span><br><span class="line"><span class="meta">  uint32_t  gray = (R + G + B) &gt;&gt; 8;          \</span></span><br><span class="line"><span class="meta">  pDstData[0] = (uint8_t)((gray &gt; 32) ? 0xFF : 0x00);  \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIXEL_GRAY_TO_BIVALENT               \</span></span><br><span class="line"><span class="meta">  pDstData[0] = (pSrcData[0] &gt; 32) ? 0xFF : 0x00;      \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIXEL_BIVALENT_TO_GRAY                \</span></span><br><span class="line"><span class="meta">  pDstData[0] = pSrcData[0];                    \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">XImage::Convert</span><span class="params">(PXL_FORMAT target_pxl_format, XImage&amp; target_img)</span></span><br><span class="line">&#123;</span><br><span class="line">  target_img.Release( );</span><br><span class="line">  <span class="type">int32_t</span> res = target_img.Allocate(target_pxl_format, width_, height_);</span><br><span class="line">  <span class="keyword">if</span> (res != XOK)</span><br><span class="line">  &#123;</span><br><span class="line">    XOS_ERROR(TAG_IMGENG, <span class="string">&quot;&lt;XImage.Convert&gt; fail to allocate image, fmt=%d, w=%d, h=%d&quot;</span>,</span><br><span class="line">              target_pxl_format, width_, height_ );</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (target_pxl_format == pxl_format_)  </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 目标和当前是相同的像素格式,直接数据拷贝</span></span><br><span class="line">    <span class="built_in">memcpy</span>(target_img.image_data_, image_data_, image_bytes_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pixel_bytes_ == <span class="number">3</span> &amp;&amp; target_img.pixel_bytes_ == <span class="number">3</span>)  <span class="comment">// 24bit --&gt; 24bit, change RB</span></span><br><span class="line">  &#123;</span><br><span class="line">    PIXEL_TRAVERSAL_BEGIN;  PIXEL_CHGRB_24BIT_TO_24BIT;  PIXEL_TRAVERSAL_END;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pixel_bytes_ == <span class="number">4</span> &amp;&amp; target_img.pixel_bytes_ == <span class="number">4</span>)  <span class="comment">// 32bit --&gt; 32bit, change RB</span></span><br><span class="line">  &#123;</span><br><span class="line">    PIXEL_TRAVERSAL_BEGIN;  PIXEL_CHGRB_32BIT_TO_32BIT;  PIXEL_TRAVERSAL_END;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pixel_bytes_ == <span class="number">3</span> &amp;&amp; target_img.pixel_bytes_ == <span class="number">4</span>)  <span class="comment">// 24bit --&gt; 32bit</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ((pxl_format_ == PXL_FORMAT_24BIT_RGB &amp;&amp; target_img.pxl_format_ == PXL_FORMAT_32BIT_BGRA)</span><br><span class="line">        || (pxl_format_ == PXL_FORMAT_24BIT_BGR &amp;&amp; target_img.pxl_format_ == PXL_FORMAT_32BIT_RGBA))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// RGB--&gt; BGRA or BGR--&gt;RGBA</span></span><br><span class="line">      PIXEL_TRAVERSAL_BEGIN;  PIXEL_CHGRB_24BIT_TO_32BIT;  PIXEL_TRAVERSAL_END;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// RGB--&gt; RGBA or BGR--&gt;BGRA</span></span><br><span class="line">      PIXEL_TRAVERSAL_BEGIN;  PIXEL_24BIT_TO_32BIT;  PIXEL_TRAVERSAL_END;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pixel_bytes_ == <span class="number">4</span> &amp;&amp; target_img.pixel_bytes_ == <span class="number">3</span>)  <span class="comment">// 32bit --&gt; 24bit</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ((pxl_format_ == PXL_FORMAT_32BIT_RGBA &amp;&amp; target_img.pxl_format_ == PXL_FORMAT_24BIT_BGR)</span><br><span class="line">        || (pxl_format_ == PXL_FORMAT_32BIT_BGRA &amp;&amp; target_img.pxl_format_ == PXL_FORMAT_24BIT_RGB))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// RGBA--&gt; BGR or BGRA--&gt;RGB</span></span><br><span class="line">      PIXEL_TRAVERSAL_BEGIN;  PIXEL_CHGRB_32BIT_TO_24BIT;  PIXEL_TRAVERSAL_END;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// RGBA--&gt; RGB or BGRA--&gt;BGR</span></span><br><span class="line">      PIXEL_TRAVERSAL_BEGIN;  PIXEL_32BIT_TO_24BIT;  PIXEL_TRAVERSAL_END;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pixel_bytes_ == <span class="number">1</span> &amp;&amp; target_img.pixel_bytes_ == <span class="number">3</span>)  <span class="comment">// Gray --&gt; 24bit(RGB/BGR)</span></span><br><span class="line">  &#123;</span><br><span class="line">    PIXEL_TRAVERSAL_BEGIN;  PIXEL_GRAY_TO_24BIT;  PIXEL_TRAVERSAL_END;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pixel_bytes_ == <span class="number">1</span> &amp;&amp; target_img.pixel_bytes_ == <span class="number">4</span>)  <span class="comment">// Gray --&gt; 32bit(RGBA/BGRA)</span></span><br><span class="line">  &#123;</span><br><span class="line">    PIXEL_TRAVERSAL_BEGIN;  PIXEL_GRAY_TO_32BIT;  PIXEL_TRAVERSAL_END;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pixel_bytes_ == <span class="number">1</span> &amp;&amp; target_img.pixel_bytes_ == <span class="number">1</span>)  <span class="comment">// Bivalent/Gray --&gt; Gray/Bivalen</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (pxl_format_ == PXL_FORMAT_8BIT_BIVALENT &amp;&amp;  target_img.pxl_format_ == PXL_FORMAT_8BIT_GRAY)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// Bivalent--&gt;Gray</span></span><br><span class="line">      PIXEL_TRAVERSAL_BEGIN;  PIXEL_BIVALENT_TO_GRAY;  PIXEL_TRAVERSAL_END;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// Gray--&gt;Bivalent</span></span><br><span class="line">      PIXEL_TRAVERSAL_BEGIN;  PIXEL_GRAY_TO_BIVALENT;  PIXEL_TRAVERSAL_END;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (target_img.pixel_bytes_ == <span class="number">1</span>)  <span class="comment">// 24bit/32bit --&gt; Gray</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (target_img.pxl_format_ == PXL_FORMAT_8BIT_GRAY)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (pxl_format_ == PXL_FORMAT_24BIT_RGB || pxl_format_ == PXL_FORMAT_32BIT_RGBA)  <span class="comment">// RGB/RGBA --&gt; Gray</span></span><br><span class="line">      &#123;</span><br><span class="line">        PIXEL_TRAVERSAL_BEGIN;  PIXEL_RGB_TO_GRAY;  PIXEL_TRAVERSAL_END;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>    <span class="comment">// BGR/BGRA --&gt;Gray</span></span><br><span class="line">      &#123;</span><br><span class="line">        PIXEL_TRAVERSAL_BEGIN;  PIXEL_BGR_TO_GRAY;  PIXEL_TRAVERSAL_END;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (pxl_format_ == PXL_FORMAT_24BIT_RGB || pxl_format_ == PXL_FORMAT_32BIT_RGBA)  <span class="comment">// RGB/RGBA --&gt; Bivalent</span></span><br><span class="line">      &#123;</span><br><span class="line">        PIXEL_TRAVERSAL_BEGIN;  PIXEL_RGB_TO_BIVALENT;  PIXEL_TRAVERSAL_END;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>    <span class="comment">// BGR/BGRA --&gt;Bivalent</span></span><br><span class="line">      &#123;</span><br><span class="line">        PIXEL_TRAVERSAL_BEGIN;  PIXEL_BGR_TO_BIVALENT;  PIXEL_TRAVERSAL_END;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    XOS_ERROR(TAG_IMGENG, <span class="string">&quot;&lt;XImage.Convert&gt; unsupported format, src_fmt=%d, dst_fmt=%d&quot;</span>,</span><br><span class="line">              pxl_format_, target_pxl_format );</span><br><span class="line">    <span class="keyword">return</span> XERR_UNSUPPORTED;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> XOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>多帧图像下的通道变换（图层混合操作）</title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%A4%9A%E5%B8%A7%E5%9B%BE%E5%83%8F%E4%B8%8B%E7%9A%84%E9%80%9A%E9%81%93%E5%8F%98%E6%8D%A2%EF%BC%88%E5%9B%BE%E5%B1%82%E6%B7%B7%E5%90%88%E6%93%8D%E4%BD%9C%EF%BC%89/%E5%A4%9A%E5%B8%A7%E5%9B%BE%E5%83%8F%E4%B8%8B%E7%9A%84%E9%80%9A%E9%81%93%E5%8F%98%E6%8D%A2%EF%BC%88%E5%9B%BE%E5%B1%82%E6%B7%B7%E5%90%88%E6%93%8D%E4%BD%9C%EF%BC%89/</url>
    <content><![CDATA[<p><img src="/image/image_CE75VBRHOK.png"></p>
<p>+：<br>图像叠加:$f_1(x,y)\alpha*f_2(x,y)(1-\alpha);\alpha\in[0,1]$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 读取图片1</span></span><br><span class="line">img = cv.imread(<span class="string">&#x27;zzf1.jpg&#x27;</span>)</span><br><span class="line">img1 = cv.resize(img, (<span class="number">400</span>, <span class="number">600</span>))</span><br><span class="line">cv.imshow(<span class="string">&#x27;reba&#x27;</span>, img1)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 读取图片2</span></span><br><span class="line">img2 = cv.imread(<span class="string">&#x27;zzf2.jpg&#x27;</span>)</span><br><span class="line">img3 = cv.resize(img2, (<span class="number">400</span>, <span class="number">600</span>))</span><br><span class="line">cv.imshow(<span class="string">&#x27;dilireba&#x27;</span>, img3)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 对图像加权相加</span></span><br><span class="line">img4 = cv.addWeighted(img1, <span class="number">0.6</span>, img3, <span class="number">0.4</span>, <span class="number">0</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;addweighted&#x27;</span>, img4)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>多帧去噪：$\frac{1}{M}\sum_{i&#x3D;1}^{M}f_i(x,y)$<br>单帧增亮&#x2F;增暗：$f(x,y)+-num；若限制最大值为255则增亮，若不限制则可能溢出变暗$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    +对两个图像进行操作时，像素大于255取余数，所以相加后的图形会变暗</span></span><br><span class="line"><span class="string">    add对两个图形进行操作时，像素大于255时保持255，所以相加后的图像会变亮</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img = cv.imread(<span class="string">&#x27;zzf1.jpg&#x27;</span>)</span><br><span class="line">img = cv.resize(img, (<span class="number">600</span>,<span class="number">800</span>))</span><br><span class="line">cv.imshow(<span class="string">&#x27;zzf&#x27;</span>, img)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 用+对图像相加</span></span><br><span class="line">img1 = img + img</span><br><span class="line">cv. imshow(<span class="string">&#x27;+&#x27;</span>, img1)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 用add对图像相加</span></span><br><span class="line">img2 = cv.add(img, img)</span><br><span class="line">cv.imshow(<span class="string">&#x27;add&#x27;</span>, img2)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p>-:<br>检测多帧变化的部分，检测运动物体</p>
<p>*：</p>
<p>除法：<br>产生比率图像？</p>
<p>&amp;:<br>通过与2值图像进行掩模进行图像分割：</p>
<p><img src="/image/image_AX6r4tpoS_.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 读取图片</span></span><br><span class="line">img = cv.imread(<span class="string">&#x27;pangdi.jpg&#x27;</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;reba&#x27;</span>, img)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 生成掩膜图像</span></span><br><span class="line">mask = np.zeros(img.shape, dtype=np.uint8)</span><br><span class="line">mask[<span class="number">200</span>:<span class="number">400</span>, <span class="number">400</span>:<span class="number">600</span>] = <span class="number">255</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;mask&#x27;</span>, mask)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 进行逻辑与运算，截取重要部分</span></span><br><span class="line">img1 = cv.bitwise_and(img, mask)</span><br><span class="line">cv.imshow(<span class="string">&#x27;bitwise_and&#x27;</span>, img1)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>|:<br>通过与2值图像进行掩模进行图像分割：</p>
<p><img src="/image/image_p1tuxWVrYk.png"></p>
<p>~:<br>二值化后进行反色<br>(&amp;’):</p>
<p>(|’):</p>
<p>异或：<br>加密：图片与密钥异或运算<br>解密：加密图像与密钥异或运算</p>
<p><img src="https://img-blog.csdnimg.cn/bfe601156df04f0cb64b1925ac882a28.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5LiA5Y-q5Lya6aOe55qE54yq77iP,size_20,color_FFFFFF,t_70,g_se,x_16"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">img = cv.imread(<span class="string">&#x27;zzf3.jpg&#x27;</span>)</span><br><span class="line">img = cv.resize(img, (<span class="number">800</span>, <span class="number">500</span>))</span><br><span class="line">cv.imshow(<span class="string">&#x27;yuantu&#x27;</span>, img)  <span class="comment"># 显示原图</span></span><br><span class="line">key = np.random.randint(<span class="number">0</span>, <span class="number">256</span>, size=img.shape , dtype=np.uint8)</span><br><span class="line">cv.imshow(<span class="string">&#x27;key&#x27;</span>, key)  <span class="comment"># 显示密钥</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 对图像进行加密</span></span><br><span class="line">img1 = cv.bitwise_xor(img, key)  <span class="comment">#显示加密后图形</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;encryption&#x27;</span>, img1)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 对加密图像解密</span></span><br><span class="line">img2 = cv.bitwise_xor(img1, key)</span><br><span class="line">cv.imshow(<span class="string">&#x27;decryption&#x27;</span>, img2)  <span class="comment"># 显示解密后图形</span></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h2 id="模板：两张图像进行自定义操作后输出到目标图像："><a href="#模板：两张图像进行自定义操作后输出到目标图像：" class="headerlink" title="模板：两张图像进行自定义操作后输出到目标图像："></a>模板：两张图像进行自定义操作后输出到目标图像：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief The Base information of image </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">XImgBaseInfo</span><span class="comment">//图像基本信息的结构体</span></span><br><span class="line">&#123;</span><br><span class="line">  PXL_FORMAT  pxl_format;</span><br><span class="line">  <span class="type">int32_t</span>      pixel_bytes;<span class="comment">// 像素格式</span></span><br><span class="line">  <span class="type">int32_t</span>      line_bytes;<span class="comment">// 每行像素所占字节数</span></span><br><span class="line">  <span class="type">int32_t</span>      width;<span class="comment">//图像宽度</span></span><br><span class="line">  <span class="type">int32_t</span>     height;<span class="comment">//图像高度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief Liner operation function, </span></span><br><span class="line"><span class="comment">*        The source &amp; reference &amp; out image must have the same width &amp; height &amp; pixel format</span></span><br><span class="line"><span class="comment">* @param user_data    -- user data;;;指向 void 类型的用户自定义数据的指针</span></span><br><span class="line"><span class="comment">* @param img_info     -- the base information of image;;;引用类型的 XImgBaseInfo 结构体，用于传递图像的基本信息</span></span><br><span class="line"><span class="comment">* @param src_pxl_data -- source pixel data;;uint8_t 类型的指针，指向源图像的像素数据</span></span><br><span class="line"><span class="comment">* @param ref_pxl_data -- reference pixel data;;uint8_t 类型的指针，指向参考图像的像素数据</span></span><br><span class="line"><span class="comment">* @param out_pxl_data -- output pixel data;;;uint8_t 类型的指针，指向输出图像的像素数据</span></span><br><span class="line"><span class="comment">* @return None</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span>/定义了一个函数指针类型PFN_LINEAR_OPT，指向的函数返回<span class="type">void</span>,且接受右边一箩筐参数</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*PFN_LINEAR_OPT)</span><span class="params">(<span class="type">void</span>* user_data, <span class="type">const</span> XImgBaseInfo&amp; img_info,<span class="type">uint8_t</span>* src_pxl_data,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">uint8_t</span>* ref_pxl_data, <span class="type">uint8_t</span>* out_pxl_data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 两张图像做自定义操作 (例如: 加; 减; 乘; 除; 异或 等), 结果输出到目标图像</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">XImage::LinearOperation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> XImage&amp;    reference_img, </span></span></span><br><span class="line"><span class="params"><span class="function">  XImage&amp;          out_img,</span></span></span><br><span class="line"><span class="params"><span class="function">  PFN_LINEAR_OPT  fn_linear_opt, <span class="comment">//声明PFN_LINEAR_OPT类型函数指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">void</span>*            user_data      )</span><span class="comment">//指向 void 类型的用户自定义数据的指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int32_t</span> ret = <span class="number">0</span>, i, j;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!image_valid_)<span class="comment">// 检查输入参数的有效性</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> XERR_BAD_STATE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (fn_linear_opt == <span class="literal">nullptr</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> XERR_INVALID_PARAM;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">IsSameParameter</span>(reference_img))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> XERR_INVALID_PARAM;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">IsSameParameter</span>(out_img))</span><br><span class="line">  &#123;</span><br><span class="line">    out_img.<span class="built_in">Release</span>();</span><br><span class="line">    ret = out_img.<span class="built_in">Allocate</span>(pxl_format_, width_, height_);</span><br><span class="line">    <span class="built_in">XASSERT</span>(ret == XOK);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 设置图像的基本信息</span></span><br><span class="line">  XImgBaseInfo  base_info;</span><br><span class="line">  base_info.pxl_format = pxl_format_;</span><br><span class="line">  base_info.pixel_bytes = pixel_bytes_;</span><br><span class="line">  base_info.line_bytes = line_bytes_;</span><br><span class="line">  base_info.width = width_;</span><br><span class="line">  base_info.height = height_;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span>* source_line    = image_data_;</span><br><span class="line">  <span class="type">uint8_t</span>* reference_line = reference_img.image_data_;</span><br><span class="line">  <span class="type">uint8_t</span>* target_line    = out_img.image_data_;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; height_; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">uint8_t</span>* source_data    = source_line;</span><br><span class="line">    <span class="type">uint8_t</span>* reference_data = reference_line;</span><br><span class="line">    <span class="type">uint8_t</span>* target_data    = target_line;</span><br><span class="line"><span class="comment">// 遍历图像的每个像素点，调用线性操作函数进行操作</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; width_; j++)</span><br><span class="line">    &#123;<span class="comment">//调用fn_linear_opt指针所指向的函数，并传递了五个参数：</span></span><br><span class="line">      (fn_linear_opt)(user_data, base_info, source_data, reference_data, target_data);</span><br><span class="line"><span class="comment">// 更新指针</span></span><br><span class="line">      source_data += pixel_bytes_;</span><br><span class="line">      reference_data += pixel_bytes_;</span><br><span class="line">      target_data += pixel_bytes_;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 更新行指针</span></span><br><span class="line">    source_line += line_bytes_;</span><br><span class="line">    reference_line += line_bytes_;</span><br><span class="line">    target_line += line_bytes_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> XOK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 原始图像以 65%显示;  参考图像以35%透明度显示</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XImageLinearOpt</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">void</span>* user_data,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">const</span> XImgBaseInfo&amp; img_info,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">uint8_t</span>* src_pxl_data,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">uint8_t</span>* ref_pxl_data,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">uint8_t</span>* out_pxl_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">// 获取原始图像和参考图像的RGB值</span></span><br><span class="line">  <span class="type">int32_t</span> src_b = src_pxl_data[<span class="number">0</span>];</span><br><span class="line">  <span class="type">int32_t</span> src_g = src_pxl_data[<span class="number">1</span>];</span><br><span class="line">  <span class="type">int32_t</span> src_r = src_pxl_data[<span class="number">2</span>];</span><br><span class="line">  <span class="type">int32_t</span> ref_b = ref_pxl_data[<span class="number">0</span>];</span><br><span class="line">  <span class="type">int32_t</span> ref_g = ref_pxl_data[<span class="number">1</span>];</span><br><span class="line">  <span class="type">int32_t</span> ref_r = ref_pxl_data[<span class="number">2</span>];</span><br><span class="line">  <span class="type">int32_t</span> out_b, out_g, out_r;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 原始图像以 65%显示;  参考图像以35%透明度显示</span></span><br><span class="line">  <span class="comment">// 浮点计算公式:  out = src * 0.65 + ref * 0.35</span></span><br><span class="line">  <span class="comment">// 优化定点公式:  out = (src * 166 + ref * 90) &gt;&gt; 8;</span></span><br><span class="line">  out_b = (src_b * <span class="number">166</span> + ref_b * <span class="number">90</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">  out_g = (src_g * <span class="number">166</span> + ref_g * <span class="number">90</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">  out_r = (src_r * <span class="number">166</span> + ref_r * <span class="number">90</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 对输出像素的RGB值进行范围限制</span></span><br><span class="line">  <span class="keyword">if</span> (out_b &lt; <span class="number">0</span>)    out_b = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (out_b &gt; <span class="number">255</span>)  out_b = <span class="number">255</span>;</span><br><span class="line">  <span class="keyword">if</span> (out_g &lt; <span class="number">0</span>)    out_g = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (out_g &gt; <span class="number">255</span>)  out_g = <span class="number">255</span>;</span><br><span class="line">  <span class="keyword">if</span> (out_r &lt; <span class="number">0</span>)    out_r = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (out_r &gt; <span class="number">255</span>)  out_r = <span class="number">255</span>;</span><br><span class="line"><span class="comment">// 将计算得到的RGB值保存到输出像素中</span></span><br><span class="line">  out_pxl_data[<span class="number">0</span>] = out_b;</span><br><span class="line">  out_pxl_data[<span class="number">1</span>] = out_g;</span><br><span class="line">  out_pxl_data[<span class="number">2</span>] = out_r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  XImage source_img, ref_img, target_img;</span><br><span class="line">  ret = source_img.<span class="built_in">LoadFromBmp</span>(<span class="string">&quot;d:/source.bmp&quot;</span>);</span><br><span class="line">  <span class="built_in">XASSERT</span>(XOK == ret);</span><br><span class="line">  ret = ref_img.<span class="built_in">LoadFromBmp</span>(<span class="string">&quot;d:/reference.bmp&quot;</span>);</span><br><span class="line">  <span class="built_in">XASSERT</span>(XOK == ret);</span><br><span class="line">  ret = source_img.<span class="built_in">LinearOperation</span>(ref_img, target_img, XImageLinearOpt, <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">XASSERT</span>(XOK == ret);</span><br><span class="line">  target_img.<span class="built_in">SaveToBmp</span>(<span class="string">&quot;d:/linear_opt.bmp&quot;</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>图像特征？？</title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%9B%BE%E5%83%8F%E7%89%B9%E5%BE%81%EF%BC%9F%EF%BC%9F/%E5%9B%BE%E5%83%8F%E7%89%B9%E5%BE%81%EF%BC%9F%EF%BC%9F/</url>
    <content><![CDATA[<p>自然特征：图像内容本身包含的信息：大小、色彩分布、轮廓、边缘梯度、纹理等<br>人为特征：人为挖掘出来认定有用的信息（统计特征）：色彩直方图、矩特征、熵等</p>
<h2 id="颜色特征"><a href="#颜色特征" class="headerlink" title="颜色特征"></a><strong>颜色特征</strong></h2><p><strong>颜色直方图</strong>：相似图像具有相似的直方图信息<br>1）计算图像标准直方图<br>2）<strong>计算直方图数据的欧式距离</strong><br>3）<strong>设置阈值：</strong> 定义一个阈值，欧式距离小于该阈值时，认为相似</p>
<p>？？？<strong>2、图像颜色矩</strong>。颜色矩是一种简单有效的颜色特征标记方法。一阶矩(均值,mean)、二阶矩(方差,variance)和三阶矩(斜度,skewness)等，由于颜色信息主要分布于低阶矩中，所以用一阶矩，二阶矩和三阶矩足以表达图像的颜色分布，颜色矩已证明可有效地表示图像中的颜色分布。 对于RGB颜色空间的图像，i&#x3D;1，2，3，下面的Ei、δi、Si 表示第i个通道上的一阶颜色矩，Pij表示第j个像素的第i个通道上的颜色值。</p>
<p>一阶颜色矩采用一阶原点矩，反映图像的整体明暗程度。</p>
<p><img src="https://pic2.zhimg.com/80/v2-2224ddeb6e58868801ec44e6c965a345_720w.webp"></p>
<p>一阶颜色矩</p>
<p>二阶颜色矩采用二阶中心距的平方根，反映图像颜色的分布范围</p>
<p><img src="https://pic4.zhimg.com/80/v2-4db53e6e84afb3097b4d138c33b06ddb_720w.webp"></p>
<p>二阶颜色矩</p>
<p>三阶颜色矩采用三阶中心距的立方根，反映图像颜色分布的对称性</p>
<p><img src="https://pic1.zhimg.com/80/v2-5f8a3d9583a9ac3a912ea7b2315a3988_720w.webp"></p>
<p>三阶颜色矩</p>
<p><strong>3、颜色聚合向量（CCV）</strong>。 针对颜色直方图和颜色矩无法表达图像色彩的空间位置的缺点，Pass[9]提出了图像的颜色聚合向量（color coherence vector）。它是颜色直方图的一种演变，其核心思想是将属于直方图每一个bin的像素进行分为两部分：如果该bin内的某些像素所占据的连续区域的面积大于给定的阈值，则该区域内的像素作为<strong>聚合像素</strong>；否则作为<strong>非聚合像素</strong>。假设αi与βi分别代表直方图的第i个bin中聚合像素和非聚合像素的数量，图像的颜色聚合向量可以表达为&lt;(α1, β1), (α2, β2), …, (αN, βN)&gt;。而&lt;α1+ β1, α2 + β2, …, αN +βN &gt; 就是该图像的颜色直方图。由于包含了颜色分布的空间信息，颜色聚合向量相比颜色直方图可以达到更好的检索效果。</p>
<p>算法具体过程：</p>
<p>1）平滑滤波。通常使用3*3的模板进行平滑滤波。</p>
<p>2）量化。把0-255的颜色区间量化为n个颜色区间,通常采用均匀量化。</p>
<p>3）划分连通区域（每一个连通区域只有一个灰度值）。</p>
<p>4）计算颜色聚合向量。可以参考 <a href="https://link.zhihu.com/?target=https://blog.csdn.net/u014655590/article/details/25108297" title="颜色聚合向量（CCV）_u014655590的专栏-CSDN博客_颜色聚合向量">颜色聚合向量（CCV）_u014655590的专栏-CSDN博客_颜色聚合向量</a></p>
<p>每一个灰度级i(也就是直方图的每一个bin)有两部分组成(Ci and Ni)；</p>
<p>Ci是聚合像素的个数(灰度值为i的所有大连通区域像素之和)；</p>
<p>Ni是非聚合像素的个数(灰度值为i的所有小连通区域像素之和)；</p>
<p>&lt;Ci+Ni&gt;是灰度级为i的像素之和。</p>
<p>该图像的颜色聚合向量可表示为：CCV&#x3D;&lt;(C1,N1)、(C2,N2)、(C3,N3)、…..(Cn,Nn)&gt;</p>
<p>颜色直方图可表示为：HIST&#x3D;&lt;(C1+N1)、(C2+N2)、(C3+N3)、…..(Cn+Nn)&gt;</p>
<p>可以这样理解，CCV有两个直方图组成：一个直方图统计聚合的像素。一个直方图统计非聚合的像素。</p>
<p>在进行图像匹配操作时，可以直接计算其欧式几何距离。</p>
<p>假设：图像IMG1的颜色聚合向量：CCV1&#x3D;&lt;(C1,N1)、(C2,N2)、(C3,N3)、…..(Cn,Nn)&gt;；图像img2的颜色聚合向量：ccv2&#x3D;&lt;(c1,n1)、(c2,n2)、(c3,n3)、…..(cn,nn)&gt;。那么图像IMG1与图像img2的距离：</p>
<p><img src="https://pic1.zhimg.com/80/v2-f02f4b2e30a2d44caed03ddd6f453b30_720w.webp"></p>
<p><strong>4、频域哈希感知指纹</strong>。 在进行大量图像快速匹配时，对于数据运算性能要求比较高，在这种场景下可以降低一定的匹配精度，减小特征提取的计算量，有一种哈希感知算法（该算法google在进行搜索图像识别预处理的时候使用）来提取图像指纹特征，从而进行快速图像匹配。具体算法步骤：</p>
<p>1）将图像尺寸缩小到 32*32像素大小， 这一步的作用是去除各种图片尺寸和图片比例的差异, 只保留结构、明暗等基本信息。</p>
<p>2）图像转换为灰度图像，只保留明暗灰度信息。</p>
<p>3）进行DCT变换，DCT变换后只保留左上角8*8像素的1&#x2F;4矩阵数据。左上角是DCT变换后的低频信息，也即保留了图像的最基本的细节信息。</p>
<p>4）计算这 8*8&#x3D;64个 DCT系数的评价值。</p>
<p>5）将每个像素的灰度与DCT系数平均值进行比较, 如果大于或等于平均值记为1, 小于平均值记为0，结果组合在一起就构成了一个64位的二进制整数, 这就是这张图片的频域指纹。这样一张图像只需要8个字节即可表示其指纹特征信息。</p>
<p>在图像频域指纹进行匹配时，直接进行与运算，计算出64位中有多少位是不一样的。设定一个阈值（例如：5），如果不相同的数据位数不超过阈值，就说明两张图片相似，反之则不相似。</p>
<p>采用频域哈希感知算法，可以快速的计算图像的指纹特征，并且指纹匹配比较也非常快速，这种算法在一些图像分类、检索的场景中，可以用于预处理先过滤一部分图像。而在实际的应用场景中，特别是图像内容差距不是非常显著的情况下，精度不高，但好在计算迅速。</p>
<h2 id="统计特征"><a href="#统计特征" class="headerlink" title="统计特征"></a><strong>统计特征</strong></h2><p>矩是概率与统计中的一个概念，是随机变量的一种数字特征。在统计特征方面通常使用图像矩来表示图像特征。</p>
<p><strong>1、普通矩</strong>。</p>
<p><strong>零阶矩</strong>：图像灰度的总和。</p>
<p><img src="https://pic2.zhimg.com/80/v2-97b93229567360cdf5a4fdb7fc52d885_720w.webp"></p>
<p><strong>一阶矩</strong>： m10和m01表示用来确定图像的灰度中心</p>
<p><img src="https://pic3.zhimg.com/80/v2-99464e02476e48ca16bb9eead9dfc2ca_720w.webp"></p>
<p><strong>二阶矩</strong>：有三个，m11 m02 m20，也成为惯性矩。它们可以确定物体的几个特性：</p>
<p>1）二阶中心矩用来确定目标物体的主轴，长轴和短轴分别对应最大和最小的二阶中心矩。可以计算主轴方向角。</p>
<p>2）图像椭圆：由一阶、二阶矩可以确定一个与原图像惯性等价的图像椭圆。所谓图像椭圆是一个与原图像的二阶矩及原图像的灰度总和均相等的均匀椭圆。使得主轴与图像的主轴方向重合，一边分析图像性质。</p>
<p><img src="https://pic4.zhimg.com/80/v2-d72c3f355be39896075b039d79767e4f_720w.webp"></p>
<p><strong>三阶矩</strong>：投影扭曲，描述了图像投影的扭曲程度。扭曲是一个经典统计量,用来衡量关于均值对称分布的偏差程度。</p>
<p><strong>四阶矩</strong>：投影峰度，峰度是一个用来测量分布峰度的经典统计量。可以计算峰度</p>
<p><strong>2、Hu矩</strong>。图像的hu矩是一种具有平移、旋转和尺度不变性的图像特征。</p>
<p><img src="https://pic1.zhimg.com/80/v2-8c6bb8b4cfe569fc14105ee3123d9d9c_720w.webp"></p>
<p>Hu矩利用二阶和三阶规格中心矩可以导出下面7个不变矩组(Φ1 Φ7)，它们在图像平移、旋转和比例变化时保持不变</p>
<p><img src="https://pic2.zhimg.com/80/v2-4736e182439e4ff1e6ea20ec3f6c8cc1_720w.webp"></p>
<h2 id="神经网络特征"><a href="#神经网络特征" class="headerlink" title="神经网络特征"></a><strong>神经网络特征</strong></h2><p>最常用的是使用卷积神经网络(CNN)来提取图像特征，这是目前主要使用的主流方式，本章节不做详细描述，在后续的系列文章中转码讲解。</p>
<p><strong>总结</strong></p>
<p>图像特征提取的算法有很多，从传统的图像矩、颜色特征等方式、到基于机器学习的SIFT、SURF、再到最新的CNN等方式，提取图像的特征也越来越精确，同时相应的数据运算量也逐渐变大，在实际项目中可以根据自己的需求来选择合适的特征提取方式。</p>
]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>常见量化方式（像素节点）</title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%B8%B8%E8%A7%81%E9%87%8F%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%88%E5%83%8F%E7%B4%A0%E8%8A%82%E7%82%B9%EF%BC%89/%E5%B8%B8%E8%A7%81%E9%87%8F%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%88%E5%83%8F%E7%B4%A0%E8%8A%82%E7%82%B9%EF%BC%89/</url>
    <content><![CDATA[<h1 id="灰度图像："><a href="#灰度图像：" class="headerlink" title="灰度图像："></a>灰度图像：</h1><ul>
<li>单色图片一般仅用8位无符号整数(256级)存储灰度值，即像素I取值范围通常为[ 0 , 255 ] ；无颜色信息<br>0”表示纯黑色，“255”表示纯白色；</li>
</ul>
<p><img src="/image/image_oWCx8KOGzu.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 灰度图像数据结构；内存占用字节数 = 图像宽度 * 图像高度 * 每个像素占用字节</span></span><br><span class="line"><span class="type">int</span> nPxlBytes = <span class="number">1</span>;<span class="comment">//像素灰度信息占用字节数</span></span><br><span class="line"><span class="type">int</span> nBufSize = nImgWidth * nImgHeight * nPxlBytes; </span><br><span class="line"><span class="type">uint8_t</span>  *pGrayBuffer = (<span class="type">uint8_t</span>*)<span class="built_in">malloc</span>(nBufSize);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于(x,y) 像素点的访问：访问地址=基地址+偏移量=基地址+(size-1)=基地址+（y行*宽度*字节大小）+（(x列+1)*字节大小-字节大小）</span></span><br><span class="line"><span class="type">uint8_t</span>  *pPixelData = pGrayBuffer + (nImgWidth * y * nPxlBytes) + (x * nPxlBytes);</span><br><span class="line">pPixelData[<span class="number">0</span>] = <span class="number">128</span>;  <span class="comment">// 将 (x,y)像素点的灰度值设置为128，中等灰度 </span></span><br></pre></td></tr></table></figure>

<ul>
<li>二值图像：灰度值只由0、1两个值构成，“0”代表黑色，“1”代表白色。二值图像可以看成是灰度图像的特例。</li>
</ul>
<h1 id="彩色图像"><a href="#彩色图像" class="headerlink" title="彩色图像:"></a>彩色图像:</h1><h2 id="x20-RGB模型："><a href="#x20-RGB模型：" class="headerlink" title="&#x20;RGB模型："></a>&#x20;RGB模型：</h2><p>大多数彩色可用红（R）、绿（G）、蓝（B）三基色混合产生；<br>以三通道组合（R,G,B）表示像素的颜色信息（光强，波长综合信息）。R、G、B三分量一般用3个连续的8位无符号整型表示；故RGB通道的3个字节总计可表示 256*<em>256</em>*256&#x3D;16777216种颜色。</p>
<p><img src="https://img-blog.csdnimg.cn/2020031514263580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU3MjY1Ng==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p><img src="/image/image__je4oZQr39.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内存占用字节数 = 图像宽度 * 图像高度 * 每个像素占用字节</span></span><br><span class="line"><span class="type">int</span> nPxlBytes = <span class="number">3</span>;   <span class="comment">// 每个像素占用3个字节</span></span><br><span class="line"><span class="type">int</span> nBufSize = nImgWidth * nImgHeight * nPxlBytes; </span><br><span class="line"><span class="type">uint8_t</span>  *pRgbBuffer = (<span class="type">uint8_t</span>*)<span class="built_in">malloc</span>(nBufSize);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于(x,y) 像素点的颜色值访问</span></span><br><span class="line"><span class="type">uint8_t</span>  *pPixelData = pRgbBuffer + (nImgWidth * y * nPxlBytes) + (x * nPxlBytes);</span><br><span class="line">pPixelData[<span class="number">0</span>] = <span class="number">128</span>;  <span class="comment">// 将 (x,y)像素点的颜色值设置为 RGB(128, 255, 64)</span></span><br><span class="line">pPixelData[<span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">pPixelData[<span class="number">2</span>] = <span class="number">64</span>;</span><br></pre></td></tr></table></figure>

<p>有些设备上有时会有其他的色彩通道排布方式。例如：BGR格式</p>
<p><img src="/image/image_5XyoyCoXLM.png"></p>
<p>多张图像重叠显示的两种情况1）遮罩：上层的图像完全遮挡下层图像显示2）带透明度显示：隐约看到下层图像</p>
<p>重叠区域要将两张图片做显示程度叠加运算，基本混合算法公式: *<em>dest &#x3D; srcUp * alpha + srcDn (1.0-alpha)</em> ；alpha就是上层图像的透明度。在实际进行运算操作时，每个像素的三个色彩通道分别独立的按公式计算显示像素颜色。</p>
<p><img src="https://pic3.zhimg.com/80/v2-19fa7bb77da5804467b8286a0e175a02_1440w.webp"></p>
<p>*alpha *<strong>用一个8位u_int存储；构成了4元排列 RGBA</strong>或者<strong>BGRA</strong> 像素格式</p>
<h2 id="CMYK模型："><a href="#CMYK模型：" class="headerlink" title="CMYK模型："></a>CMYK模型：</h2><p>CMYK颜色模型包括青(cyan)、品红(magenta)、黄(yellow)和黑(black)，为避免与蓝色混淆，黑色用K表示。青、品红、黄分别是红、绿、蓝三基色的互补色。彩色打印、印刷等应用领域采用打印墨水、彩色涂料的反射光来显现颜色，是一种减色方式。 彩色打印机和彩色印刷都是采用这个原理。由于彩色墨水和颜料的化学特性，用等量的三种基色得到的黑色不是真正的黑色，因此在印刷术中加入一种真正的黑色，所以通常把CMY模型写成CMYK。 &#x20;</p>
<p><img src="https://img-blog.csdnimg.cn/20200315142356135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU3MjY1Ng==,size_16,color_FFFFFF,t_70#pic_center"></p>
<h2 id="HSI（HSV）模型：-（-theta-r-z）"><a href="#HSI（HSV）模型：-（-theta-r-z）" class="headerlink" title="HSI（HSV）模型：$（\theta,r,z）$"></a>HSI（HSV）模型：$（\theta,r,z）$</h2><p>HSI色彩系统中，每个像素点的颜色使用：色调(Hue)、饱和度(Saturation) 和 亮度 (Intensity) 3元排列描述</p>
<p><strong>色调(Hue)</strong>: 表示颜色的相位角，是彩色最重要的属性，决定颜色的类别。色调可以用一个标准圆的角度来表示，红色是0度，绿色是120度、蓝色是240度，相互之间分别相隔120度。简单来说表示是蓝色还是红色色或者绿色<br>**饱和度(Saturation)**：表示颜色的深浅程度，饱和度越高（半径越长），颜色越深；<br>**亮度(Intensity)**：表示色彩的明亮程度（高度） &#x20;</p>
<p><img src="/image/image_Aaf_njl9Jy.png"></p>
<p><img src="https://img-blog.csdnimg.cn/20200302213549837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU3MjY1Ng==,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>HSI 和R GB的色彩坐标系换算$（\theta,r,z）\rightleftharpoons(R,G,B)$，不同的换算算法也有不同的换算公式。</p>
<p><img src="/image/image_70NzSiUckO.png"></p>
<p>&#x20;HSI toRGB:</p>
<p><img src="/image/image_FLhn73CnzM.png"></p>
<p>转换公式中 RGB值是归一化的值，在[0.0, 1.0]范围内，色调H可以用得到的值除以360归一化，其他饱和度和亮度两个分量也归一化在[0.0, 1.0]范围内<br>&#x20;两个相似的概念：HSI和HSV空间。HSV里面的V指的是RGB里面的最大值，v &#x3D; m a x ( r , g , b ) ；而HSI的I是平均值，I &#x3D; ( r + g + b ) &#x2F; 3&#x20;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RGB ==&gt; HSI转换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConvertRgbToHsi</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">double_t</span> R,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">double_t</span> G,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">double_t</span> B,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">double_t</span>&amp; hue,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">double_t</span>&amp; saturation,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">double_t</span>&amp; illumine    )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">double_t</span> mx, mi, th;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (R &gt; G &amp;&amp; R &gt; B)</span><br><span class="line">  &#123;</span><br><span class="line">    mx = R;</span><br><span class="line">    mi = <span class="built_in">MIN</span>(G, B);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (G &gt; B) &#123;</span><br><span class="line">      mx = G;</span><br><span class="line">      mi = <span class="built_in">MIN</span>(R, B);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     mx = B;</span><br><span class="line">     mi = <span class="built_in">MIN</span>(R, G);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  illumine = (R + G + B) / <span class="number">3.0</span>;</span><br><span class="line">  <span class="keyword">if</span> (illumine &lt; <span class="number">0</span>)  </span><br><span class="line">    illumine = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (illumine &gt; <span class="number">1.0</span>) </span><br><span class="line">    illumine = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (illumine == <span class="number">0</span> || mx == mi) </span><br><span class="line">  &#123;</span><br><span class="line">    saturation = <span class="number">0</span>;</span><br><span class="line">    hue = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    saturation = <span class="number">1</span> - mi / illumine;</span><br><span class="line">    th = (R - G) * (R - G) + (R - B) * (G - B);</span><br><span class="line">    th = <span class="built_in">sqrt</span>(th) + <span class="number">1e-5</span>;</span><br><span class="line">    th = <span class="built_in">acos</span>(((R - G + R - B)*<span class="number">0.5</span>) / th);</span><br><span class="line">    <span class="keyword">if</span> (G &gt;= B) </span><br><span class="line">      hue = th;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      hue = <span class="number">2.0</span> * X_PI - th;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hue = hue / X_2PI;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HSI ==&gt; RGB转换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConvertHsiToRgb</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">double_t</span> hue,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">double_t</span> saturation,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">double_t</span> illumine,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">double_t</span>&amp; R,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">double_t</span>&amp; G,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">double_t</span>&amp; B      )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">double_t</span> preh = hue * X_2PI;  <span class="comment">// H</span></span><br><span class="line">  <span class="type">double_t</span> pres = saturation;    <span class="comment">// S</span></span><br><span class="line">  <span class="type">double_t</span> prei = illumine;       <span class="comment">// I</span></span><br><span class="line">  <span class="type">double_t</span> t1, t2, t3;</span><br><span class="line"></span><br><span class="line">  t1 = (<span class="number">1.0</span> - pres) / <span class="number">3.0</span>;</span><br><span class="line">  <span class="keyword">if</span> (preh &gt;= <span class="number">0</span> &amp;&amp; preh &lt; (X_2PI / <span class="number">3</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    B = t1;</span><br><span class="line">    t2 = pres * <span class="built_in">cos</span>(preh);</span><br><span class="line">    t3 = <span class="built_in">cos</span>(X_PI / <span class="number">3</span> - preh);</span><br><span class="line">    R = (<span class="number">1</span> + t2 / t3) / <span class="number">3</span>;</span><br><span class="line">    R = <span class="number">3</span> * prei * R;</span><br><span class="line">    B = <span class="number">3</span> * prei * B;</span><br><span class="line">    G = <span class="number">3</span> * prei - (R + B);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (preh &gt;= (X_2PI / <span class="number">3</span>) &amp;&amp; preh &lt; (X_PI * <span class="number">4</span> / <span class="number">3</span>)) &#123;</span><br><span class="line">    R = t1;</span><br><span class="line">    t2 = pres * <span class="built_in">cos</span>(preh - X_2PI / <span class="number">3</span>);</span><br><span class="line">    t3 = <span class="built_in">cos</span>(X_PI - preh);</span><br><span class="line">    G = (<span class="number">1</span> + t2 / t3) / <span class="number">3</span>;</span><br><span class="line">    R = <span class="number">3</span> * prei * R;</span><br><span class="line">    G = <span class="number">3</span> * G * prei;</span><br><span class="line">    B = <span class="number">3</span> * prei - (R + G);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (preh &gt;= (X_PI * <span class="number">4</span> / <span class="number">3</span>) &amp;&amp; preh &lt;= X_2PI) &#123;</span><br><span class="line">    G = t1;</span><br><span class="line">    t2 = pres * <span class="built_in">cos</span>(preh - <span class="number">4</span> * X_PI / <span class="number">3</span>);</span><br><span class="line">    t3 = <span class="built_in">cos</span>(X_PI * <span class="number">5</span> / <span class="number">3</span> - preh);</span><br><span class="line">    B = (<span class="number">1</span> + t2 / t3) / <span class="number">3</span>;</span><br><span class="line">    G = <span class="number">3</span> * G * prei;</span><br><span class="line">    B = <span class="number">3</span> * prei * B;</span><br><span class="line">    R = <span class="number">3</span> * prei - (G + B);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 调节明度-色调-饱和度</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">XImage::AdjustHsi</span><span class="params">(XImage&amp; out_img)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  out_img.<span class="built_in">Release</span>( );</span><br><span class="line">  <span class="type">int32_t</span> res = out_img.<span class="built_in">Allocate</span>(pxl_format_, width_, height_);</span><br><span class="line">  <span class="keyword">if</span> (res != XOK)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">XOS_ERROR</span>(TAG_IMGENG, <span class="string">&quot;&lt;XImage.Convert&gt; fail to allocate image, fmt=%d, w=%d, h=%d&quot;</span>,</span><br><span class="line">      pxl_format_, width_, height_ );</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span>* src_line = image_data_;</span><br><span class="line">  <span class="type">uint8_t</span>* dst_line = out_img.image_data_;</span><br><span class="line">  <span class="type">int32_t</span> x, y;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; height_; y++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">uint8_t</span>* src_data = src_line;</span><br><span class="line">    <span class="type">uint8_t</span>* dst_data = dst_line;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; width_; x++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">double_t</span> R, G, B;</span><br><span class="line">      <span class="type">double_t</span> hue, saturation, illumine;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Convert RGB --&gt; HSI</span></span><br><span class="line">      B = (<span class="type">double_t</span>)(src_data[<span class="number">0</span>]) / <span class="number">255.0</span>;</span><br><span class="line">      G = (<span class="type">double_t</span>)(src_data[<span class="number">1</span>]) / <span class="number">255.0</span>;</span><br><span class="line">      R = (<span class="type">double_t</span>)(src_data[<span class="number">2</span>]) / <span class="number">255.0</span>;</span><br><span class="line">      <span class="built_in">ConvertRgbToHsi</span>(R, G, B, hue, saturation, illumine);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这里可以分别对 hue-saturation-illumine 进行调节</span></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">      <span class="comment">// Convert HSI --&gt; RGB</span></span><br><span class="line">      <span class="built_in">ConvertHsiToRgb</span>(hue, saturation, illumine, R, G, B);</span><br><span class="line">      B *= <span class="number">255.0</span>;</span><br><span class="line">      G *= <span class="number">255.0</span>;</span><br><span class="line">      R *= <span class="number">255.0</span>;</span><br><span class="line">      <span class="keyword">if</span> (B &lt; <span class="number">0</span>)  B = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (B &gt; <span class="number">255.0</span>)  B = <span class="number">255.0</span>;</span><br><span class="line">      <span class="keyword">if</span> (G &lt; <span class="number">0</span>)  G = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (G &gt; <span class="number">255.0</span>)  G = <span class="number">255.0</span>;</span><br><span class="line">      <span class="keyword">if</span> (R &lt; <span class="number">0</span>)  R = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (R &gt; <span class="number">255.0</span>)  R = <span class="number">255.0</span>;</span><br><span class="line">      dst_data[<span class="number">0</span>] = (<span class="type">uint8_t</span>)(B);</span><br><span class="line">      dst_data[<span class="number">1</span>] = (<span class="type">uint8_t</span>)(G);</span><br><span class="line">      dst_data[<span class="number">2</span>] = (<span class="type">uint8_t</span>)(R);</span><br><span class="line"></span><br><span class="line">      src_data += pixel_bytes_;</span><br><span class="line">      dst_data += pixel_bytes_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    src_line += line_bytes_;</span><br><span class="line">    dst_line += line_bytes_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> XOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="YUV模型"><a href="#YUV模型" class="headerlink" title="YUV模型"></a>YUV模型</h2><p><a href="https://zhuanlan.zhihu.com/p/259904996" title=" 图像算法原理与实践——基础知识之 色彩表示模型 一、人眼视觉系统和图像形成在实际物理条件下，图像都是由图像照射源和在各个场景下各物体对照射光源形成的反射部分构成。这些光源本身是由光线频谱来表达，不同的频谱显示出不同的颜色效果。当用数学方法描述图像… https://zhuanlan.zhihu.com/p/259904996"> 图像算法原理与实践——基础知识之 色彩表示模型 一、人眼视觉系统和图像形成在实际物理条件下，图像都是由图像照射源和在各个场景下各物体对照射光源形成的反射部分构成。这些光源本身是由光线频谱来表达，不同的频谱显示出不同的颜色效果。当用数学方法描述图像… https://zhuanlan.zhihu.com/p/259904996</a></p>
]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>空间域直方图处理</title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%A4%84%E7%90%86/%E7%A9%BA%E9%97%B4%E5%9F%9F%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>图像整体明暗程度（对比度）由灰度值分布情况决定，低灰度值像素所占比例比较高，图像整体色调偏暗；高灰度值像素所占比例较高，图像整体比较明亮。灰度值像素所占比例可用灰度值分布图表示；<br>对于彩色图像，R、G、B三个通道的直方图需要分别单独计算</p>
<h1 id="通道值分布频率计算"><a href="#通道值分布频率计算" class="headerlink" title="通道值分布频率计算"></a>通道值分布频率计算</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算图像的直方图</span></span><br><span class="line"><span class="comment">// out_Histogram -- 输出三个通道的直方图</span></span><br><span class="line"><span class="comment">// out_normal_Histogram -- 输出归一化到[0.0~1.0]之间的直方图</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">XImage::ParseHistogram</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">int32_t</span>  out_histogram[<span class="number">3</span>][<span class="number">256</span>],<span class="comment">//输出直方图</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">float</span>   out_normal_histogram[<span class="number">3</span>][<span class="number">256</span>]  )</span><span class="comment">//归一化直方图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">uint8_t</span>* src_line = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="type">uint8_t</span>* src_data = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="type">int32_t</span>  i, j;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!image_valid_)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> XERR_BAD_STATE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)<span class="comment">//初始化</span></span><br><span class="line">  &#123;</span><br><span class="line">    out_histogram[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    out_histogram[<span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">    out_histogram[<span class="number">2</span>][i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">1</span> == pixel_bytes_) <span class="comment">// 灰度图遍历像素值，再对应值索引处+1</span></span><br><span class="line">  &#123;</span><br><span class="line">    src_line = image_data_;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; height_; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      src_data = src_line;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; width_; j++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">uint8_t</span> gray = src_data[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对应通道的像素个数分别增加,灰度图三个通道值一样</span></span><br><span class="line">        out_histogram[<span class="number">0</span>][gray]++;</span><br><span class="line">        out_histogram[<span class="number">1</span>][gray]++;</span><br><span class="line">        out_histogram[<span class="number">2</span>][gray]++;</span><br><span class="line"></span><br><span class="line">        src_data += pixel_bytes_;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      src_line += line_bytes_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="comment">// 彩色图</span></span><br><span class="line">  &#123;</span><br><span class="line">    src_line = image_data_;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; height_; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      src_data = src_line;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; width_; j++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">uint8_t</span> r = src_data[<span class="number">0</span>];</span><br><span class="line">        <span class="type">uint8_t</span> g = src_data[<span class="number">1</span>];</span><br><span class="line">        <span class="type">uint8_t</span> b = src_data[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对应通道的像素个数分别增加</span></span><br><span class="line">        out_histogram[<span class="number">0</span>][r]++;</span><br><span class="line">        out_histogram[<span class="number">1</span>][g]++;</span><br><span class="line">        out_histogram[<span class="number">2</span>][b]++;</span><br><span class="line"></span><br><span class="line">        src_data += pixel_bytes_;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      src_line += line_bytes_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将比例归一化到 [0.0, 1.0] 区间</span></span><br><span class="line">  <span class="type">float</span> pixel_count = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(width_ * height_);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    out_normal_histogram[<span class="number">0</span>][i] = (<span class="type">float</span>)(out_histogram[<span class="number">0</span>][i]) / pixel_count;<span class="comment">//次数换算成频率</span></span><br><span class="line">    out_normal_histogram[<span class="number">1</span>][i] = (<span class="type">float</span>)(out_histogram[<span class="number">0</span>][i]) / pixel_count;</span><br><span class="line">    out_normal_histogram[<span class="number">2</span>][i] = (<span class="type">float</span>)(out_histogram[<span class="number">0</span>][i]) / pixel_count;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> XOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="直方图均衡化原理"><a href="#直方图均衡化原理" class="headerlink" title="直方图均衡化原理"></a><strong>直方图均衡化原理</strong></h1><p>灰度直方图&#x3D;以灰度级为随机变量的概率密度函数图；增加对比度的一个方法：将连续的归一化灰度随机变量变为一致分布；其满足约束：变换前后其累积分布值一致：<br>⇒$E<em>y&#x3D;\int_{-\infty}^{x}f(x)dx;期望E&#x3D;1&#x2F;1&#x3D;1$<br>⇒$y&#x3D;255</em>\int_{-\infty}^{x}f(x)dx$即灰度均衡化算子<br>而其离散运算版本的算子是：y&#x3D;T(x)&#x3D;$\lim_{\lambda  \to \infty}  255<em>\sum_{0}^{x} f(\xi_i )\frac{1}{\lambda}$&#x3D;  $ 255</em>\sum_{0}^{x}h(x)&#x2F;(w*h)  $</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 直方图均衡化处理</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">XImage::HistogramEqualize</span><span class="params">(<span class="type">int32_t</span> histogram[<span class="number">3</span>][<span class="number">256</span>], XImage&amp; out_img)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int32_t</span> i, j, ret;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!image_valid_)  &#123;</span><br><span class="line">    <span class="keyword">return</span> XERR_BAD_STATE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">IsSameParameter</span>(out_img))</span><br><span class="line">  &#123;</span><br><span class="line">    out_img.<span class="built_in">Release</span>( );</span><br><span class="line">    ret = out_img.<span class="built_in">Allocate</span>(pxl_format_, width_, height_);</span><br><span class="line">    <span class="built_in">XASSERT</span>(ret == XOK);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 计算分布变换函数(也就是变换函数f(x))</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="type">uint8_t</span> color_map[<span class="number">3</span>][<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//定义一个二维数组用于存储R、G、B三个通道的映射值</span></span><br><span class="line">  <span class="type">int32_t</span> pixel_sum[<span class="number">3</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//定义一个数组用于存储R、G、B三个通道的像素累计值。</span></span><br><span class="line">  <span class="type">int32_t</span> pixel_count = width_ * height_;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>;  i++)<span class="comment">//计算i灰度级(即x)的映射值</span></span><br><span class="line">  &#123;</span><br><span class="line">    pixel_sum[<span class="number">0</span>] += histogram[<span class="number">0</span>][i];<span class="comment">//累积像素</span></span><br><span class="line">    pixel_sum[<span class="number">1</span>] += histogram[<span class="number">1</span>][i];</span><br><span class="line">    pixel_sum[<span class="number">2</span>] += histogram[<span class="number">2</span>][i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> map_r = <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(pixel_sum[<span class="number">0</span>] * <span class="number">255</span> / pixel_count);<span class="comment">//映射值</span></span><br><span class="line">    <span class="type">int32_t</span> map_g = <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(pixel_sum[<span class="number">1</span>] * <span class="number">255</span> / pixel_count);</span><br><span class="line">    <span class="type">int32_t</span> map_b = <span class="built_in">static_cast</span>&lt;<span class="type">int32_t</span>&gt;(pixel_sum[<span class="number">2</span>] * <span class="number">255</span> / pixel_count);</span><br><span class="line">    <span class="keyword">if</span> (map_r &lt; <span class="number">0</span>)    map_r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (map_r &gt; <span class="number">255</span>)  map_r = <span class="number">255</span>;</span><br><span class="line">    <span class="keyword">if</span> (map_g &lt; <span class="number">0</span>)    map_g = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (map_g &gt; <span class="number">255</span>)  map_g = <span class="number">255</span>;</span><br><span class="line">    <span class="keyword">if</span> (map_b &lt; <span class="number">0</span>)    map_b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (map_b &gt; <span class="number">255</span>)  map_b = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">    color_map[<span class="number">0</span>][i] = map_r;</span><br><span class="line">    color_map[<span class="number">1</span>][i] = map_g;</span><br><span class="line">    color_map[<span class="number">2</span>][i] = map_b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 对灰度图像进行直方图均衡化变换处理</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="type">uint8_t</span>* src_line = image_data_;<span class="comment">//定义一个指针，指向源图像的第一行</span></span><br><span class="line">  <span class="type">uint8_t</span>* dst_line = out_img.image_data_;<span class="comment">//定义一个指针，指向输出图像的第一行</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; height_; i++)  </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">uint8_t</span>* src_data = src_line;</span><br><span class="line">    <span class="type">uint8_t</span>* dst_data = dst_line;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; width_; j++)<span class="comment">//遍历像素，变换值</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">1</span> == pixel_bytes_)</span><br><span class="line">      &#123;</span><br><span class="line">        dst_data[<span class="number">0</span>] = color_map[<span class="number">0</span>][src_data[<span class="number">0</span>]];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        dst_data[<span class="number">0</span>] = color_map[<span class="number">0</span>][src_data[<span class="number">0</span>]];</span><br><span class="line">        dst_data[<span class="number">1</span>] = color_map[<span class="number">1</span>][src_data[<span class="number">1</span>]];</span><br><span class="line">        dst_data[<span class="number">2</span>] = color_map[<span class="number">2</span>][src_data[<span class="number">2</span>]];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      src_data += pixel_bytes_;</span><br><span class="line">      dst_data += out_img.pixel_bytes_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    src_line += line_bytes_;</span><br><span class="line">    dst_line += out_img.line_bytes_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> XOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="彩色图像的直方图均衡化"><a href="#彩色图像的直方图均衡化" class="headerlink" title="彩色图像的直方图均衡化"></a><strong>彩色图像的直方图均衡化</strong></h1><p>直接对3通道均衡化会损失色调信息；<br>将 RGB色彩格式转换未 HSI格式，然后<strong>仅对于其中的I通道（Intensity）进行直方图均衡化</strong>，之后再将调节后的 HSI格式变换回RGB格式</p>
<p>直方图均衡化缺陷？局部均衡化</p>
]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>腐蚀、膨胀、开运算、闭运算</title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E8%85%90%E8%9A%80%E3%80%81%E8%86%A8%E8%83%80%E3%80%81%E5%BC%80%E8%BF%90%E7%AE%97%E3%80%81%E9%97%AD%E8%BF%90%E7%AE%97/%E8%85%90%E8%9A%80%E3%80%81%E8%86%A8%E8%83%80%E3%80%81%E5%BC%80%E8%BF%90%E7%AE%97%E3%80%81%E9%97%AD%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>S为处理后的二值图像集合${(x,y)\in S}$<br>B为形态学模板<br>X为原图二值化后像素集合${(x,y)\in X}$</p>
<h2 id="腐蚀"><a href="#腐蚀" class="headerlink" title="腐蚀"></a>腐蚀</h2><p>向内收缩边界，连接中断，平滑边界突起；<br>B被X包括的情况的B位置集合</p>
<p><img src="/image/image_YosUQPA1x9.png"></p>
<p>1）遍历元素<br>2）每个元素遍历模板；判断模板是包含，击中，还是未击中；<br>3)包含则&#x3D;1，未击中和击中&#x3D;0（在此例中为赋值检测到的最小通道值）<br>$\mathsf{dst}(x,y)&#x3D;\min_{(x,y)∈待处理图片;(x^{\prime},y^{\prime})∈模板}{\mathsf{src}(x+x^{\prime},y+y^{\prime})}$；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 功能: 使用 wnd_size*wnd_size 大小的模板进行腐蚀操作</span></span><br><span class="line"><span class="comment">// 参数: template_data: wnd_size*wn_size大小的掩码模板, 值为1表示相应像素参与计算</span></span><br><span class="line"><span class="comment">//       wnd_size : 模板窗口大小</span></span><br><span class="line"><span class="comment">//       out_img : 输出图像数据</span></span><br><span class="line"><span class="comment">// 返回: 错误码</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">XImage::Corrode</span><span class="params">(<span class="type">int32_t</span>* template_data, <span class="type">int32_t</span> wnd_size, XImage&amp; out_img)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//初始化参数以及检查</span></span><br><span class="line">  <span class="type">int32_t</span>   template_size = wnd_size * wnd_size;  <span class="comment">// 模板元素数量</span></span><br><span class="line">  <span class="type">int32_t</span>   half_wnd_size = wnd_size / <span class="number">2</span>;          <span class="comment">// 半个窗口的宽高</span></span><br><span class="line">  <span class="type">int32_t</span>   unit_stride = <span class="number">1</span>;                      <span class="comment">// 每个元素之间的跨度,这里固定1个像素 </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!image_valid_) &#123;</span><br><span class="line">    <span class="keyword">return</span> XERR_BAD_STATE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">IsSameParameter</span>(out_img))</span><br><span class="line">  &#123;</span><br><span class="line">    out_img.<span class="built_in">Release</span>();</span><br><span class="line">    out_img.<span class="built_in">Allocate</span>(pxl_format_, width_, height_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 生成模板元素相对于中心的偏移位置</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="type">int32_t</span> i, j, k, x, y, z;</span><br><span class="line">  XPoint* locate_offset = <span class="keyword">new</span> XPoint[template_size];   <span class="comment">// 模板像素数组，存储模板元素的偏移位置</span></span><br><span class="line">  <span class="built_in">XASSERT</span>(locate_offset);</span><br><span class="line">  z = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (y = -half_wnd_size; y &lt;= half_wnd_size; y++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (x = -half_wnd_size; x &lt;= half_wnd_size; x++)</span><br><span class="line">    &#123;</span><br><span class="line">      locate_offset[z].x = x * unit_stride;</span><br><span class="line">      locate_offset[z].y = y * unit_stride;</span><br><span class="line">      z++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="comment">// 对输入图像中每个像素点进行卷积操作，结果保存到输出图像中</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">1</span> == pixel_bytes_)<span class="comment">//检测通道数是否为1（灰度图像）</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">uint8_t</span>* dst_line = out_img.image_data_;<span class="comment">//获取输出图像数据指针</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; out_img.height_; i++)<span class="comment">//遍历图像</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">uint8_t</span>* dst_data = dst_line;<span class="comment">//更新指向的待操作数据指针</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; out_img.width_; j++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 在模板掩码范围内找灰度最小的像素值，如果未击中dst_data[0]=0；如果击中dst_data[0]=0；包含dst_data[0]=1</span></span><br><span class="line">        <span class="type">uint8_t</span> min_gray = <span class="number">0xFF</span>;      </span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; template_size; k++)<span class="comment">//对图像每个像素遍历模板值</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (template_data[k] == <span class="number">0</span>) &#123;  <span class="comment">// 跳过模板0值</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line"><span class="comment">//模板为1则执行下面</span></span><br><span class="line">          y = j + locate_offset[k].y;<span class="comment">//// 计算模板中1元素对应的图像坐标</span></span><br><span class="line">          x = i + locate_offset[k].x;</span><br><span class="line">          <span class="keyword">if</span> (x &lt; <span class="number">0</span>)         x = <span class="number">0</span>; <span class="comment">// 边界处理，确保模板坐标不越界</span></span><br><span class="line">          <span class="keyword">if</span> (x &gt;= height_)  x = height_ - <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> (y &lt; <span class="number">0</span>)         y = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> (y &gt; width_)    y = width_ - <span class="number">1</span>;</span><br><span class="line">          <span class="comment">//获取图像中对应坐标的像素值</span></span><br><span class="line">          <span class="type">uint8_t</span>* source_data = image_data_ + (y * line_bytes_) + (x * pixel_bytes_);</span><br><span class="line">          <span class="keyword">if</span> ((*source_data) &lt; min_gray)<span class="comment">//判断不在白色区域内</span></span><br><span class="line">          &#123;</span><br><span class="line">            min_gray = (*source_data);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将最小的灰度值作为目标像素颜色值</span></span><br><span class="line">        dst_data[<span class="number">0</span>] = min_gray;</span><br><span class="line"></span><br><span class="line">        dst_data += out_img.pixel_bytes_;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      dst_line += line_bytes_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span><span class="comment">//3通道图像处理</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">uint8_t</span>* dst_line = out_img.image_data_;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; out_img.height_; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">uint8_t</span>* dst_data = dst_line;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; out_img.width_; j++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 在模板掩码范围内找颜色值最小的像素值</span></span><br><span class="line">        <span class="type">uint8_t</span> min_gray = <span class="number">0xFF</span>;</span><br><span class="line">        <span class="type">uint8_t</span> min_red = <span class="number">0x00</span>, min_green = <span class="number">0x00</span>, min_blue = <span class="number">0x00</span>;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; template_size; k++)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (template_data[k] == <span class="number">0</span>) &#123;  <span class="comment">// 模板掩码</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          y = j + locate_offset[k].y;</span><br><span class="line">          x = i + locate_offset[k].x;</span><br><span class="line">          <span class="keyword">if</span> (x &lt; <span class="number">0</span>)         x = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> (x &gt;= height_)  x = height_ - <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> (y &lt; <span class="number">0</span>)         y = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> (y &gt; width_)    y = width_ - <span class="number">1</span>;</span><br><span class="line">          <span class="type">uint8_t</span>* source_data = image_data_ + (x * line_bytes_) + (y * pixel_bytes_);</span><br><span class="line">          <span class="type">uint32_t</span>  R = source_data[<span class="number">2</span>] * <span class="number">77</span>;</span><br><span class="line">          <span class="type">uint32_t</span>  G = source_data[<span class="number">1</span>] * <span class="number">151</span>;</span><br><span class="line">          <span class="type">uint32_t</span>  B = source_data[<span class="number">0</span>] * <span class="number">28</span>;</span><br><span class="line">          <span class="type">uint32_t</span>  gray = (R + G + B) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">          <span class="keyword">if</span> (gray &lt; min_gray)</span><br><span class="line">          &#123;</span><br><span class="line">            min_gray = gray;</span><br><span class="line">            min_red = R;  </span><br><span class="line">            min_green = G;  </span><br><span class="line">            min_blue = B;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将最小的颜色值作为目标颜色值  </span></span><br><span class="line">        dst_data[<span class="number">0</span>] = min_blue;</span><br><span class="line">        dst_data[<span class="number">1</span>] = min_green;</span><br><span class="line">        dst_data[<span class="number">2</span>] = min_red;</span><br><span class="line"></span><br><span class="line">        dst_data += out_img.pixel_bytes_;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      dst_line += line_bytes_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> XOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h2><p>二值化物体边界扩充，挨着的物体连通到一起；填补空洞<br>1）遍历元素<br>2）每个元素遍历模板；判断模板是包含，击中，还是未击中；<br>3)包含和击中则&#x3D;1，未击中&#x3D;0（在此例中为赋值检测到的最小通道值）<br>$\mathsf{dst}(x,y)&#x3D;\max_{(x,y)∈待处理图片;(x^{\prime},y^{\prime})∈模板}{\mathsf{src}(x+x^{\prime},y+y^{\prime})}$；</p>
<p><img src="/image/image_6JqILFyMfc.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 功能: 使用 wnd_size*wnd_size 大小的模板进行膨胀操作</span></span><br><span class="line"><span class="comment">// 参数: template_data: wnd_size*wn_size大小的掩码模板, 值为1表示相应像素参与计算</span></span><br><span class="line"><span class="comment">//       wnd_size : 模板窗口大小</span></span><br><span class="line"><span class="comment">//       out_img : 输出图像数据</span></span><br><span class="line"><span class="comment">// 返回: 错误码</span></span><br><span class="line"><span class="comment">// 初始化和参数检查</span></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">XImage::Expand</span><span class="params">(<span class="type">int32_t</span>* template_data, <span class="type">int32_t</span> wnd_size, XImage&amp; out_img)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int32_t</span>   template_size = wnd_size * wnd_size;  <span class="comment">// 模板元素数量</span></span><br><span class="line">  <span class="type">int32_t</span>   half_wnd_size = wnd_size / <span class="number">2</span>;          <span class="comment">// 半个窗口的宽高</span></span><br><span class="line">  <span class="type">int32_t</span>   unit_stride = <span class="number">1</span>;                      <span class="comment">// 每个元素之间的跨度,这里固定1个像素 </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!image_valid_) &#123;</span><br><span class="line">    <span class="keyword">return</span> XERR_BAD_STATE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">IsSameParameter</span>(out_img))</span><br><span class="line">  &#123;</span><br><span class="line">    out_img.<span class="built_in">Release</span>();</span><br><span class="line">    out_img.<span class="built_in">Allocate</span>(pxl_format_, width_, height_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 计算每个卷积元素相对于中心的偏移位置</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="type">int32_t</span> i, j, k, x, y, z;</span><br><span class="line">  XPoint* locate_offset = <span class="keyword">new</span> XPoint[template_size];   <span class="comment">// 各个卷积元素的偏移位置</span></span><br><span class="line">  <span class="built_in">XASSERT</span>(locate_offset);</span><br><span class="line">  z = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (y = -half_wnd_size; y &lt;= half_wnd_size; y++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (x = -half_wnd_size; x &lt;= half_wnd_size; x++)</span><br><span class="line">    &#123;</span><br><span class="line">      locate_offset[z].x = x * unit_stride;</span><br><span class="line">      locate_offset[z].y = y * unit_stride;</span><br><span class="line">      z++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="comment">// 对输入图像中每个像素点进行卷积操作，结果保存到输出图像中</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">1</span> == pixel_bytes_)<span class="comment">// 处理单通道图像（灰度图）</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">uint8_t</span>* dst_line = out_img.image_data_;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; out_img.height_; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">uint8_t</span>* dst_data = dst_line;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; out_img.width_; j++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 在模板掩码范围内找灰度最大的像素值</span></span><br><span class="line">        <span class="type">uint8_t</span> max_gray = <span class="number">0x00</span>;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; template_size; k++)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (template_data[k] == <span class="number">0</span>) &#123;  <span class="comment">// 忽略模板中的0元素</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line"><span class="comment">// 计算模板中元素对应的图像坐标</span></span><br><span class="line">          y = j + locate_offset[k].y;</span><br><span class="line">          x = i + locate_offset[k].x;</span><br><span class="line">          <span class="comment">// 边界处理，确保坐标不越界</span></span><br><span class="line">          <span class="keyword">if</span> (x &lt; <span class="number">0</span>)         x = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> (x &gt;= height_)  x = height_ - <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> (y &lt; <span class="number">0</span>)         y = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> (y &gt; width_)    y = width_ - <span class="number">1</span>;</span><br><span class="line">          <span class="comment">// 获取图像中对应坐标的像素值</span></span><br><span class="line">          <span class="type">uint8_t</span>* source_data = image_data_ + (x * line_bytes_) + (y * pixel_bytes_);</span><br><span class="line">          <span class="keyword">if</span> ((*source_data) &gt; max_gray)</span><br><span class="line">          &#123;</span><br><span class="line">            max_gray = (*source_data);<span class="comment">// 更新最大灰度值</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将最大的灰度值作为目标颜色值</span></span><br><span class="line">        dst_data[<span class="number">0</span>] = max_gray;</span><br><span class="line"></span><br><span class="line">        dst_data += out_img.pixel_bytes_;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      dst_line += line_bytes_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">uint8_t</span>* dst_line = out_img.image_data_;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; out_img.height_; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">uint8_t</span>* dst_data = dst_line;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; out_img.width_; j++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 在模板掩码范围内找颜色值最大的像素值</span></span><br><span class="line">        <span class="type">uint8_t</span> max_gray = <span class="number">0x00</span>;</span><br><span class="line">        <span class="type">uint8_t</span> max_red = <span class="number">0xFF</span>, max_green = <span class="number">0xFF</span>, max_blue = <span class="number">0xFF</span>;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; template_size; k++)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (template_data[k] == <span class="number">0</span>) &#123;  <span class="comment">// 模板掩码</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          y = j + locate_offset[k].y;</span><br><span class="line">          x = i + locate_offset[k].x;</span><br><span class="line">          <span class="keyword">if</span> (x &lt; <span class="number">0</span>)         x = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> (x &gt;= height_)  x = height_ - <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> (y &lt; <span class="number">0</span>)         y = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> (y &gt; width_)    y = width_ - <span class="number">1</span>;</span><br><span class="line">          <span class="type">uint8_t</span>* source_data = image_data_ + (x * line_bytes_) + (y * pixel_bytes_);</span><br><span class="line">          <span class="type">uint32_t</span>  R = source_data[<span class="number">2</span>] * <span class="number">77</span>;</span><br><span class="line">          <span class="type">uint32_t</span>  G = source_data[<span class="number">1</span>] * <span class="number">151</span>;</span><br><span class="line">          <span class="type">uint32_t</span>  B = source_data[<span class="number">0</span>] * <span class="number">28</span>;</span><br><span class="line">          <span class="type">uint32_t</span>  gray = (R + G + B) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">          <span class="keyword">if</span> (gray &gt; max_gray)</span><br><span class="line">          &#123;</span><br><span class="line">            max_gray = gray;</span><br><span class="line">            max_red = R;</span><br><span class="line">            max_green = G;</span><br><span class="line">            max_blue = B;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将最大的颜色值作为目标颜色值  </span></span><br><span class="line">        dst_data[<span class="number">0</span>] = max_blue;</span><br><span class="line">        dst_data[<span class="number">1</span>] = max_green;</span><br><span class="line">        dst_data[<span class="number">2</span>] = max_red;</span><br><span class="line"></span><br><span class="line">        dst_data += out_img.pixel_bytes_;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      dst_line += line_bytes_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> XOK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 十字链模板</span></span><br><span class="line">  <span class="type">int32_t</span> corrode_template[<span class="number">9</span>] = &#123;</span><br><span class="line">    <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  XImage  org_img, gray_img, corrode_img, expand_img;</span><br><span class="line"></span><br><span class="line">  org_img.<span class="built_in">LoadFromBmp</span>(<span class="string">&quot;d:/24bit.bmp&quot;</span>);</span><br><span class="line">  org_img.<span class="built_in">Convert</span>(PXL_FORMAT_8BIT_GRAY, gray_img);</span><br><span class="line">  gray_img.<span class="built_in">SaveToBmp</span>(<span class="string">&quot;d:/gray.bmp&quot;</span>);</span><br><span class="line"></span><br><span class="line">  ret = gray_img.<span class="built_in">Corrode</span>(corrode_template, <span class="number">3</span>, corrode_img);</span><br><span class="line">  corrode_img.<span class="built_in">SaveToBmp</span>(<span class="string">&quot;d:/corrode.bmp&quot;</span>);</span><br><span class="line"></span><br><span class="line">  ret = gray_img.<span class="built_in">Expand</span>(corrode_template, <span class="number">3</span>, expand_img);</span><br><span class="line">  expand_img.<span class="built_in">SaveToBmp</span>(<span class="string">&quot;d:/expand.bmp&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="开运算"><a href="#开运算" class="headerlink" title="开运算"></a>开运算</h2><p><strong>先腐蚀 再膨胀</strong>称之为开运算<br>消除小物体；在纤细处分离物体；平滑较大的边界并不明显改变其面积。从视觉上看仿佛将原本连接的物体“分开”了一样</p>
<p><img src="/image/image_gTuR5OfOgz.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 十字链模板</span></span><br><span class="line">  <span class="type">int32_t</span> template_data[<span class="number">9</span>] = &#123;</span><br><span class="line">    <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  XImage  org_img, gray_img, corrode_img, expand_img;</span><br><span class="line"></span><br><span class="line">  org_img.<span class="built_in">LoadFromBmp</span>(<span class="string">&quot;d:/24bit.bmp&quot;</span>);</span><br><span class="line">  org_img.<span class="built_in">Convert</span>(PXL_FORMAT_8BIT_GRAY, gray_img);</span><br><span class="line">  gray_img.<span class="built_in">SaveToBmp</span>(<span class="string">&quot;d:/gray.bmp&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先腐蚀，再膨胀</span></span><br><span class="line">  ret = gray_img.<span class="built_in">Corrode</span>(template_data, <span class="number">3</span>, corrode_img);</span><br><span class="line">  ret = corrode_img.<span class="built_in">Expand</span>(template_data, <span class="number">3</span>, expand_img);</span><br><span class="line">  expand_img.<span class="built_in">SaveToBmp</span>(<span class="string">&quot;d:/opened.bmp&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="闭运算"><a href="#闭运算" class="headerlink" title="闭运算"></a>闭运算</h2><p><strong>先膨胀 再腐蚀</strong> 称之为闭运算<br>排除小型黑洞，从视觉上看仿佛将原本分开的部分“闭合”了一样</p>
<p><img src="/image/image_dicLkBE1i6.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 十字链模板</span></span><br><span class="line">  <span class="type">int32_t</span> template_data[<span class="number">9</span>] = &#123;</span><br><span class="line">    <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>,   <span class="number">1</span>,   <span class="number">1</span>,</span><br><span class="line">    <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">0</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  XImage  org_img, gray_img, corrode_img, expand_img;</span><br><span class="line"></span><br><span class="line">  org_img.<span class="built_in">LoadFromBmp</span>(<span class="string">&quot;d:/24bit.bmp&quot;</span>);</span><br><span class="line">  org_img.<span class="built_in">Convert</span>(PXL_FORMAT_8BIT_GRAY, gray_img);</span><br><span class="line">  gray_img.<span class="built_in">SaveToBmp</span>(<span class="string">&quot;d:/gray.bmp&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先膨胀，再腐蚀</span></span><br><span class="line">  ret = gray_img.<span class="built_in">Expand</span>(template_data, <span class="number">3</span>, expand_img);</span><br><span class="line">  ret = expand_img.<span class="built_in">Corrode</span>(template_data, <span class="number">3</span>, corrode_img);</span><br><span class="line">  corrode_img.<span class="built_in">SaveToBmp</span>(<span class="string">&quot;d:/closed.bmp&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Top-hat变换"><a href="#Top-hat变换" class="headerlink" title="Top-hat变换"></a>Top-hat变换</h2><p>&#x20;<strong>原图像</strong> 与 <strong>开运算结果图像</strong> 之差:$T_w(f)&#x3D;f-f\circ s$<br>可得到图像中那些面积小于结构元且比周围亮的区域</p>
<p><strong>闭运算结果图像</strong> 与 <strong>原图像</strong> 之差:$T_b(f)&#x3D;f\bullet s-f$<br>可得到图像中那些面积小于结构元且比周围暗的区域</p>
<h2 id="骨架抽取、极线腐蚀、击中击不中变换、颗粒分析、流域变换、形态学梯度等"><a href="#骨架抽取、极线腐蚀、击中击不中变换、颗粒分析、流域变换、形态学梯度等" class="headerlink" title="骨架抽取、极线腐蚀、击中击不中变换、颗粒分析、流域变换、形态学梯度等"></a>骨架抽取、极线腐蚀、击中击不中变换、颗粒分析、流域变换、形态学梯度等</h2>]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>轮廓检测，提取，追踪，连接</title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E8%BD%AE%E5%BB%93%E6%A3%80%E6%B5%8B%EF%BC%8C%E6%8F%90%E5%8F%96%EF%BC%8C%E8%BF%BD%E8%B8%AA%EF%BC%8C%E8%BF%9E%E6%8E%A5/%E8%BD%AE%E5%BB%93%E6%A3%80%E6%B5%8B%EF%BC%8C%E6%8F%90%E5%8F%96%EF%BC%8C%E8%BF%BD%E8%B8%AA%EF%BC%8C%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<p>检测，提取：<a href="../%E7%A9%BA%E9%97%B4%E5%9F%9F%E6%BB%A4%E6%B3%A2%E5%99%A8/%E7%A9%BA%E9%97%B4%E5%9F%9F%E6%BB%A4%E6%B3%A2%E5%99%A8.md" title="空间域滤波器">空间域滤波器</a><br>追踪：</p>
]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>空间域滤波器</title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E7%A9%BA%E9%97%B4%E5%9F%9F%E6%BB%A4%E6%B3%A2%E5%99%A8/%E7%A9%BA%E9%97%B4%E5%9F%9F%E6%BB%A4%E6%B3%A2%E5%99%A8/</url>
    <content><![CDATA[<h1 id="平滑-模糊-滤波"><a href="#平滑-模糊-滤波" class="headerlink" title="平滑(模糊)滤波"></a>平滑(模糊)滤波</h1><p><strong>减少当前像素点的颜色值 与 周边像素点颜色值的差异</strong></p>
<p><img src="/image/image_Du0bGdDZS3.png"></p>
<p>一维噪声</p>
<p><img src="/image/image_IGAcezGwsK.png"></p>
<p>二维噪声</p>
<h2 id="均值滤波器"><a href="#均值滤波器" class="headerlink" title="均值滤波器"></a>均值滤波器</h2><p>多帧均值：预设噪声是发生在某空域上的随机误差事件；则$n_{→+\infty}$帧图像在此空域上的噪声总和$\sum_{n&#x3D;1}^{+\infty}\Delta$ 趋近于0</p>
<h3 id="单帧均值滤波器"><a href="#单帧均值滤波器" class="headerlink" title="单帧均值滤波器"></a>单帧均值滤波器</h3><p>遍历每个像素，对像素领域进行加权平均，能对颜色值去峰填谷，去除椒盐噪声；弊端是降低图片对比度，使图形边缘模糊<br>$期望g\left(x_0,y_0\right)&#x3D;\frac1{width\times heigth }\sum_{(x,y)\in (x_0,y_0)的邻域}f(x,y)$</p>
<p><img src="/image/image_b0zIDxOHxs.png"></p>
<p>卷积模板窗口越大其平滑效果越好，但是也带来一个问题：过多平滑后图像显得比较模糊</p>
<h3 id="高斯加权均值滤波器"><a href="#高斯加权均值滤波器" class="headerlink" title="高斯加权均值滤波器"></a>高斯加权均值滤波器</h3><p><strong>考虑减小图形边缘</strong>（颜色值变化陡峭处)去峰填谷的效应；即类似以下分布的空域上像素滤波后能更接近原来的情况</p>
<p><img src="/image/image_N37Ncahyp2.png"></p>
<p>使<strong>接近中心像素的权值变高，距离中心像素远的权值变低</strong>；这样能降低图像边缘去峰填谷效应；对稀疏的椒盐噪点的滤波依旧有效<br>高斯模板：$G(x,y)&#x3D;\frac1{2\pi\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}}$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>  <span class="title">XBmpCalcuGaussCoeff</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  XLONG      lWndSize,<span class="comment">//模板边长</span></span></span></span><br><span class="line"><span class="params"><span class="function">  XFLOAT    fSigma,<span class="comment">//sigma方差</span></span></span></span><br><span class="line"><span class="params"><span class="function">  XDOUBLE*  pGaussCoeff      )</span><span class="comment">//模板系数数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  XLONG lHalfWndSize = lWndSize / <span class="number">2</span>;<span class="comment">//感知半径</span></span><br><span class="line">  XLONG x, y, z;</span><br><span class="line">  XDOUBLE fSigma2 = <span class="number">2.0</span> * fSigma * fSigma;<span class="comment">//计算指数系数：2倍方差</span></span><br><span class="line">  XDOUBLE fConstCoeff = <span class="number">2.0</span> * X_PI * fSigma2;<span class="comment">//计算常数系数</span></span><br><span class="line">  XDOUBLE  fCoeffSum = <span class="number">0</span>;<span class="comment">// 系数之和</span></span><br><span class="line">  <span class="comment">//XDOUBLE fElmSum = 0;// 元素之和</span></span><br><span class="line"></span><br><span class="line">  z = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (y = -lHalfWndSize; y &lt;= lHalfWndSize; y++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (x = -lHalfWndSize; x &lt;= lHalfWndSize; x++)</span><br><span class="line">    &#123;</span><br><span class="line">      pGaussCoeff[z] = <span class="built_in">exp</span>(-(x*x + y*y) / fSigma2) / fConstCoeff;</span><br><span class="line">      fCoeffSum += pGaussCoeff[z];</span><br><span class="line">      z++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所有系数归一化操作</span></span><br><span class="line">  z = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (y = -lHalfWndSize; y &lt;= lHalfWndSize; y++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (x = -lHalfWndSize; x &lt;= lHalfWndSize; x++)</span><br><span class="line">    &#123;</span><br><span class="line">      pGaussCoeff[z] /= fCoeffSum;<span class="comment">//离散化后累积分布不等于1；要归一化出一个新概率分布</span></span><br><span class="line">     <span class="comment">// fElmSum += pGaussCoeff[z];//验证归一化后总和是否为1</span></span><br><span class="line">      z++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 最后统计到的所有元素之和 fElmSum应该是1.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h2><h3 id="排序中值滤波器"><a href="#排序中值滤波器" class="headerlink" title="排序中值滤波器"></a><strong>排序中值滤波器</strong></h3><p>对卷积窗口区域内像素<strong>排序</strong>，<strong>找到将</strong>中值作为中心像素颜色值</p>
<h1 id="锐化滤波"><a href="#锐化滤波" class="headerlink" title="锐化滤波"></a>锐化滤波</h1><p><a href="https://zhuanlan.zhihu.com/p/166638524" title="2、平滑滤波器和锐化滤波器 平滑滤波器主要用于模糊处理和降低噪声。模糊处理经常用于图像预处理，比如主要目标提取中去除琐碎细节以及桥接线的缝隙。 2.1 线性平滑滤波器其输出/响应是滤波器模板邻域内像素的均值，因此也被称为均值滤波器，… https://zhuanlan.zhihu.com/p/166638524">2、平滑滤波器和锐化滤波器 平滑滤波器主要用于模糊处理和降低噪声。模糊处理经常用于图像预处理，比如主要目标提取中去除琐碎细节以及桥接线的缝隙。 2.1 线性平滑滤波器其输出&#x2F;响应是滤波器模板邻域内像素的均值，因此也被称为均值滤波器，… https://zhuanlan.zhihu.com/p/166638524</a></p>
<p>增强(提取)图形边缘（灰度陡峭过渡部分）</p>
<h2 id="典型边缘类型"><a href="#典型边缘类型" class="headerlink" title="典型边缘类型"></a>典型边缘类型</h2><p>边缘上灰度变化平缓；而边缘两侧(即垂直边缘方向灰度变化不连续&#x2F;陡峭)</p>
<p><img src="/image/image_pzpjsP_yD9.png"></p>
<p>可见2阶微分能筛出边缘（以及噪声）；削除灰度缓慢变化的区域（筛出突变，削除慢变）<br>二阶差分$\Delta^2 y[x]&#x3D;\Delta (\Delta y[x])&#x3D;\Delta(y[x+1]-y[x])&#x3D;y[x+2]-2y[x+1]+y[x]$</p>
<h2 id="边缘提取"><a href="#边缘提取" class="headerlink" title="边缘提取"></a>边缘提取</h2><p>水平差分算子：在水平方向上进行滤波增强水平边界$\Delta^2 f[x,y]&#x3D;f[x+2,y]-2f[x+1,y]+f[x,y]$<br>垂直差分算子：在垂直方向上进行滤波增强垂直边界$\Delta^2 f[x,y]&#x3D;f[x,y+2]-2f[x,y+1]+f[x,y]$<br>筛出xy轴方向的边界：分别把图像用上述两种算子处理再相加；</p>
<h3 id="拉普拉斯算子-Laplacian算子"><a href="#拉普拉斯算子-Laplacian算子" class="headerlink" title="拉普拉斯算子(Laplacian算子)"></a><strong>拉普拉斯算子</strong>(Laplacian算子)</h3><p>在边缘垂直方向求二阶微分；<br>$\bigtriangleup f&#x3D;\bigtriangledown^2 f&#x3D;$$(\frac{\partial }{\partial x},\frac{\partial }{\partial y})\cdot$$(\frac{\partial }{\partial x},\frac{\partial }{\partial y})\cdot$$f$&#x3D;$\frac{\partial^2 f}{\partial x^2 }+\frac{\partial^2 f }{\partial y^2}$;使用sobel差分：<br>$&#x3D;[f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)]-4f(x,y)$</p>
<p><img src="/image/image_bDj7UZ8qCd.png"></p>
<h3 id="高斯-拉普拉斯算子"><a href="#高斯-拉普拉斯算子" class="headerlink" title="高斯-拉普拉斯算子"></a>高斯-<strong>拉普拉斯算子</strong></h3><p>先平滑噪声再提取边界<a href="https://www.bilibili.com/video/BV1z8411W73i/?p=23&vd_source=5e06b5dd11f67d0863cd77450011b67a" title="https://www.bilibili.com/video/BV1z8411W73i/?p=23&amp;vd_source=5e06b5dd11f67d0863cd77450011b67a">https://www.bilibili.com/video/BV1z8411W73i/?p=23&amp;vd_source&#x3D;5e06b5dd11f67d0863cd77450011b67a</a></p>
<h3 id="排序最值滤波器"><a href="#排序最值滤波器" class="headerlink" title="排序最值滤波器"></a><strong>排序最值滤波器</strong></h3><p>在卷积模板窗口区域中，查找到<strong>最大或者最小的</strong>一个像素值作为目标输出像素值</p>
<p><img src="/image/image_sYXB2vUzj2.png"></p>
<h2 id="边缘增强-弱化"><a href="#边缘增强-弱化" class="headerlink" title="边缘增强&#x2F;弱化"></a>边缘增强&#x2F;弱化</h2><p>边缘提取后跟原图叠在一起；或边缘提取算子 *(-1)再直接+$af[x,y]$边缘弱化的话：边缘提取算子 *(+1)再直接+$af[x,y]$</p>
<h2 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h2><p>1)边缘检测误检的最大原因是噪声；所以要先平滑再检测<br>2)判断某点是否是边缘；即判断相邻重叠n*n区域最大方向导数（梯度的模）的差是否大于某个阈值；经过以下算子计算梯度的模</p>
<h3 id="水平-垂直差分算子"><a href="#水平-垂直差分算子" class="headerlink" title="水平&#x2F;垂直差分算子"></a><strong>水平&#x2F;垂直差分算子</strong></h3><p><a href="https://www.wolai.com/uM8A3jfCffoXQjEv2XvkCH" title="数学分析">数学分析</a><br>水平垂直差分梯度<br>$|\bigtriangledown f|&#x3D;\sqrt{(\frac{\partial Z_x}{\partial x})^2+(\frac{\partial Z_y}{\partial y})^2}$&#x3D;$\sqrt{f[x+1,y]^2+2f[x,y]^2+f[x,y+1]^2-2f<a href="f%5Bx+1,y%5D+f%5Bx,y+1%5D">x,y</a>}≈\sqrt{(\frac{\partial Z_x}{\partial x}+\frac{\partial Z_y}{\partial y})^2}&#x3D;\left|f(x,y)-f(x+1,y)\right|+\left|f(x,y)-f(x,y+1)\right|$</p>
<p><img src="/image/image_dCt9C3tyqc.png"></p>
<p>左边</p>
<p><img src="/image/image_tZwDXyQ8OA.png"></p>
<p>右边</p>
<h3 id="Roberts算子（交叉微分算法）"><a href="#Roberts算子（交叉微分算法）" class="headerlink" title="Roberts算子（交叉微分算法）"></a><strong>Roberts算子</strong>（交叉微分算法）</h3><p>$|\bigtriangledown f|&#x3D;\sqrt{(\frac{\partial Z}{\partial l}\frac{\partial l}{\partial x})^2+(\frac{\partial Z}{\partial k}\frac{\partial k}{\partial y})^2}$≈$\sqrt{(\frac{\partial Z}{\partial l}\frac{\partial l}{\partial x}+\frac{\partial Z}{\partial k}\frac{\partial k}{\partial y})^2}$&#x3D;$|\frac{\partial Z}{\partial l}\frac{\partial l}{\partial x}+\frac{\partial Z}{\partial k}\frac{\partial k}{\partial y}|$≈$|\frac{\partial Z}{\partial l}cos-45|+|\frac{\partial Z}{\partial k}cos-135|$&#x3D;$\sqrt{2}|f[x+1,y+1]-f[x,y]|+\sqrt{2}|f[x,y+1]-f[x,y]|$；用来比较阈值的，系数可以去掉，把阈值除以$\sqrt{2}$即可;<br>适用于+-45的边缘</p>
<p><img src="/image/image_u7In9KqarR.png"></p>
<p><img src="/image/image_u9aGQTlR8f.png"></p>
<h3 id="Prewitt算子-平均差分算子"><a href="#Prewitt算子-平均差分算子" class="headerlink" title="Prewitt算子(平均差分算子)"></a><strong>Prewitt算子</strong>(平均差分算子)</h3><p>使用每一点数据时先用相邻3点进行算术平均滤波；排除噪声影响；适用于渐变图片<br>$|\bigtriangledown f|&#x3D;\sqrt{(\frac{\partial Z_x}{\partial x})^2+(\frac{\partial Z_y}{\partial y})^2}$≈$\sqrt{(\frac{\partial Z_x}{\partial x}+\frac{\partial Z_y}{\partial y})^2}$≈$|\frac{\partial Z_x}{\partial x}|+|\frac{\partial Z_y}{\partial y}|$;<br>|$\frac{\partial Z_x}{\partial x}|$&#x3D;$|\frac{[f(x+1,y-1)+f(x+1,y)+f(x+1,y+1)]}{3}-\frac{[f(x-1,y-1)+f(x-1,y)+f(x-1,y+1)]}{3}|$$|\frac{\partial Z_y}{\partial y}|&#x3D;|\frac{[f(x-1,y+1)+f(x,y+1)+f(x+1,y+1)]}{3}-\frac{[f(x-1,y-1)+f(x,y-1)+f(x+1,y-1)]}{3}|$；比较相邻梯度时1&#x2F;3无意义</p>
<p><img src="/image/image_7mYBVSlOTS.png"></p>
<h3 id="Sobel算子-加权平均差分法"><a href="#Sobel算子-加权平均差分法" class="headerlink" title="Sobel算子(加权平均差分法)"></a><strong>Sobel算子</strong>(加权平均差分法)</h3><p>使用每一点数据时先用相邻3点进行加权平均滤波；排除噪声影响；适用于渐变图片<br>$|\bigtriangledown f|&#x3D;\sqrt{(\frac{\partial Z_x}{\partial x})^2+(\frac{\partial Z_y}{\partial y})^2}$≈$\sqrt{(\frac{\partial Z_x}{\partial x}+\frac{\partial Z_y}{\partial y})^2}$≈$|\frac{\partial Z_x}{\partial x}|+|\frac{\partial Z_y}{\partial y}|$;<br>|$\frac{\partial Z_x}{\partial x}|$&#x3D;$|\frac{[f(x+1,y-1)+2f(x+1,y)+f(x+1,y+1)]}{3}-\frac{[f(x-1,y-1)+2f(x-1,y)+f(x-1,y+1)]}{3}|$$|\frac{\partial Z_y}{\partial y}|&#x3D;|\frac{[f(x-1,y+1)+2f(x,y+1)+f(x+1,y+1)]}{3}-\frac{[f(x-1,y-1)+2f(x,y-1)+f(x+1,y-1)]}{3}|$；比较相邻梯度时1&#x2F;3无意义</p>
<p><img src="/image/image__sumaSHVdg.png"></p>
<p><img src="/image/image_zXEPCxHpwR.png"></p>
<p>sobel算子在连续函数上能检测各个方向上的边界</p>
<h3 id="自适应检测"><a href="#自适应检测" class="headerlink" title="自适应检测"></a>自适应检测</h3><p>对每个像素；上面的算子都试一遍，取效果最好的那一个</p>
<h1 id="彩色图像的滤波处理"><a href="#彩色图像的滤波处理" class="headerlink" title="彩色图像的滤波处理"></a>彩色图像的滤波处理</h1><p>前面的平滑和锐化滤波算法主要讲解针对单通道的灰度图像进行的，对于彩色图像有RGB三个通道，处理方式也是基本类似（除了排序滤波器），各种平滑和锐化滤波器同样可以应用于RGB彩色图像，具体做法就是：R、G、B三个通道分别进行卷积计算处理，分别输出的R、G、B值组成目标彩色图像的像素值。</p>
<p>那么对于排序滤波器主要的问题是：对于同一个像素，在3*3的模板中，其中R通道排序可能是最小值，而B通道排序是比较大的值，不同通道中排序的位置不对，所以不能直接进行各个通道排序。如果RGB彩色图像非要使用排序滤波的话，可以考虑先将其RGB彩色图像转换成灰度值，然后再进行灰度值排序。</p>
<h1 id="滤波器使用"><a href="#滤波器使用" class="headerlink" title="滤波器使用"></a>滤波器使用</h1><p><img src="/image/image_GQ2Av05SXD.png"></p>
<p>越界的部分用指定像素填充（通常就是边界像素）；<br>上述空域算法都是对感应区域内&#x2F;全部f(x,y)进行加权求和；$w(x,y)* f(x,y)&#x3D;\sum_{r&#x3D;-a}^{a}\sum_{c&#x3D;-b}^{b}w(r,c)f(x-r,y-c);a,b$是半径</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 功能: 卷积操作：遍历像素，且遍历每个像素的模板进行累加</span></span><br><span class="line"><span class="comment">// 参数:  wnd_size     : 模板窗口大小，这里就是模板的宽和高，当前只支持宽高一致的情况，需要是奇数</span></span><br><span class="line"><span class="comment">//       unit_stride  : 卷积模板中每个元素对应的像素长度，默认为1</span></span><br><span class="line"><span class="comment">//       template_data: 卷积模板数据，整型数据，其数据大小为 (lWndSize*lWndSize)</span></span><br><span class="line"><span class="comment">//       out_img      : 卷积结果输出图像</span></span><br><span class="line"><span class="comment">// 返回：错误值</span></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">XImage::ConvoluteFloat</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int32_t</span>    wnd_size,         <span class="comment">//边长</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int32_t</span>    unit_stride,      <span class="comment">//</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">float</span>*    template_data,     <span class="comment">//模板数据；即输入算子</span></span></span></span><br><span class="line"><span class="params"><span class="function">        XImage&amp;    out_img            )</span><span class="comment">//输出结果</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int32_t</span>   template_size = wnd_size * wnd_size;         <span class="comment">// 模板元素数量</span></span><br><span class="line">    <span class="type">int32_t</span>   half_wnd_size = wnd_size / <span class="number">2</span>;               <span class="comment">// 模板半径</span></span><br><span class="line">    <span class="type">int32_t</span>   padding_size  = half_wnd_size * unit_stride;<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!image_valid_)  &#123;</span><br><span class="line">        <span class="keyword">return</span> XERR_BAD_STATE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IsSameParameter</span>(out_img))</span><br><span class="line">    &#123;</span><br><span class="line">        out_img.<span class="built_in">Release</span>( );</span><br><span class="line">        out_img.<span class="built_in">Allocate</span>(pxl_format_, width_, height_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 计算每个卷积元素相对于中心的偏移位置</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="type">int32_t</span> i, j, k, x, y, z;</span><br><span class="line">    XPoint* locate_offset = <span class="keyword">new</span> XPoint[template_size];   <span class="comment">// 实例化模板</span></span><br><span class="line">    <span class="built_in">XASSERT</span>(locate_offset);</span><br><span class="line">    z = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (y = -half_wnd_size; y &lt;= half_wnd_size; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (x = -half_wnd_size; x &lt;= half_wnd_size; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            locate_offset[z].x = x * unit_stride;<span class="comment">//每个模板数组成员是(x,y,v)</span></span><br><span class="line">            locate_offset[z].y = y * unit_stride;</span><br><span class="line">            z++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 对输入图像中每个像素点进行卷积操作，结果保存到输出图像中</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="type">uint8_t</span>* dst_line = out_img.image_data_;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; out_img.height_; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint8_t</span>* dst_data = dst_line;<span class="comment">//总是指向要处理的像素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; out_img.width_; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">float</span> sum_red = <span class="number">0</span>, sum_green = <span class="number">0</span>, sum_blue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; template_size; k++)<span class="comment">//卷积</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 计算模板元素对应在原图中的像素位置, 超出边缘的直接以边缘图像数据为准//(x,y)原来是偏移量-&gt;原图坐标</span></span><br><span class="line">                y = j + padding_size + locate_offset[k].y;</span><br><span class="line">                x = i + padding_size + locate_offset[k].x;</span><br><span class="line">                <span class="keyword">if</span> (x &lt; <span class="number">0</span>)         x = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (x &gt;= height_)  x = height_ - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (y &lt; <span class="number">0</span>)         y = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (y &gt;= width_)    y = width_ - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 找到模板元素对应的原图中像素数据In像素数组//把（x,y）映射到图片数组指针</span></span><br><span class="line">                <span class="type">uint8_t</span>* source_data = image_data_ + (y * line_bytes_) + (x * pixel_bytes_);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 进行卷积操作//模板下对应的数值*权</span></span><br><span class="line">                sum_red   += (<span class="type">float</span>)source_data [<span class="number">0</span>] * template_data[k];</span><br><span class="line">                sum_green += (<span class="type">float</span>)source_data [<span class="number">1</span>] * template_data[k];</span><br><span class="line">                sum_blue  += (<span class="type">float</span>)source_data [<span class="number">2</span>] * template_data[k];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将输出RGB颜色值控制在 [0, 255]值域内</span></span><br><span class="line">            dst_data[<span class="number">0</span>] = (<span class="type">uint8_t</span>)(<span class="built_in">MAX</span>(<span class="built_in">MIN</span>(<span class="number">255</span>, sum_red), <span class="number">0</span>));</span><br><span class="line">            dst_data[<span class="number">1</span>] = (<span class="type">uint8_t</span>)(<span class="built_in">MAX</span>(<span class="built_in">MIN</span>(<span class="number">255</span>, sum_green), <span class="number">0</span>));</span><br><span class="line">            dst_data[<span class="number">2</span>] = (<span class="type">uint8_t</span>)(<span class="built_in">MAX</span>(<span class="built_in">MIN</span>(<span class="number">255</span>, sum_blue), <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">            dst_data += out_img.pixel_bytes_;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dst_line += line_bytes_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> XOK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 具体调用尝试</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestConvolute</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    XImage  org_img, gray_img;</span><br><span class="line">    org_img.<span class="built_in">LoadFromBmp</span>(<span class="string">&quot;e:/24bit.bmp&quot;</span>);</span><br><span class="line">    org_img.<span class="built_in">Convert</span>(PXL_FORMAT_8BIT_GRAY, gray_img);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个一个 5*5窗口大小的卷积模板</span></span><br><span class="line">    <span class="comment">// 实际上是LOG锐化算子的模板，具体参数意义后续详细讲解</span></span><br><span class="line">    <span class="type">float</span> template_data[<span class="number">25</span>] = &#123;</span><br><span class="line">            <span class="number">-0.0357f</span>, <span class="number">-0.0714f</span>, <span class="number">-0.0714f</span>, <span class="number">-0.0714f</span>, <span class="number">-0.0357f</span>,</span><br><span class="line">            <span class="number">-0.0714f</span>, <span class="number">0.0000f</span>, <span class="number">0.1429f</span>, <span class="number">0.0000f</span>, <span class="number">-0.0714f</span>,</span><br><span class="line">            <span class="number">-0.0714f</span>, <span class="number">0.1429f</span>, <span class="number">1.4286f</span>, <span class="number">0.1429f</span>, <span class="number">-0.0714f</span>,</span><br><span class="line">            <span class="number">-0.0714f</span>, <span class="number">0.0000f</span>, <span class="number">0.1429f</span>, <span class="number">0.0000f</span>, <span class="number">-0.0714f</span>,</span><br><span class="line">            <span class="number">-0.0357f</span>, <span class="number">-0.0714f</span>, <span class="number">-0.0714f</span>, <span class="number">-0.0714f</span>, <span class="number">-0.0357f</span></span><br><span class="line">    &#125;;</span><br><span class="line">    XImage  convolute_img, gray_convolute_img;<span class="comment">//开辟输出图片的内存</span></span><br><span class="line">    ret = org_img.<span class="built_in">ConvoluteFloat</span>(<span class="number">5</span>, <span class="number">1</span>, template_data, convolute_img);<span class="comment">//卷积滤波</span></span><br><span class="line">    convolute_img.<span class="built_in">SaveToBmp</span>(<span class="string">&quot;e:/convolute.bmp&quot;</span>);<span class="comment">//保存</span></span><br><span class="line">    ret = gray_img.<span class="built_in">ConvoluteFloat</span>(<span class="number">5</span>, <span class="number">1</span>, template_data, gray_convolute_img);</span><br><span class="line">    gray_convolute_img.<span class="built_in">SaveToBmp</span>(<span class="string">&quot;e:/gray_convolute.bmp&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">//</span><br><span class="line">// 功能: 整数卷积操作</span><br><span class="line">// 参数: wnd_size     : 模板窗口大小，这里就是模板的宽和高，当前只支持宽高一致的情况，需要是奇数</span><br><span class="line">//       unit_stride  : 卷积模板中每个元素对应的像素长度，默认为<span class="number">1</span></span><br><span class="line">//       template_data: 卷积模板数据，整型数据，其数据大小为 (lWndSize*lWndSize)  </span><br><span class="line">//       out_img      : 卷积结果输出图像</span><br><span class="line">// 返回：错误值  </span><br><span class="line">//</span><br><span class="line">int32_t XImage::ConvoluteInteger(</span><br><span class="line">  int32_t    wnd_size, </span><br><span class="line">  int32_t    unit_stride,</span><br><span class="line">  int32_t*  template_data,</span><br><span class="line">  XImage&amp;    out_img            )</span><br><span class="line">&#123;</span><br><span class="line">  int32_t   template_size = wnd_size * wnd_size;  // 模板元素数量</span><br><span class="line">  int32_t   half_wnd_size = wnd_size / <span class="number">2</span>;  // 半个窗口的宽高</span><br><span class="line">  int32_t   padding_size  = half_wnd_size * unit_stride;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!image_valid_)  &#123;</span><br><span class="line">    <span class="keyword">return</span> XERR_BAD_STATE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!IsSameParameter(out_img))</span><br><span class="line">  &#123;</span><br><span class="line">    out_img.Release( );</span><br><span class="line">    out_img.Allocate(pxl_format_, width_, height_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //</span><br><span class="line">  // 计算每个卷积元素相对于中心的偏移位置</span><br><span class="line">  //</span><br><span class="line">  int32_t i, j, k, x, y, z;</span><br><span class="line">  int32_t coeff_sum = <span class="number">0</span>;         // 统计系数累加和</span><br><span class="line">  XPoint* locate_offset = new XPoint[template_size];   // 各个卷积元素的偏移位置</span><br><span class="line">  XASSERT(locate_offset);</span><br><span class="line">  z = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (y = -half_wnd_size; y &lt;= half_wnd_size; y++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (x = -half_wnd_size; x &lt;= half_wnd_size; x++)</span><br><span class="line">    &#123;</span><br><span class="line">      locate_offset[z].x = x * unit_stride;</span><br><span class="line">      locate_offset[z].y = y * unit_stride;</span><br><span class="line">      coeff_sum += template_data[z];  // 统计模板系数之和</span><br><span class="line">      z++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // </span><br><span class="line">  // 对输入图像中每个像素点进行卷积操作，结果保存到输出图像中</span><br><span class="line">  //</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">1</span> == pixel_bytes_)</span><br><span class="line">  &#123;</span><br><span class="line">    uint8_t* dst_line = out_img.image_data_;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; out_img.height_; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      uint8_t* dst_data = dst_line;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; out_img.width_; j++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">float</span> sum_red = <span class="number">0</span>, sum_green = <span class="number">0</span>, sum_blue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; template_size; k++)</span><br><span class="line">        &#123;</span><br><span class="line">          // 计算模板元素对应在原图中的像素位置, 超出边缘的直接以边缘图像数据为准</span><br><span class="line">          y = j + padding_size + locate_offset[k].y;</span><br><span class="line">          x = i + padding_size + locate_offset[k].x;</span><br><span class="line">          <span class="keyword">if</span> (x &lt; <span class="number">0</span>)         x = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> (x &gt;= height_)  x = height_ - <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> (y &lt; <span class="number">0</span>)         y = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> (y &gt; width_)    y = width_ - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          // 找到模板元素对应的原图中像素数据</span><br><span class="line">          uint8_t* source_data = image_data_ + (x * line_bytes_) + (y * pixel_bytes_);</span><br><span class="line"></span><br><span class="line">          // 进行卷积操作</span><br><span class="line">          sum_red   += source_data[<span class="number">0</span>] * template_data[k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 卷积累加后统一整除系数之和,进行正常化处理</span><br><span class="line">        sum_red /= coeff_sum;</span><br><span class="line"></span><br><span class="line">        // 将输出RGB颜色值控制在 [<span class="number">0</span>, <span class="number">255</span>]值域内  </span><br><span class="line">        dst_data[<span class="number">0</span>] = (XBYTE)(MAX(MIN(<span class="number">255</span>, sum_red), <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        dst_data += out_img.pixel_bytes_;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      dst_line += line_bytes_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    uint8_t* dst_line = out_img.image_data_;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; out_img.height_; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      uint8_t* dst_data = dst_line;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; out_img.width_; j++)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">float</span> sum_red = <span class="number">0</span>, sum_green = <span class="number">0</span>, sum_blue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; template_size; k++)</span><br><span class="line">        &#123;</span><br><span class="line">          // 计算模板元素对应在原图中的像素位置, 超出边缘的直接以边缘图像数据为准</span><br><span class="line">          y = j + padding_size + locate_offset[k].y;</span><br><span class="line">          x = i + padding_size + locate_offset[k].x;</span><br><span class="line">          <span class="keyword">if</span> (x &lt; <span class="number">0</span>)         x = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> (x &gt;= height_)  x = height_ - <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span> (y &lt; <span class="number">0</span>)         y = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> (y &gt; width_)    y = width_ - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">          // 找到模板元素对应的原图中像素数据</span><br><span class="line">          uint8_t* source_data = image_data_ + (x * line_bytes_) + (y * pixel_bytes_);</span><br><span class="line"></span><br><span class="line">          // 进行卷积操作</span><br><span class="line">          sum_red   += source_data[<span class="number">0</span>] * template_data[k];</span><br><span class="line">          sum_green += source_data[<span class="number">1</span>] * template_data[k];</span><br><span class="line">          sum_blue  += source_data[<span class="number">2</span>] * template_data[k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 卷积累加后统一整除系数之和,进行正常化处理</span><br><span class="line">        sum_red   /= coeff_sum;</span><br><span class="line">        sum_green /= coeff_sum;</span><br><span class="line">        sum_blue  /= coeff_sum;</span><br><span class="line"></span><br><span class="line">        // 将输出RGB颜色值控制在 [<span class="number">0</span>, <span class="number">255</span>]值域内  </span><br><span class="line">        dst_data[<span class="number">0</span>] = (XBYTE)(MAX(MIN(<span class="number">255</span>, sum_red), <span class="number">0</span>));</span><br><span class="line">        dst_data[<span class="number">1</span>] = (XBYTE)(MAX(MIN(<span class="number">255</span>, sum_green), <span class="number">0</span>));</span><br><span class="line">        dst_data[<span class="number">2</span>] = (XBYTE)(MAX(MIN(<span class="number">255</span>, sum_blue), <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        dst_data += out_img.pixel_bytes_;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      dst_line += line_bytes_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> XOK;</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">// 具体调用尝试</span><br><span class="line">//</span><br><span class="line">void TestConvolute()</span><br><span class="line">&#123;</span><br><span class="line">  XImage  org_img, gray_img;</span><br><span class="line">  org_img.LoadFromBmp(<span class="string">&quot;e:/24bit.bmp&quot;</span>);</span><br><span class="line">  org_img.Convert(PXL_FORMAT_8BIT_GRAY, gray_img);</span><br><span class="line"></span><br><span class="line">  // 这个一个 <span class="number">5</span>*<span class="number">5</span>窗口大小的卷积模板，与上面例子系数一样，只是转成整型数据</span><br><span class="line">  // 实际上是LOG锐化算子的模板</span><br><span class="line">  int32_t template_data[<span class="number">25</span>] = &#123; </span><br><span class="line">    -<span class="number">2</span>,  -<span class="number">4</span>,  -<span class="number">4</span>,  -<span class="number">4</span>,  -<span class="number">2</span>,</span><br><span class="line">    -<span class="number">4</span>,  <span class="number">0</span>,   <span class="number">8</span>,  <span class="number">0</span>,  -<span class="number">4</span>,</span><br><span class="line">    -<span class="number">4</span>,   <span class="number">8</span>,  <span class="number">80</span>,   <span class="number">8</span>,  -<span class="number">4</span>,</span><br><span class="line">    -<span class="number">4</span>,   <span class="number">0</span>,   <span class="number">8</span>,   <span class="number">0</span>,  -<span class="number">4</span>,</span><br><span class="line">    -<span class="number">2</span>,  -<span class="number">4</span>,  -<span class="number">4</span>,  -<span class="number">4</span>,  -<span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  XImage  convolute_img, gray_convolute_img;</span><br><span class="line">  ret = org_img.ConvoluteFloat(<span class="number">5</span>, <span class="number">1</span>, template_data, convolute_img);</span><br><span class="line">  convolute_img.SaveToBmp(<span class="string">&quot;e:/convolute.bmp&quot;</span>);  </span><br><span class="line">  ret = gray_img.ConvoluteFloat(<span class="number">5</span>, <span class="number">1</span>, template_data, gray_convolute_img);</span><br><span class="line">  gray_convolute_img.SaveToBmp(<span class="string">&quot;e:/gray_convolute.bmp&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>边缘检测分割</title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E5%88%86%E5%89%B2/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B%E5%88%86%E5%89%B2/</url>
    <content><![CDATA[<p><a href="../%E7%A9%BA%E9%97%B4%E5%9F%9F%E6%BB%A4%E6%B3%A2%E5%99%A8/%E7%A9%BA%E9%97%B4%E5%9F%9F%E6%BB%A4%E6%B3%A2%E5%99%A8.md" title="空间域滤波器">空间域滤波器</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/378130527" title="https://zhuanlan.zhihu.com/p/378130527">https://zhuanlan.zhihu.com/p/378130527</a>?</p>
]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E8%BE%B9%E7%BC%98%E8%BF%BD%E8%B8%AA/%E8%BE%B9%E7%BC%98%E8%BF%BD%E8%B8%AA/</url>
    <content><![CDATA[<h1 id="边缘追踪"><a href="#边缘追踪" class="headerlink" title="边缘追踪"></a>边缘追踪</h1>]]></content>
  </entry>
  <entry>
    <title>运动检测</title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E8%BF%90%E5%8A%A8%E6%A3%80%E6%B5%8B/%E8%BF%90%E5%8A%A8%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>股票交易技术面分析</title>
    <url>/2024/02/08/%E9%87%91%E8%9E%8D/%E8%82%A1%E7%A5%A8%E6%8A%80%E6%9C%AF%E9%9D%A2%E5%88%86%E6%9E%90/%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="单根K线"><a href="#单根K线" class="headerlink" title="单根K线"></a>单根K线</h1><p>包含市场价格&#x2F;指数在过去单位时间内走势的4个指标<br>1）上影线（最值）<br>2）下影线<br>3）开盘价&#x2F;指数<br>4）收盘价&#x2F;指数</p>
<h2 id="典型K线形态"><a href="#典型K线形态" class="headerlink" title="典型K线形态"></a>典型K线形态</h2><p>其本质是判断市场情绪<br>大阳线：影线很短，收盘价&gt;&gt;开盘价；反应买入力量强；过去单位时间内大概率处于上涨趋势<br>大阴线：收盘价&lt;&lt;开盘价;市场悲观，纷纷抛售；过去单位时间内大概率处于下跌趋势<br>锤子线：有一个较小实体；下影线很长，几乎没有上影线；过去单位时间内出现凹形拐点；有可能是市场回归理性的信号；有概率是某个时间段内买入的好时机（判断是否出现在下降趋势中增加概率）<br>射击之星：有一个较小实体；上影线很长，几乎没有下影线；过去单位时间内出现凸形拐点；有可能是市场回归理性的信号；有概率是某个时间段内卖出的好时机（判断是否出现在上升趋势中增加概率）<br>十字线：上下影线很长；收盘接近于开盘；反应市场买卖双方力量接近；有较大不确定性</p>
<p><img src="/image/image_SFfYoB7bo_.png"></p>
<p>大阳</p>
<p><img src="/image/image_Rf8ng17FWZ.png"></p>
<p>大阴</p>
<p><img src="/image/image_lmGxD5Vt8P.png"></p>
<p>锤子</p>
<p><img src="/image/image_MkZwo0Os8m.png"></p>
<p>射击之星</p>
<p><img src="/image/image_Nqocgi5Kg3.png"></p>
<p>十字线</p>
<p><img src="/image/image_kKoG4PS3o8.png"></p>
<h1 id="多根K线分析"><a href="#多根K线分析" class="headerlink" title="多根K线分析"></a>多根K线分析</h1><p>典型凹形拐点</p>
<p>1）低开高走：在下降趋势中，前一天还处于下降；后一天还没开盘时依然处于看空状态（开盘比前天收盘还低），但交易中却慢慢回升，收盘价超过前天降幅一半以上（若收盘&gt;前天开盘；完全补上前天跌幅；见底概率上升）；有概率是下降趋势的后期（近谷底），可适当买入<br>2）高开高走：在下降趋势中，前一天还处于下降；后一天还没开盘时却处于看多状态（开盘比前天收盘高），交易中价格回升，价格中位数超过收盘价超过前天开盘价；有概率是下降趋势的后期（近谷底），可考虑抄底吸纳</p>
<p><img src="/image/image_CzFeVHjxFQ.png"></p>
<p>低开高走</p>
<p><img src="/image/image_LgBSSWlBhK.png"></p>
<p>高开高走</p>
<p>典型凸形拐点</p>
<p>1）高开低走：在上升趋势中，前一天还处于上涨；后一天还没开盘就处于看涨状态（开盘比前天收盘高），但交易期间慢慢回落至低于前天涨幅一半以下（若收盘&lt;前天开盘；抹除了前天涨幅；见顶概率上升）；有概率是上涨趋势的尾声（见顶），市场看空；可清仓或减半<br>2）低开低走：在上升趋势中，前一天还处于上涨；后一天还没开盘就处于看空状态（开盘比前天收盘低），且价格中位数低于前天收盘价；有概率是上涨趋势的尾声（见顶），市场看空；可开始减仓</p>
<p><img src="/image/image_GwXB3uNZ8b.png"></p>
<p>高开低走</p>
<p><img src="/image/image_et3IITZtN-.png"></p>
<p>低开低走</p>
<h1 id="成交量"><a href="#成交量" class="headerlink" title="成交量"></a>成交量</h1><p>反应市场情绪和资金流入情况</p>
<p><img src="/image/image_rwvt3-IH7y.png"></p>
<p>缩量：<br>1）供过于求：有人卖没人买；市场保持观望态度<br>2）供不应求：有人买没人卖；多数看多<br>增量（具有欺骗性）：<br>1）有人买有人卖</p>
<h2 id="量价关系"><a href="#量价关系" class="headerlink" title="量价关系"></a>量价关系</h2><p>1）价涨量增：成本上升；却依然有上涨的需求⇒市场看多力量强；若为缺口式上涨,成本大幅却丝毫不影响需求侧，反应市场买方力量强劲，供不应求（真正看好价格持续上涨应该成交量下跌；但却出现更多次成交）</p>
<p><img src="/image/image_SjsiVPjbA_.png"></p>
<p>2）价跌量缩（平）：若是上升阶段，则表示不愿意卖出，还认为会上涨；市场保持观望态度</p>
<p><img src="/image/image_L_dLJqZRyb.png"></p>
<p>3）价跌量增：常出现于下跌中后期，市场投资者快速大量抛售；若是看好这只股票，那么这是捡便宜的好时机（熊市机会）</p>
<p><img src="/image/image_HrJQqG0Taq.png"></p>
<p>4）价涨量跌：若处于上升阶段；表示持股人认为股价会持续上涨，倾向继续持有，且买方加价；成交量下跌；属于正常现象；<br>若处于下跌阶段，反弹初期；市场供过于求表现为量缩，在此入场是好机会</p>
<p><img src="/image/image_PUwUGF86Mi.png"></p>
<p><img src="/image/image_RETOZ0ODs8.png"></p>
<p>均量线：周期时间内成交量的数学期望；反应周期单位时间的成交量波动水平（感觉是多余概念，不如直接看成交量）</p>
<h1 id="技术指标"><a href="#技术指标" class="headerlink" title="技术指标"></a>技术指标</h1><h2 id="趋势线"><a href="#趋势线" class="headerlink" title="趋势线"></a>趋势线</h2><p>阻力线（市场预期股价上界），支撑线（市场预期股价下界，碰到就反弹），其在过去某个周期时间内的斜率体现了一种市场共识；<br>1）双线斜率&gt;0：过去周期内市场情绪多数看多<br>2）双线&lt;0：过去周期内市场情绪多数看空<br>3）多次越过上个周期的趋势线；进入新周期，原有趋势被打破；（做多时跌破支撑线：考虑抛售，等待下一个趋势；）<br>3）双线交汇：原有趋势被打破，阻力线变成支撑线；支撑线变阻力线，考虑买入</p>
<h2 id="移动平均线Ema"><a href="#移动平均线Ema" class="headerlink" title="移动平均线Ema"></a>移动平均线Ema</h2><p><a href="https://www.youtube.com/watch?v=bHY9XMRKWDA&t=517s" title="  https://www.youtube.com/watch?v=bHY9XMRKWDA&amp;t=517s">  https://www.youtube.com/watch?v=bHY9XMRKWDA&amp;t&#x3D;517s</a></p>
<p>单位周期时间内收盘价的加权平均值；相当于给金融资产价格的离散信号进行了平滑（均值）滤波；ema模板的权重应该是符合指数分布的；就是平滑了噪声的价格走势线</p>
<h2 id="RSI"><a href="#RSI" class="headerlink" title="RSI"></a>RSI</h2><p><a href="https://zhuanlan.zhihu.com/p/62868406" title=" RSI指标详解，解密它的致命缺陷 文章开始之前强烈推荐 专栏|我的交易系统最经典的系列文章： 1我的交易系统| 趋势研究的本质 2我的交易系统| 概率游戏 3我的交易系统| K线是规则的承载之量价时空分析法 4我的交易系统| 什么样的个股会长期上涨 5… https://zhuanlan.zhihu.com/p/62868406"> RSI指标详解，解密它的致命缺陷 文章开始之前强烈推荐 专栏|我的交易系统最经典的系列文章： 1我的交易系统| 趋势研究的本质 2我的交易系统| 概率游戏 3我的交易系统| K线是规则的承载之量价时空分析法 4我的交易系统| 什么样的个股会长期上涨 5… https://zhuanlan.zhihu.com/p/62868406</a></p>
<p>通过比较一段时间内的价格上涨幅度每单位净变化，来评估市场的多空力量和价格的强弱程度(供需强弱：过去单位净增幅变化1时的增幅强度)<br>RSI（N日） &#x3D; $100<em>\frac{N日内收盘涨幅均值}{N日内收盘涨跌幅均值的绝对值}$&#x3D;$100</em>\frac{1}{1+\frac{1}{RS}}$&#x3D;$100<em>\frac{RS}{1+RS}&#x3D;100</em>(1-\frac{1}{1+RS})$<br>当RSI&gt;70:需求&gt;供给：高位套现？加仓？<br>当RSI&lt;30：需求&lt;供给：抄底？止损？<br>背离：股价上升；需求减弱（逃顶？）；股价下降；需求上涨（可能要反弹？）<br>失效：单边趋势；即使这些震荡因素判断对了也无法阻止的总体价值走势</p>
<p><img src="/image/image_i3uOb5JQuY.png"></p>
<p><img src="/image/image_qQspW9Aik1.png"></p>
<p>macd</p>
<p>短期均线（趋势）与长期均线的残差DIF&#x3D;ema(c,12)-ema(c,26)；DEA&#x3D;DIF&#x2F;9消除了随机误差项，即短期趋势与长期趋势的真正差别；如果你假设长期趋势与短期趋势之间的随机误差实质是市场情绪因素造成的；<br>则BAR&#x3D;DIF-DEA即反应市场情绪：<br>BAR&gt;0：买方&gt;卖方;快线高过慢线的交叉点是买入时机<br>BAR&lt;0：卖方&gt;买方;慢线高过快线的交叉点前抛售</p>
<h2 id="vmacd"><a href="#vmacd" class="headerlink" title="vmacd"></a>vmacd</h2><p>kdj</p>
<p>RSV&#x3D;$\frac{收盘价 - N日最低价}{N日最高价 - N日最低价} * 100$；反映收盘价处于N日内价格波动区间的位置；判断收盘价处于N日内投资者预期价的相对位置（只能判断短期震荡趋势中的相对位置；进而判断超买超卖）<br>K&#x3D;$\frac{2}{3}\cdot$前一日K值+$\frac{1}{3}\cdot$当日RSV值 ;RSV与历史K值加权平均可以去噪，加权值是试出来的（短期震荡可能十分剧烈）<br>D&#x3D;$\frac{2}{3}\cdot$前一日D值+$\frac{1}{3}\cdot$当日K值；<br>J&#x3D;3K-2D</p>
]]></content>
      <categories>
        <category>金融</category>
      </categories>
      <tags>
        <tag>金融</tag>
      </tags>
  </entry>
  <entry>
    <title>通道变换</title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E9%80%9A%E9%81%93%E5%8F%98%E6%8D%A2/%E9%80%9A%E9%81%93%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<p>像素点都是单独处理的，有利于用GPU加速优化；像素点(x,y)的模型都是n元排列：ex:（R,G,B）<br>像素点处理就是对n元排列各分量（颜色通道）进行变换$G(x,y) &#x3D; Trans(I(x,y))$</p>
<h1 id="图像反色1-x"><a href="#图像反色1-x" class="headerlink" title="图像反色1-x"></a>图像反色1-x</h1><p><img src="/image/image_uvS6eSVux3.png"></p>
<p><img src="/image/image_wv5SW6ToMk.png"></p>
<p><img src="/image/image_2cyheZ2pXW.png"></p>
<p><img src="/image/image__rOeyDeVVL.png"></p>
<p>步骤：<br>1）拿出像素各分量值uint8_t ，进行归一化映射<br>2）反色 变换：1.0-gray<br>3)归一化逆映射再存储</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 功能：进行单通道反色变换，对于RGB彩色颜色值，各个通道分别调用该函数</span></span><br><span class="line"><span class="comment">// 输入: nInputData : 单通道颜色值,值在[0, 255]</span></span><br><span class="line"><span class="comment">// 返回: 变换后的颜色值,值在[0, 255]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Trans_Reverse</span><span class="params">(<span class="type">uint8_t</span> nInputData)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 归一化输入的颜色值  </span></span><br><span class="line">  <span class="type">double</span> fInData = (<span class="type">double</span>)nInputData / <span class="number">255.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进行反色变换</span></span><br><span class="line">  <span class="type">double</span> fTransVal = <span class="number">1.0</span> - fInData;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 将变换后的值重新还原到 [0, 255] 区间</span></span><br><span class="line">  <span class="type">uint8_t</span> nRetVal = (<span class="type">uint8_t</span>)(fTransVal * <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nRetVal;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Trans_ReverseFast</span><span class="params">(<span class="type">uint8_t</span> nInputData)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 直接反色变换，这个计算最快</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="number">255</span>-nInputData);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h1 id="对数变换-Alog-x-offset"><a href="#对数变换-Alog-x-offset" class="headerlink" title="对数变换$Alog(x-offset)$"></a>对数变换$Alog(x-offset)$</h1><p>对数函数特点：先快速增长（斜率&gt;1），再慢速增长(斜率&lt;1)<br>1）使较暗像素变亮，使较亮像素变暗<br>2）快速点亮较暗部分，缓慢点亮较暗部分（改变像素灰度分布，使像素更多分布在高灰度区域，可以将原本低灰度区域细节表现得更多一些）</p>
<p><img src="/image/image_9EAbjdZgAt.png"></p>
<p><img src="/image/image_kSo4QowQbI.png"></p>
<p><img src="/image/image_OBlC1PlPiQ.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 功能：进行单通道对数变换，对于RGB彩色颜色值，各个通道分别调用该函数</span></span><br><span class="line"><span class="comment">// 输入: nInputData : 单通道颜色值,值在[0, 255]</span></span><br><span class="line"><span class="comment">// 返回: 变换后的颜色值,值在[0, 255]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Trans_Log</span><span class="params">(<span class="type">uint8_t</span> nInputData)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 归一化输入的颜色值  </span></span><br><span class="line">  <span class="type">double</span> fInData = (<span class="type">double</span>)nInputData / <span class="number">255.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进行指数变换</span></span><br><span class="line">  <span class="type">double</span> fAmplitude = <span class="number">1.2</span>;   <span class="comment">// 幅度变换系数</span></span><br><span class="line">  <span class="type">double</span> fTransVal = fAmplitude * ln(fInData + <span class="number">1.0</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 将变换后的值重新还原到 [0, 255] 区间</span></span><br><span class="line">  fTransVal = MIN( MAX(<span class="number">0</span>, fTransVal ), <span class="number">1.0</span>);  <span class="comment">//筛出&gt;0部分，再筛出小于1部分</span></span><br><span class="line">  <span class="type">uint8_t</span> nRetVal = (<span class="type">uint8_t</span>)(fTransVal * <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nRetVal;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h1 id="指数（伽马）变换-Ax-gamma"><a href="#指数（伽马）变换-Ax-gamma" class="headerlink" title="指数（伽马）变换$Ax^\gamma$"></a>指数（伽马）变换$Ax^\gamma$</h1><p>γ&gt;1.0，变换后图像整体亮度变暗；较低灰度像素变多，较高灰度像素数量减少<br>γ&lt;1.0，变换后图像整体亮度变亮；较高灰度像素变多，较低灰度像素数量减少</p>
<p><img src="/image/image_RYme7FVS8q.png"></p>
<p>$Y &#x3D; X ^ {0.4}$</p>
<p><img src="/image/image_QIaN1hKrDy.png"></p>
<p>$Y &#x3D; X ^ {2.5}$</p>
<p><img src="/image/image_ZB9gt8PWAc.png"></p>
<p><img src="/image/image_ZzynetnwXN.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 功能：进行单通道指数变换，对于RGB彩色颜色值，各个通道分别调用该函数</span></span><br><span class="line"><span class="comment">// 输入: nInputData : 单通道颜色值,值在[0, 255]</span></span><br><span class="line"><span class="comment">// 返回: 变换后的颜色值,值在[0, 255]</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Trans_Index</span><span class="params">(<span class="type">uint8_t</span> nInputData)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 归一化输入的颜色值  </span></span><br><span class="line">  <span class="type">double</span> fInData = (<span class="type">double</span>)nInputData / <span class="number">255.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进行指数变换</span></span><br><span class="line">  <span class="type">double</span> fAmplitude = <span class="number">1.0</span>;   <span class="comment">// 幅度变换系数</span></span><br><span class="line">  <span class="type">double</span> fGama = <span class="number">0.4</span>;        <span class="comment">// 指数系数</span></span><br><span class="line">  <span class="type">double</span> fTransVal = fAmplitude * power(fInData, fGama);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 将变换后的值重新还原到 [0, 255] 区间</span></span><br><span class="line">  fTransVal = MIN( MAX(<span class="number">0</span>, fTransVal ), <span class="number">1.0</span>);  </span><br><span class="line">  <span class="type">uint8_t</span> nRetVal = (<span class="type">uint8_t</span>)(fTransVal * <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nRetVal;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h1 id="分段线性变换-frac-1-1-e-A-x-offset"><a href="#分段线性变换-frac-1-1-e-A-x-offset" class="headerlink" title="分段线性变换$\frac{1}{1+e^{-A(x-offset)}}$"></a>分段线性变换$\frac{1}{1+e^{-A(x-offset)}}$</h1><p>Sigmoid函数$\frac{1}{1+e^{-t}}$;R→(0,1);其在0.5处中心对称；通过调节频率和相位使其有较好的2分性质；<br>使暗灰度区域更暗，亮灰度区域更亮，使整张图像亮&#x2F;暗两区域区别更明显。通常用于增加对比度调节$i_{max}-i_{min}$，</p>
<p><img src="/image/image_r4WXxASd9T.png"></p>
<p><img src="/image/image_38cNocURCA.png"></p>
<p><img src="/image/image_KKRidLm3Nm.png"></p>
<p><img src="/image/image_rWsrdZNmDA.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 功能：进行单通道Sigmoid变换，对于RGB彩色颜色值，各个通道分别调用该函数</span></span><br><span class="line"><span class="comment">// 输入: nInputData : 单通道颜色值,值在[0, 255]</span></span><br><span class="line"><span class="comment">// 返回: 变换后的颜色值,值在[0, 255]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Trans_Sigmoid</span><span class="params">(<span class="type">uint8_t</span> nInputData)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 归一化输入的颜色值  </span></span><br><span class="line">  <span class="type">double</span> fInData = (<span class="type">double</span>)nInputData / <span class="number">255.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进行Sigmoid变换</span></span><br><span class="line">  <span class="type">double</span> fTransVal = <span class="number">1.0</span> / (<span class="number">1.0</span> + <span class="built_in">exp</span>(<span class="number">-10.0</span>*(fInData<span class="number">-0.5</span>)));</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 将变换后的值重新还原到 [0, 255] 区间</span></span><br><span class="line">  fTransVal = MIN( MAX(<span class="number">0</span>, fTransVal ), <span class="number">1.0</span>);  </span><br><span class="line">  <span class="type">uint8_t</span> nRetVal = (<span class="type">uint8_t</span>)(fTransVal * <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nRetVal;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h1 id="滤镜算法"><a href="#滤镜算法" class="headerlink" title="滤镜算法"></a>滤镜算法</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief Filter function for RGB channel</span></span><br><span class="line"><span class="comment">* @param user_data   -- user data</span></span><br><span class="line"><span class="comment">* @param pxl_format  -- pixel format, in &amp; out have same pixel format</span></span><br><span class="line"><span class="comment">* @param pixel_bytes -- bytes of one pixel</span></span><br><span class="line"><span class="comment">* @param line_bytes  -- bytes of one line pixel</span></span><br><span class="line"><span class="comment">* @param in_pxl_data -- input RGB/RGBA/Gray data</span></span><br><span class="line"><span class="comment">* @param out_pxl_data-- output RGB/RGBA/Gray data</span></span><br><span class="line"><span class="comment">* @return None</span></span><br><span class="line"><span class="comment">* //1）检查输入图像的格式，2）遍历像素进行变换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*PFN_FILTER)</span><span class="params">(<span class="comment">//定义指向返回值为void函数的指针PFN_FILTER，用于将函数作为参数传入</span></span></span></span><br><span class="line"><span class="params"><span class="function">              XVOID* user_data, </span></span></span><br><span class="line"><span class="params"><span class="function">              PXL_FORMAT pxl_format, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int32_t</span> pixel_bytes, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int32_t</span> line_bytes,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">uint8_t</span>* in_pxl_data,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">uint8_t</span>* out_pxl_data   )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 通道变换处理，将变换函数指针作为参数输入，应用层可以实现不同的变换函数</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">XImage::Filter</span><span class="params">(PFN_FILTER fnFilter, <span class="type">void</span>* user_data, XImage&amp; out_img)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int32_t</span> i, j, ret;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fnFilter == <span class="literal">nullptr</span>)  &#123;</span><br><span class="line">    <span class="keyword">return</span> XERR_INVALID_PARAM;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!image_valid_)  &#123;</span><br><span class="line">    <span class="keyword">return</span> XERR_BAD_STATE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">IsSameParameter</span>(out_img))</span><br><span class="line">  &#123;</span><br><span class="line">    out_img.<span class="built_in">Release</span>( );</span><br><span class="line">    ret = out_img.<span class="built_in">Allocate</span>(pxl_format_, width_, height_);</span><br><span class="line">    <span class="built_in">XASSERT</span>(ret == XOK);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span>* src_line = image_data_;</span><br><span class="line">  <span class="type">uint8_t</span>* dst_line = out_img.image_data_;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; height_; i++)  </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">uint8_t</span>* src_data = src_line;</span><br><span class="line">    <span class="type">uint8_t</span>* dst_data = dst_line;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; width_; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      (fnFilter)(user_data, pxl_format_, pixel_bytes_, line_bytes_, src_data, dst_data);<span class="comment">//还能通过指针调用函数。。。</span></span><br><span class="line">                               </span><br><span class="line">      src_data += pixel_bytes_;</span><br><span class="line">      dst_data += out_img.pixel_bytes_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    src_line += line_bytes_;</span><br><span class="line">    dst_line += out_img.line_bytes_;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> XOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、反色变换函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反色变换处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XImageFilterReserve</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  XVOID* user_data, </span></span></span><br><span class="line"><span class="params"><span class="function">  PXL_FORMAT pxl_format, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">int32_t</span> pixel_bytes, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">int32_t</span> line_bytes,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">uint8_t</span>* in_pxl_data, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">uint8_t</span>* out_pxl_data    )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pixel_bytes == <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    out_pxl_data[<span class="number">0</span>] = <span class="number">255</span> - in_pxl_data[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pixel_bytes == <span class="number">3</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    out_pxl_data[<span class="number">0</span>] = <span class="number">255</span> - in_pxl_data[<span class="number">0</span>];</span><br><span class="line">    out_pxl_data[<span class="number">1</span>] = <span class="number">255</span> - in_pxl_data[<span class="number">1</span>];</span><br><span class="line">    out_pxl_data[<span class="number">2</span>] = <span class="number">255</span> - in_pxl_data[<span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">XImage  org_img, reverse_img;</span><br><span class="line">org_img.<span class="built_in">LoadFromBmp</span>(<span class="string">&quot;e:/24bit.bmp&quot;</span>);</span><br><span class="line">org_img.<span class="built_in">Filter</span>(XImageFilterReserve, <span class="literal">nullptr</span>, reverse_img);<span class="comment">//函数名是指针。。。</span></span><br><span class="line">reverse_img.<span class="built_in">SaveToBmp</span>(<span class="string">&quot;e:/reverse.bmp&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>2、指数变换：<br>指数变换通常比较适合用于灰度图，而对于RGB24位色虽然也可以使用指数变换，但是容易导致失真，在调整对比度我们通常会采用其他的算法来进行处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">XImageFilterLog</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  XVOID* user_data, </span></span></span><br><span class="line"><span class="params"><span class="function">  PXL_FORMAT pxl_format, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">int32_t</span> pixel_bytes, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">int32_t</span> line_bytes,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">uint8_t</span>* in_pxl_data, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">uint8_t</span>* out_pxl_data    )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pixel_bytes == <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 归一化输入的颜色值  </span></span><br><span class="line">    <span class="type">double</span> normal_data = (<span class="type">double</span>)(in_pxl_data[<span class="number">0</span>]) / <span class="number">255.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行指数变换</span></span><br><span class="line">    <span class="type">double</span> amplitude = <span class="number">1.5</span>;   <span class="comment">// 幅度变换系数</span></span><br><span class="line">    <span class="type">double</span> log_data = amplitude * <span class="built_in">log</span>(normal_data + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">if</span> (log_data &lt; <span class="number">0</span>)  log_data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (log_data &gt; <span class="number">1.0f</span>) log_data = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    out_pxl_data[<span class="number">0</span>] = (<span class="type">uint8_t</span>)(log_data * <span class="number">255</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pixel_bytes == <span class="number">3</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">double</span> normal_r = (<span class="type">double</span>)(in_pxl_data[<span class="number">0</span>]) / <span class="number">255.0</span>;</span><br><span class="line">    <span class="type">double</span> normal_g = (<span class="type">double</span>)(in_pxl_data[<span class="number">1</span>]) / <span class="number">255.0</span>;</span><br><span class="line">    <span class="type">double</span> normal_b = (<span class="type">double</span>)(in_pxl_data[<span class="number">2</span>]) / <span class="number">255.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> amplitude = <span class="number">1.5</span>;   <span class="comment">// 幅度变换系数</span></span><br><span class="line">    <span class="type">double</span> log_r = amplitude * <span class="built_in">log</span>(normal_r + <span class="number">1.0</span>);</span><br><span class="line">    <span class="type">double</span> log_g = amplitude * <span class="built_in">log</span>(normal_g + <span class="number">1.0</span>);</span><br><span class="line">    <span class="type">double</span> log_b = amplitude * <span class="built_in">log</span>(normal_b + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">if</span> (normal_r &lt; <span class="number">0</span>)  normal_r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (normal_r &gt; <span class="number">1.0f</span>) normal_r = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">if</span> (normal_g &lt; <span class="number">0</span>)  normal_g = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (normal_g &gt; <span class="number">1.0f</span>) normal_g = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="keyword">if</span> (normal_b &lt; <span class="number">0</span>)  normal_b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (normal_b &gt; <span class="number">1.0f</span>) normal_b = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    out_pxl_data[<span class="number">0</span>] = (<span class="type">uint8_t</span>)(log_r * <span class="number">255</span>);</span><br><span class="line">    out_pxl_data[<span class="number">1</span>] = (<span class="type">uint8_t</span>)(log_g * <span class="number">255</span>);</span><br><span class="line">    out_pxl_data[<span class="number">2</span>] = (<span class="type">uint8_t</span>)(log_b * <span class="number">255</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">XImage  org_img, gray_img, log_img;</span><br><span class="line">org_img.<span class="built_in">LoadFromBmp</span>(<span class="string">&quot;e:/24bit.bmp&quot;</span>);</span><br><span class="line">org_img.<span class="built_in">Convert</span>(PXL_FORMAT_8BIT_GRAY, gray_img);</span><br><span class="line">gray_img.<span class="built_in">Filter</span>(XImageFilterLog, <span class="literal">nullptr</span>, log_img);</span><br><span class="line">log_img.<span class="built_in">SaveToBmp</span>(<span class="string">&quot;e:/log.bmp&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>通道变换时，浮点计算会比较耗时，考虑到每个通道像素值∈[0, 255]，且每个像素是独立变换，因此可空间换时间，把0~255所有的变换值先计算出来，然后在像素遍历的时候就直接查询计算好的结果O(1).这种方法几乎适合所有的通道变换算法，我们称之为<strong>查表法</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 预先计算好的数据 存放到 log_tab 数组表中</span></span><br><span class="line"><span class="type">uint8_t</span> log_tab[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">XImageFilterLog</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  XVOID* user_data, </span></span></span><br><span class="line"><span class="params"><span class="function">  PXL_FORMAT pxl_format, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">int32_t</span> pixel_bytes, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">int32_t</span> line_bytes,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">uint8_t</span>* in_pxl_data, </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">uint8_t</span>* out_pxl_data    )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pixel_bytes == <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    out_pxl_data[<span class="number">0</span>] = log_tab[in_pxl_data[<span class="number">0</span>]];  <span class="comment">// 直接查询表方式,性能快很多</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pixel_bytes == <span class="number">3</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    out_pxl_data[<span class="number">0</span>] = log_tab[in_pxl_data[<span class="number">0</span>]];</span><br><span class="line">    out_pxl_data[<span class="number">1</span>] = log_tab[in_pxl_data[<span class="number">1</span>]];</span><br><span class="line">    out_pxl_data[<span class="number">2</span>] = log_tab[in_pxl_data[<span class="number">2</span>]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 预先进行指数变换计算,结果存放到表格中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 归一化输入的颜色值  </span></span><br><span class="line">    <span class="type">double</span> normal_data = (<span class="type">double</span>)(i) / <span class="number">255.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行指数变换</span></span><br><span class="line">    <span class="type">double</span> amplitude = <span class="number">1.5</span>;   <span class="comment">// 幅度变换系数</span></span><br><span class="line">    <span class="type">double</span> log_data = amplitude * <span class="built_in">log</span>(normal_data + <span class="number">1.0</span>);</span><br><span class="line">    <span class="keyword">if</span> (log_data &lt; <span class="number">0</span>)  log_data = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (log_data &gt; <span class="number">1.0f</span>) log_data = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    log_tab[i] = (<span class="type">uint8_t</span>)(log_data * <span class="number">255</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">XImage  org_img, gray_img, log_img;</span><br><span class="line">org_img.<span class="built_in">LoadFromBmp</span>(<span class="string">&quot;e:/24bit.bmp&quot;</span>);</span><br><span class="line">org_img.<span class="built_in">Convert</span>(PXL_FORMAT_8BIT_GRAY, gray_img);</span><br><span class="line">gray_img.<span class="built_in">Filter</span>(XImageFilterLog, <span class="literal">nullptr</span>, log_img);</span><br><span class="line">log_img.<span class="built_in">SaveToBmp</span>(<span class="string">&quot;e:/log.bmp&quot;</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>阈值分割</title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/%E9%98%88%E5%80%BC%E5%88%86%E5%89%B2/</url>
    <content><![CDATA[<h2 id="二值分割"><a href="#二值分割" class="headerlink" title="二值分割"></a><strong>二值分割</strong></h2><p>适合背景简单的图像内容，如绿幕抠图等简单的前后景分离</p>
<p><img src="/image/image_WeKxaO1Pa_.png"></p>
<p>当像素点的RGB与背景绿色值 (0x00, 0x00, 0xFF) 间的差距小于一定阈值，则判断该像素点为背景像素，否则为前景像素<br>$\sqrt((r-r_{back})^2+(g-g_{back})^2+(b-b_{back})^2)$&lt;阈值⇒背景<br>在实际工程化开发中，可以将 sqrt() 开平方计算拿掉，直接调大阈值范围，这样可以大大加快计算性能</p>
<h2 id="分水岭算法"><a href="#分水岭算法" class="headerlink" title="分水岭算法"></a>分水岭算法</h2><p>很多时候前后景像素的色彩差异值没有这么大，此时就需要对图像内容本身做分割处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>频域滤波器？？？？</title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E9%A2%91%E5%9F%9F%E6%BB%A4%E6%B3%A2%E5%99%A8%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%9F/%E9%A2%91%E5%9F%9F%E6%BB%A4%E6%B3%A2%E5%99%A8%EF%BC%9F%EF%BC%9F%EF%BC%9F%EF%BC%9F/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/374642386" title=" 图像算法原理与实践——图像增强之 频率域处理 本章重点讲解在频域范围内的滤波，主要是在傅里叶变换的频域内进行滤波等处理。 一、图像傅里叶频域变换 关于图像的二维傅里叶变换，已经有很多非常详细的资料说明了，本章节不再做细节说明，直接上代码。参考 下… https://zhuanlan.zhihu.com/p/374642386"> 图像算法原理与实践——图像增强之 频率域处理 本章重点讲解在频域范围内的滤波，主要是在傅里叶变换的频域内进行滤波等处理。 一、图像傅里叶频域变换 关于图像的二维傅里叶变换，已经有很多非常详细的资料说明了，本章节不再做细节说明，直接上代码。参考 下… https://zhuanlan.zhihu.com/p/374642386</a></p>
]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>AWTK</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/AWTK/AWTK/</url>
    <content><![CDATA[<p><a href="https://www.zlg.cn/index/pub/awtk.html#d2" title=" AWTK专栏-广州致远电子股份有限公司 AWTK全称为Toolkit AnyWhere，是ZLG倾心打造的一套基于C语言开发的GUI框架。旨在为用户提供一个功能强大、高效可靠、简单易用、可轻松做出炫酷效果的GUI引擎，并支持跨平台同步开发，一次编程，终生使用。 https://www.zlg.cn/index/pub/awtk.html#d2"> AWTK专栏-广州致远电子股份有限公司 AWTK全称为Toolkit AnyWhere，是ZLG倾心打造的一套基于C语言开发的GUI框架。旨在为用户提供一个功能强大、高效可靠、简单易用、可轻松做出炫酷效果的GUI引擎，并支持跨平台同步开发，一次编程，终生使用。 https://www.zlg.cn/index/pub/awtk.html#d2</a></p>
<ol>
<li>如何渲染render和刷新refresh界面？ 在获取对象树或者渲染树object tree&#x2F;render tree之后，需要将其绘制到帧缓冲区上。这个过程可以由CPU或者GPU完成，以什么格式绘制取决于具体情况。当节点的状态发生改变时，需要进行刷新，但是什么时候刷新取决于具体需求。</li>
</ol>
<p><a href="awtk%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%90%AD%E5%BB%BA/awtk%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%90%AD%E5%BB%BA.md" title="awtk基础设施搭建">awtk基础设施搭建</a></p>
<ol>
<li>如何描述界面？ 界面通常可以用像XML的树状结构来描述。<br>1）选择一种框架，设置环境<br>2）布局&#x2F;定位<br>4)常用控件<br>5)样式</li>
</ol>
<p><a href="%E7%95%8C%E9%9D%A2%E6%8F%8F%E8%BF%B0/%E7%95%8C%E9%9D%A2%E6%8F%8F%E8%BF%B0.md" title="界面描述">界面描述</a></p>
<ol>
<li>如何管理界面的树状结构？ 处理剪裁clip、透明transparent等属性，以及布局layout管理和处理父节点关闭后子节点的情况等等。</li>
<li>用户点击界面上的元素该如何处理user event handling？ 可以使用函数指针（回调）function pointer(Callback)、信号&#x2F;槽机制 signal&#x2F;slot 或者观察者接口+注册observer interface＋ registration等方式来处理用户事件。</li>
<li>如何处理系统事件？ 这是比用户事件更广义的问题。a. 输入设备触发中断请求（IRQ）input device trigged，内核处理后传递给框架的处理程序。b. 将事件打包放入事件队列。c. 循环引擎分发事件：键盘事件发送给拥有焦点的部件，鼠标事件发送给光标下的部件。d. 如果目标部件没有处理该事件的处理程序，则将事件冒泡到根节点，直到有部件接受为止。</li>
<li>MVC架构的具体细节和术语jargon。</li>
<li>多线程、进程间通信IPC和共享内存的问题。</li>
</ol>
<p>7)如何发布程序<br>8)学习<a href="https://www.zhihu.com/search?q=%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:17583879%7D" title="界面设计">界面设计</a>，交互设计</p>
<p><a href="%E6%96%B0%E9%A1%B5%E9%9D%A2/%E6%96%B0%E9%A1%B5%E9%9D%A2.md" title="新页面">新页面</a></p>
<p><a href="%E6%96%B0%E9%A1%B5%E9%9D%A2_1/%E6%96%B0%E9%A1%B5%E9%9D%A2.md" title="新页面">新页面</a></p>
<p><a href="%E6%96%B0%E9%A1%B5%E9%9D%A2_2/%E6%96%B0%E9%A1%B5%E9%9D%A2.md" title="新页面">新页面</a></p>
<p><a href="%E6%96%B0%E9%A1%B5%E9%9D%A2_3/%E6%96%B0%E9%A1%B5%E9%9D%A2.md" title="新页面">新页面</a></p>
<p><a href="%E6%96%B0%E9%A1%B5%E9%9D%A2_4/%E6%96%B0%E9%A1%B5%E9%9D%A2.md" title="新页面">新页面</a></p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU binutils</title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/GNU%20binutils/GNU%20binutils/</url>
    <content><![CDATA[<h1 id="cpp预处理器"><a href="#cpp预处理器" class="headerlink" title="cpp预处理器"></a>cpp预处理器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cpp hello.c &gt; hello.i</span><br><span class="line">more helli.i</span><br><span class="line"><span class="comment">#宏展开、条件编译、包含其他文件等操作</span></span><br><span class="line"></span><br><span class="line">gcc -Wall -S hello.i -o hello.s</span><br><span class="line">more hello.s</span><br><span class="line"><span class="comment">#转换成汇编语言</span></span><br></pre></td></tr></table></figure>

<h1 id="as汇编器"><a href="#as汇编器" class="headerlink" title="as汇编器"></a>as汇编器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">as hello.s -o hello.o</span><br><span class="line">file hello.o</span><br><span class="line"><span class="comment">#将汇编语言代码转换为机器码指令，生成目标文件；file查看文件类型</span></span><br></pre></td></tr></table></figure>

<h1 id="ld-链接器"><a href="#ld-链接器" class="headerlink" title="ld 链接器"></a>ld 链接器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -v hello.o</span><br><span class="line">或ld -o output input1.o input2.o</span><br><span class="line"><span class="comment">#将目标文件和库文件链接生成可执行文件或共享库；因可执行文件通常需要外部函数</span></span><br></pre></td></tr></table></figure>

<h1 id="readelf读取-分析ELF格式文件工具"><a href="#readelf读取-分析ELF格式文件工具" class="headerlink" title="readelf读取&#x2F;分析ELF格式文件工具"></a>readelf读取&#x2F;分析ELF格式文件工具</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">readelf -h ./hello.o</span><br><span class="line"><span class="comment">#查看ELF文件头</span></span><br><span class="line">ldd ./hello</span><br><span class="line"><span class="comment">#查看hello依赖的动态库</span></span><br><span class="line"></span><br><span class="line">readelf -S</span><br><span class="line"><span class="comment">#查看段属性</span></span><br><span class="line"></span><br><span class="line">readelf -s </span><br><span class="line"><span class="comment">#查看符号表</span></span><br><span class="line"></span><br><span class="line">readelf -x .rodata a.out</span><br><span class="line"><span class="comment">#查看ELF文件数据块中的只读数据；这类用于查看磁盘地址所存内容</span></span><br></pre></td></tr></table></figure>

<h1 id="size列出-o-out各节大小和全部大小"><a href="#size列出-o-out各节大小和全部大小" class="headerlink" title="size列出.o&#x2F;.out各节大小和全部大小"></a>size列出.o&#x2F;.out各节大小和全部大小</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">size hello.o</span><br><span class="line"><span class="comment">#text 节：二进制文件代码部分，包含所有可执行指令。</span></span><br><span class="line"><span class="comment">#data 节：所有初始化数据所在的位置</span></span><br><span class="line"><span class="comment">#bss 节：未初始化数据的存储位置。</span></span><br><span class="line"><span class="comment">#在静态的映像文件中，各个部分称之为 节(section)，而在运行时的各个部分称之为 段(segment)</span></span><br></pre></td></tr></table></figure>

<h1 id="strings打印文件中的可打印字符串"><a href="#strings打印文件中的可打印字符串" class="headerlink" title="strings打印文件中的可打印字符串"></a>strings打印文件中的可打印字符串</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">strings -d hello.o</span><br><span class="line"><span class="comment">#（可执行文件）上运行 strings 会显示在链接阶段该二进制文件中包含的其他信息</span></span><br></pre></td></tr></table></figure>

<h1 id="objdump显示目标文件信息"><a href="#objdump显示目标文件信息" class="headerlink" title="objdump显示目标文件信息"></a>objdump显示目标文件信息</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objdump -d hello.o</span><br><span class="line"><span class="comment">#反汇编输出.text</span></span><br><span class="line">objdump -d hello.out | grep -A 9 main:&gt;</span><br><span class="line"><span class="comment">#从数据流中抓取main 函数</span></span><br><span class="line"></span><br><span class="line">objdump -h </span><br><span class="line"><span class="comment">#查看段属性</span></span><br><span class="line"></span><br><span class="line">objdump -s</span><br><span class="line"><span class="comment">#将所有段的内容以十六进制打印出来</span></span><br><span class="line"></span><br><span class="line">objdump -r</span><br><span class="line"><span class="comment">#查看重定位段</span></span><br></pre></td></tr></table></figure>

<h1 id="strip从目标文件中剥离符号-调试信息"><a href="#strip从目标文件中剥离符号-调试信息" class="headerlink" title="strip从目标文件中剥离符号(调试信息)"></a>strip从目标文件中剥离符号(调试信息)</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">file a.out<span class="comment">#查看文件类型：是否被剥离</span></span><br><span class="line"><span class="built_in">du</span> -h a.out<span class="comment">#查看二进制文件大小</span></span><br><span class="line">strip a.out<span class="comment">#发布版本剥离调试信息，瘦身</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="addr2line根据地址映射到文件名和行号"><a href="#addr2line根据地址映射到文件名和行号" class="headerlink" title="addr2line根据地址映射到文件名和行号"></a>addr2line根据地址映射到文件名和行号</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objdump -d a.out | grep -A 2 -E <span class="string">&#x27;main&gt;:|function1&gt;:|function2&gt;:&#x27;</span></span><br><span class="line"><span class="comment">#找出汇编代码中的函数标签行；以及标签行对应地址</span></span><br><span class="line">addr2line -e a.out 40051d</span><br><span class="line"><span class="comment">#标签行地址对应的C源码和行号</span></span><br></pre></td></tr></table></figure>

<h1 id="nm列出目标文件的符号"><a href="#nm列出目标文件的符号" class="headerlink" title="nm列出目标文件的符号"></a>nm列出目标文件的符号</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nm a.out | grep -Ei <span class="string">&#x27;function|main|globalvar&#x27;</span><span class="comment">#获取有关函数和变量的信息</span></span><br><span class="line">&gt;&gt;&gt;000000000040051d T function1</span><br><span class="line">&gt;&gt;&gt;0000000000400532 T function2</span><br><span class="line">&gt;&gt;&gt;000000000060102c D globalvar</span><br><span class="line">&gt;&gt;&gt;U __libc_start_main@@GLIBC_2.2.5</span><br><span class="line">&gt;&gt;&gt;0000000000400547 T main</span><br><span class="line"><span class="comment">#函数被标记为 T，它表示 text 节中的符号，而变量标记为 D，表示初始化的 data 节中的符号</span></span><br><span class="line"><span class="comment">#在未剥离符号的没有源代码的二进制文件上运行此命令可窥视内部并了解使用了哪些函数和变量</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/GUI%E7%BC%96%E7%A8%8B/GUI%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="GUI编程"><a href="#GUI编程" class="headerlink" title="GUI编程"></a>GUI编程</h1><p><a href="https://www.zhihu.com/question/21219705" title=" 如何学习 GUI 编程？ - 知乎 学了很多理论，也做了不少命令行的小程序，可是却对 GUI 一无所知，也不知道背后的 function 如何和用户… https://www.zhihu.com/question/21219705"> 如何学习 GUI 编程？ - 知乎 学了很多理论，也做了不少命令行的小程序，可是却对 GUI 一无所知，也不知道背后的 function 如何和用户… https://www.zhihu.com/question/21219705</a></p>
<p>目标：界面要好看，操作要容易</p>
<p><a href="%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1-%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1-%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1.md" title="交互设计/界面设计">交互设计&#x2F;界面设计</a></p>
<p><a href="%E7%8E%AF%E5%BD%A2%E6%8E%A7%E4%BB%B6%E6%89%8B%E5%8A%BF%E6%BB%91%E5%8A%A8%E4%BA%A4%E4%BA%92/%E7%8E%AF%E5%BD%A2%E6%8E%A7%E4%BB%B6%E6%89%8B%E5%8A%BF%E6%BB%91%E5%8A%A8%E4%BA%A4%E4%BA%92.md" title="环形控件手势滑动交互">环形控件手势滑动交互</a></p>
<p><a href="%E5%9B%BD%E9%99%85%E5%8C%96/%E5%9B%BD%E9%99%85%E5%8C%96.md" title="国际化">国际化</a></p>
<p><a href="%E6%8E%A7%E4%BB%B6%E5%8A%A8%E7%94%BB/%E6%8E%A7%E4%BB%B6%E5%8A%A8%E7%94%BB.md" title="控件动画">控件动画</a></p>
<p><a href="%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94/%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94.md" title="事件响应">事件响应</a></p>
<p><a href="%E6%96%B0%E9%A1%B5%E9%9D%A2/%E6%96%B0%E9%A1%B5%E9%9D%A2.md" title="新页面">新页面</a></p>
]]></content>
  </entry>
  <entry>
    <title>gcc</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/gcc/gcc/</url>
    <content><![CDATA[<p>C&#x2F;C++文件要经过预处理(preprocessing)、编译(compilation)、汇编(assembly)和链接(linking)等 4 步才能变成可执行文件</p>
<p><img src="/image/image_kgFDHGc6-r.png"></p>
<p>$源文件hello.c\xrightarrow{预处理gcc \ -E}预处理文件.i\xrightarrow{编译gcc \ -S}汇编文件.s\xrightarrow{汇编gcc \ -c}目标文件.o(动态库则是.so)\xrightarrow{链接gcc}可执行文件hello.out&#x2F;exe$<br>1）<strong>预处理</strong>（宏展开；替换条件编译；包含头文件内容;删除注释空白）<br>2）<strong>编译</strong>（转换成汇编文件;检查语法规范；返回错误警告）<br>3）<strong>汇编</strong>（转换成机器指令）<br>4）<strong>链接</strong>(将OBJ 文件和系统库 OBJ 文件、库文件链接，生成可执行文件;数据段合并，地址回填)<br>1.静态链接：构建程序时，编译器会将静态库(目标文件文件集合)函数和数据结构的代码直接复制到最终的可执行文件中<br>2.动态链接：运行时加载和使用需要的动态库函数和数据结构<br>5）反汇编：将机器代码转换为汇编代码（调试，破解用到）</p>
<h1 id="gcc参数"><a href="#gcc参数" class="headerlink" title="gcc参数"></a>gcc参数</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -v                //版本</span><br><span class="line">-E -S -c              //预处理，编译，汇编</span><br><span class="line"></span><br><span class="line">gcc hello.c -o hello -lmath -L ./lib -I ./inc -g -Wall -O0  </span><br><span class="line">-o:指定生成文件名</span><br><span class="line">-I:指定头文件目录</span><br><span class="line">-g:支持gdb调试</span><br><span class="line">-Wall：显示所有警告</span><br><span class="line">-On:n为0~3编译优化，默认2，嵌入式场景0</span><br><span class="line">-D ERROR:注册debug宏</span><br><span class="line">-L：给连接器指定库路径</span><br><span class="line">-l:指定math为库名（去掉前后缀）</span><br></pre></td></tr></table></figure>

<h1 id="debug宏"><a href="#debug宏" class="headerlink" title="debug宏"></a>debug宏</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#define ERROR(...) /    </span></span><br><span class="line"><span class="keyword">do</span>&#123; /    </span><br><span class="line">    fprintf(stderr, <span class="string">&quot;[ERROR  ]%s %s(Line %d): &quot;</span>,__FILE__,__FUNCTION__,__LINE__); /    </span><br><span class="line">    fprintf(stderr, __VA_ARGS__); /    </span><br><span class="line">&#125;<span class="keyword">while</span>(0)    </span><br><span class="line"></span><br><span class="line"><span class="comment">#define WARNING(...) /    </span></span><br><span class="line"><span class="keyword">do</span>&#123; /    </span><br><span class="line">    fprintf(stdout, <span class="string">&quot;[WARNING]%s %s(Line %d): &quot;</span>,__FILE__,__FUNCTION__,__LINE__); /    </span><br><span class="line">    fprintf(stdout, __VA_ARGS__); /    </span><br><span class="line">&#125;<span class="keyword">while</span>(0)    </span><br><span class="line"></span><br><span class="line"><span class="comment">#define INFO(...) /    </span></span><br><span class="line"><span class="keyword">do</span>&#123; /    </span><br><span class="line">    fprintf(stdout, <span class="string">&quot;[INFO  ]%s %s(Line %d): &quot;</span>,__FILE__,__FUNCTION__,__LINE__); /    </span><br><span class="line">    fprintf(stdout, __VA_ARGS__); /    </span><br><span class="line">&#125;<span class="keyword">while</span>(0)    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#define SHOW_TIME(...) /    </span></span><br><span class="line"><span class="keyword">do</span>&#123;/    </span><br><span class="line">    extern unsigned long long gLatestTime;/    </span><br><span class="line">    timeval tp;/    </span><br><span class="line">    gettimeofday(&amp;tp, NULL);/    </span><br><span class="line">    unsigned long long now = tp.tv_sec*1000000+tp.tv_usec; /    </span><br><span class="line">    <span class="keyword">if</span>(gLatestTime != 0) /    </span><br><span class="line">    &#123; /    </span><br><span class="line">        fprintf(stdout, <span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;Used Time: %s[%d], %s: %ld.%ld, %llu ms &quot;</span>, __FILE__, __LINE__, __func__, tp.tv_sec, tp.tv_usec, (now-gLatestTime)/1000);/    </span><br><span class="line">        fprintf(stdout, __VA_ARGS__); /    </span><br><span class="line">        fprintf(stdout, <span class="string">&quot;/n&quot;</span>); /    </span><br><span class="line">    &#125; /    </span><br><span class="line">    gLatestTime = now;/    </span><br><span class="line">&#125;<span class="keyword">while</span>(0)    </span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#ifdef DEBUG    </span></span><br><span class="line"><span class="comment">#define DBG(...) /    </span></span><br><span class="line"><span class="keyword">do</span>&#123; /    </span><br><span class="line">    fprintf(stdout, <span class="string">&quot;[DEBUG  ]%s %s(Line %d): &quot;</span>,__FILE__,__FUNCTION__,__LINE__); /    </span><br><span class="line">    fprintf(stdout, __VA_ARGS__); /    </span><br><span class="line">&#125;<span class="keyword">while</span>(0)    </span><br><span class="line"><span class="comment">#else    </span></span><br><span class="line"><span class="comment">#define DBG(...)    </span></span><br><span class="line"><span class="comment">#endif   </span></span><br><span class="line"></span><br><span class="line">//测试例子，调试宏用-D或源码<span class="comment">#define注册</span></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i, <span class="built_in">sum</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = 1, <span class="built_in">sum</span> = 0; i &lt;= 5; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sum</span> += i;</span><br><span class="line">        DBG(<span class="string">&quot;sum += %d is %d\n&quot;</span>, i, <span class="built_in">sum</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;total sum is %d\n&quot;</span>, <span class="built_in">sum</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="其他编译有关指令"><a href="#其他编译有关指令" class="headerlink" title="其他编译有关指令"></a>其他编译有关指令</h1><p>gcc -E main.c &#x2F;&#x2F; 查看预处理结果，比如头文件是哪个<br>gcc -E -dM main.c &gt; 1.txt &#x2F;&#x2F; 把所有的宏展开，存在 1.txt 里<br>gcc -Wp,-MD,abc.dep -c -o main.o main.c &#x2F;&#x2F; 生成依赖文件 abc.dep，后面 Makefile 会用<br>echo ‘main(){}’| gcc -E -v - &#x2F;&#x2F; 列出头文件目录、库目录(LIBRARY_PATH)</p>
<h1 id="编译多文件流程"><a href="#编译多文件流程" class="headerlink" title="编译多文件流程"></a>编译多文件流程</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//统一编译，链接</span><br><span class="line">gcc main.c sub.c -o <span class="built_in">test</span></span><br><span class="line">//分开编译，统一链接</span><br><span class="line">gcc -c main.c -o main.o</span><br><span class="line">gcc -c sub.c -o sub.o</span><br><span class="line">gcc main.o sub.o -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h1 id="制作动态-静态库"><a href="#制作动态-静态库" class="headerlink" title="制作动态&#x2F;静态库"></a>制作动态&#x2F;静态库</h1><p>将源码打包成库隐藏实现（常存放于&#x2F;lib或&#x2F;usr&#x2F;lib）<br>而提供api文档；由.h暴露公共接口（常存放在&#x2F;usr&#x2F;include）</p>
<table>
<thead>
<tr>
<th></th>
<th>libxx.a</th>
<th>libxx.so</th>
</tr>
</thead>
<tbody><tr>
<td>.out链接方式</td>
<td>编译时把库.o的数据复制到可执行文件中</td>
<td>编译时在可执行文件中插入该库符号表引用；运行时才链接加载</td>
</tr>
<tr>
<td>.out文件大小</td>
<td>可想而知较大</td>
<td></td>
</tr>
<tr>
<td>运行时内存占用</td>
<td>静态库在可执行文件中的代码和数据被完整地加载到内存中</td>
<td>动态库数据在运行时被加载到内存中，因此共享库可以节省内存占用</td>
</tr>
<tr>
<td>更新和维护</td>
<td>如果库的更新需要重新编译所有引用了该库的可执行文件</td>
<td>只需更新库文件</td>
</tr>
<tr>
<td>.out可移植性</td>
<td>在编译时已经包含了所需的依赖，因此可执行文件可以在没有库文件的系统上运行</td>
<td>需要依赖系统中存在相应的库文件才能正常运行</td>
</tr>
</tbody></table>
<h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1)将源文件汇编成目标文件.c→.o</span><br><span class="line">gcc -c operator.c -o operator.o</span><br><span class="line">gcc -c add.c -o add.o</span><br><span class="line">gcc -c sub.c -o sub.o</span><br><span class="line">gcc -c mul.c -o mul.o</span><br><span class="line">gcc -c div.c -o div.o</span><br><span class="line"></span><br><span class="line">2)ar工具制作静态库；将目标文件（add.o、sub.o、mul.o、div.o）链接成静态库文件</span><br><span class="line">ar rcs lib math .a add.o sub.o mul.o div.o</span><br><span class="line"><span class="built_in">mv</span> libmath.a ./lib</span><br><span class="line"></span><br><span class="line">3)编译时将静态库链接为可执行文件（静态链接将库的代码拷贝嵌入到到可执行文件中）</span><br><span class="line">gcc operator.o libmath.a -o operator.out -lmath -L ./lib -I ./inc -g -Wall -O0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1)将源文件汇编成目标文件（插入该库符号表引用）.c→.o</span><br><span class="line">gcc -fPIC -c operator.c -o operator.o</span><br><span class="line">gcc -fPIC -c add.c -o add.o</span><br><span class="line">gcc -fPIC -c sub.c -o sub.o</span><br><span class="line">gcc -fPIC -c mul.c -o mul.o</span><br><span class="line">gcc -fPIC -c div.c -o div.o</span><br><span class="line"></span><br><span class="line">2)选项-shared表示生成一个共享库，</span><br><span class="line">gcc -shared -Wl -o libmath.so add.o sub.o mul.o div.o</span><br><span class="line"><span class="built_in">mv</span> libmath.so ./lib</span><br><span class="line"></span><br><span class="line">3)链接动态库中的libsub.so引用 </span><br><span class="line">gcc operator.o libmath.so -o operator.out -lmath -L ./lib -I ./inc -g -Wall -O0</span><br><span class="line"></span><br><span class="line">//给动态链接器指定库路径</span><br><span class="line">4.1)测试：环境变量</span><br><span class="line">vi ~/.bashrc</span><br><span class="line">写入：<span class="built_in">export</span> LD_LIBRARY_PATH=~/operator/lib              //设置动态库路径环境变量</span><br><span class="line"><span class="built_in">source</span> .bashrc            //shell启动配置生效</span><br><span class="line">./operator</span><br><span class="line"></span><br><span class="line">4.2)测试：把库放到系统级动态库目录</span><br><span class="line">ldd hello             //查看标准C动态库所在目录</span><br><span class="line">sudo <span class="built_in">cp</span> libmath.so 标准c路径</span><br><span class="line">./operator</span><br><span class="line"></span><br><span class="line">4.3)测试：ldconfig程序装载器工具会查找并装载应用程序所依赖的所有共享库，第一次查找/etc/ld.so.conf； 再次就从/etc/ld.so.cache</span><br><span class="line">sudo vi /etc/ld.so.conf</span><br><span class="line">写入共享库路径:~/operator/lib  </span><br><span class="line">sudo ldconfig -v              //更新查找共享库的路径</span><br><span class="line">ldd a.out                   //测试程序可否找到共享库</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/cmake/cmake/</url>
    <content><![CDATA[<h1 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h1>]]></content>
  </entry>
  <entry>
    <title>gdb</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/gdb/gdb/</url>
    <content><![CDATA[<p>1）操控程序的运行<br>2）程序异常停止时，检查发生了什么<br>3)随时查看程序内部状态:各变量的值、传给函数的参数、当前执行的语句位置等<br>debug思想：while(不符合期待){<br>&#x20;        猜想错误原因和bug发生地段-&gt;验证假设（printf；gdb打印出状态量；测试语句执行顺序）<br>}</p>
<h1 id="一般断点调试-大致定位"><a href="#一般断点调试-大致定位" class="headerlink" title="一般断点调试(大致定位)"></a>一般断点调试(大致定位)</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb hello.out</span><br><span class="line"></span><br><span class="line">b/break func1                                      //设置func1为断点</span><br><span class="line">b 12                                               //设置12行为断点</span><br><span class="line">b 12 <span class="keyword">if</span> i=7                                           //当递归/for循环索引=7时stop</span><br><span class="line">info b                                            //查看断点</span><br><span class="line">d/delete                                        //删除断点 d breakpoints NUM</span><br><span class="line"></span><br><span class="line">r/run                                          //全速运行程序</span><br><span class="line">c/continue                                     //继续全速运行剩下的代码</span><br><span class="line"></span><br><span class="line">p/print                                        //查看状态</span><br><span class="line">ptype 变量                                       //查看类型</span><br><span class="line"></span><br><span class="line">q/quit 退出gdb                           </span><br></pre></td></tr></table></figure>

<h1 id="单步调试"><a href="#单步调试" class="headerlink" title="单步调试"></a>单步调试</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">n/next                                          //逐条执行，不跳入函数</span><br><span class="line">s/step                                          //逐语句执行，跳入函数</span><br><span class="line"></span><br><span class="line">watch *ptr                                      //设置观察断点，变量的ptr由<span class="built_in">print</span>获得</span><br><span class="line">info watchpoints       </span><br><span class="line"></span><br><span class="line">display 变量                                          //设置跟踪变量</span><br><span class="line">undisplay 变量编号                                      //取消跟踪变量</span><br><span class="line"></span><br><span class="line">finish                                        //结束当前函数，返回到函数调用点 </span><br><span class="line">bt/backtrace                                 //查看函数的调用的栈帧和层级关系</span><br><span class="line">f/frame 栈帧号                                     //切换函数的栈帧，与bt组合拳查看进程空间栈区中栈帧里存储的变量 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>子进程调试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> follow-fork-mode child 命令可以指示调试器在父进程创建子进程后，自动切换到子进程并继续跟踪子进程的执行。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>后台进程调试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hello.out &amp;              //后台运行hello，屏幕回显一个pid</span><br><span class="line">gdb -p pid</span><br></pre></td></tr></table></figure>

<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">| <span class="built_in">help</span> | h | 按模块列出命令类</span><br><span class="line">| list | l | 查看代码，可跟行号和函数名 </span><br><span class="line">| x | | 查看内存 x /20xw 显示20个单元，16进制，4字节每单元 |</span><br><span class="line">shell cmd</span><br><span class="line"><span class="built_in">set</span> logging on</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">| <span class="built_in">enable</span> breakpoints | | 启用断点 |</span><br><span class="line">| <span class="built_in">disable</span> breakpoints | | 禁用断点 </span><br><span class="line">| i watch | | 显示观察点 </span><br><span class="line"> </span><br><span class="line"> | start | | 单步执行，运行程序，停在第一行执行语句 </span><br><span class="line">  | run argv[1] argv[2] | | 调试时命令行传参 </span><br><span class="line"> checkpoint</span><br><span class="line"> </span><br><span class="line">//Core文件是在程序运行过程中发生严重错误（如段错误）或者异常终止时生成的一种特殊文件。它包含了程序在崩溃瞬间的内存映像</span><br><span class="line">gdb hello,out core</span><br><span class="line"><span class="built_in">ulimit</span> -a</span><br><span class="line">-a 　显示目前资源限制的设定。</span><br><span class="line">-c &lt;core文件上限&gt; 　设定core文件的最大值，单位为区块。</span><br><span class="line">-d &lt;数据节区大小&gt; 　程序数据节区的最大值，单位为KB。</span><br><span class="line">-f &lt;文件大小&gt; 　shell所能建立的最大文件，单位为区块。</span><br><span class="line">-H 　设定资源的硬性限制，也就是管理员所设下的限制。</span><br><span class="line">-m &lt;内存大小&gt; 　指定可使用内存的上限，单位为KB。</span><br><span class="line">-n &lt;文件数目&gt; 　指定同一时间最多可开启的文件数。</span><br><span class="line">-p &lt;缓冲区大小&gt; 　指定管道缓冲区的大小，单位512字节。</span><br><span class="line">-s &lt;堆叠大小&gt; 　指定堆叠的上限，单位为KB。</span><br><span class="line">-S 　设定资源的弹性限制。</span><br><span class="line">-t &lt;CPU时间&gt; 　指定CPU使用时间的上限，单位为秒。</span><br><span class="line">-u &lt;程序数目&gt; 　用户最多可开启的程序数目。</span><br><span class="line">-v &lt;虚拟内存大小&gt; 　指定可使用的虚拟内存上限，单位为KB。</span><br><span class="line"></span><br><span class="line"><span class="built_in">ulimit</span> -c unlimited                     //生成core文件 </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>git/repo/Sourcetree</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/git-repo-Sourcetree/git-repo-Sourcetree/</url>
    <content><![CDATA[<p><img src="/image/image_8TvrWA1R8Y.png"></p>
<p>gogocode 项目地址：<a href="https://github.com/thx/gogocode%EF%BC%88%E6%B1%82%E4%B8%80%E4%B8%AAstar%EF%BC%81%EF%BC%89" title="https://github.com/thx/gogocode（求一个star！）">https://github.com/thx/gogocode（求一个star！）</a> &#x20;</p>
<p>找开源项目的一些途径 &#x20;</p>
<p>• <a href="https://github.com/trending/" title="https://github.com/trending/">https://github.com/trending/</a> &#x20;</p>
<p>• <a href="https://github.com/521xueweihan/HelloGitHub" title="https://github.com/521xueweihan/HelloGitHub">https://github.com/521xueweihan/HelloGitHub</a> &#x20;</p>
<p>• <a href="https://github.com/ruanyf/weekly" title="https://github.com/ruanyf/weekly">https://github.com/ruanyf/weekly</a> &#x20;</p>
<p>• <a href="https://www.zhihu.com/column/mm-fe" title="https://www.zhihu.com/column/mm-fe">https://www.zhihu.com/column/mm-fe</a> &#x20;</p>
<p>特殊的查找资源小技巧-常用前缀后缀 &#x20;</p>
<p>• 找百科大全 awesome xxx &#x20;</p>
<p>• 找例子 xxx sample &#x20;</p>
<p>• 找空项目架子 xxx starter &#x2F; xxx boilerplate &#x20;</p>
<p>• 找教程 xxx tutorial</p>
<p>搜寻项目<a href="https://blog.csdn.net/as480133937/article/details/105611577" title="https://blog.csdn.net/as480133937/article/details/105611577">https://blog.csdn.net/as480133937/article/details/105611577</a></p>
<p>git教程</p>
<p><a href="https://www.bilibili.com/video/BV1HM411377j?p=7&spm_id_from=pageDriver&vd_source=5e06b5dd11f67d0863cd77450011b67a" title="  https://www.bilibili.com/video/BV1HM411377j?p=7&amp;spm_id_from=pageDriver&amp;vd_source=5e06b5dd11f67d0863cd77450011b67a">  https://www.bilibili.com/video/BV1HM411377j?p=7&amp;spm_id_from&#x3D;pageDriver&amp;vd_source&#x3D;5e06b5dd11f67d0863cd77450011b67a</a></p>
<p><a href="https://www.bilibili.com/video/BV18h411B7tc/?spm_id_from=333.337.search-card.all.click&vd_source=5e06b5dd11f67d0863cd77450011b67a" title="程序员不想第一天被辞退，必会SourceTree项目版本控制软件_哔哩哔哩_bilibili 哈喽！大家好。欢迎一起学习前端。老陈这里有很多老陈自己的【前端教程和资料】。b站各种教程视频链接可以查看置顶评论哦！学习的资料、代码可以加【置顶评论的群】。我们一起为未来加油！, 视频播放量 15382、弹幕量 30、点赞数 179、投硬币枚数 67、收藏人数 416、转发人数 70, 视频作者 老陈打码, 作者简介 我是老陈，一个有趣有料有内涵的IT老男人。玩过前端，弄过Java，搞过Pytho https://www.bilibili.com/video/BV18h411B7tc/?spm_id_from=333.337.search-card.all.click&amp;vd_source=5e06b5dd11f67d0863cd77450011b67a">程序员不想第一天被辞退，必会SourceTree项目版本控制软件_哔哩哔哩_bilibili 哈喽！大家好。欢迎一起学习前端。老陈这里有很多老陈自己的【前端教程和资料】。b站各种教程视频链接可以查看置顶评论哦！学习的资料、代码可以加【置顶评论的群】。我们一起为未来加油！, 视频播放量 15382、弹幕量 30、点赞数 179、投硬币枚数 67、收藏人数 416、转发人数 70, 视频作者 老陈打码, 作者简介 我是老陈，一个有趣有料有内涵的IT老男人。玩过前端，弄过Java，搞过Pytho https://www.bilibili.com/video/BV18h411B7tc/?spm_id_from&#x3D;333.337.search-card.all.click&amp;vd_source&#x3D;5e06b5dd11f67d0863cd77450011b67a</a></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>git config –global user.name “xj”<br>git config –global user.email “<a href="mailto:&#120;&#106;&#46;&#x40;&#x6f;&#117;&#116;&#x6c;&#111;&#111;&#x6b;&#x2e;&#x63;&#111;&#x6d;">&#120;&#106;&#46;&#x40;&#x6f;&#117;&#116;&#x6c;&#111;&#111;&#x6b;&#x2e;&#x63;&#111;&#x6d;</a>“&#x20;<br>git config –global credential.helper store</p>
<p>git config –global –list</p>
<p>参数：(Local)<br>--global 全局配置，对所有仓库生效<br>--system 系统配置，对所有用户生效</p>
<h2 id="创建Repository"><a href="#创建Repository" class="headerlink" title="创建Repository"></a>创建Repository</h2><p>1)<br>&gt;&gt;mkdir learn-git<br>&gt;&gt;cd learn-git<br>&gt;&gt;git init指定当前目录为本地仓库<br>2)<br>&gt;&gt;git init my_repo创建<br>3)<br>&gt;&gt;git clone <a href="https://github.com/ekmett/ad.git" title="https://github.com/ekmett/ad.git">https://github.com/ekmett/ad.git</a></p>
<h2 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h2><p>提交到版本库时忽略某些文件<br>一般原则：</p>
<p><img src="/image/image_28gntceIgv.png"></p>
<p>eg:<br>&gt;&gt;echo *.o &gt; .gitignore</p>
<p><img src="/image/image_LhJ1d48bFA.png"></p>
<p><img src="/image/image_c8jHXx1Q0-.png"></p>
<p><img src="/image/image_B6nayNrmI6.png"></p>
<p>gitignore仓库提供常用语言的的.gitignore模板</p>
<h2 id="创建远程仓库，并在本地与其关联"><a href="#创建远程仓库，并在本地与其关联" class="headerlink" title="创建远程仓库，并在本地与其关联"></a>创建远程仓库，并在本地与其关联</h2><p>echo “remote-repo” &gt;&gt; README.md<br>git init<br>git add README.md<br>git commit -m “first commit”<br>____若已存在仓库则执行以下，否则上下都执行<br>git branch -M main                                                     将当前分支重命名为 <code>main</code><br>git remote add origin <a href="mailto:&#x67;&#105;&#x74;&#x40;&#103;&#x69;&#x74;&#104;&#x75;&#x62;&#46;&#x63;&#x6f;&#x6d;">&#x67;&#105;&#x74;&#x40;&#103;&#x69;&#x74;&#104;&#x75;&#x62;&#46;&#x63;&#x6f;&#x6d;</a>:xj&#x2F;repo.git     关联远程仓库git@github.com:xj&#x2F;repo.git；并声名为origin&#x20;<br>git push -u origin main:main                                      将本地 “main” 分支推送到远程仓库origin 的main分支</p>
<p>git remote -v            查看当前关联的仓库<br>git remote set-url 仓库名  <strong>gi</strong>t**_path**               重置仓库地址</p>
<h2 id="ssh配置"><a href="#ssh配置" class="headerlink" title="ssh配置"></a>ssh配置</h2><p>基于ssh协议从远程拉取创建本地仓库；或push到远程仓库时：配置ssh密钥<br>ssh-keygen -t rsa -b 4096 -f .&#x2F;.ssh&#x2F;id.rsa&#x20;<br>ssh-keygen -t ed25519 -C “&lt;标签：一般写 github email&gt;”<br>指定在.&#x2F;.ssh&#x2F;生成rsa（或ed25519）类型的4096位密钥id.rsa ，按回车提示命名密钥文件；默认密钥文件id_rsa;同时还会生成公钥文件id_rsa.pub</p>
<p>然后：从.ssh目录下查找并复制公钥到远程仓库设置；<br>最后：配置.ssh&#x2F;config 文件<br>eg:<br>&gt;&gt;vi config<br>#github&#x20;<br>Host github.com&#x20;<br>HostName <a href="http://github.com/" title="github.com">github.com</a>&#x20;<br>PreferredAuthentications publickey&#x20;<br>IdentityFile ~&#x2F;.ssh&#x2F;id.rsa</p>
<p>意思是连接主机 github.com 时首选验证方式为公钥验证，本地私钥路径为~&#x2F;.ssh&#x2F;id.rsa</p>
<p>ssh -T git@主机（上面host）          &#x2F;&#x2F;测试</p>
<h2 id="gitflow-githubflow"><a href="#gitflow-githubflow" class="headerlink" title="gitflow&#x2F;githubflow"></a>gitflow&#x2F;githubflow</h2><p><img src="/image/image_ez8jrm0Wm3.png"></p>
<p>每次修改完bug把修改记录添加到暂存区，最后再一次性提交到本地仓库，记录为一次版本信息<br>可以理解为3个目录（实际上不是）：本地仓库是发布目录</p>
<p><img src="/image/image_4coqZ4YmWj.png"></p>
<p>git status 查看文件状态<br>git log查看提交版本记录<br>git log —oneline</p>
<p>git diff    查看暂存区和工作区差异<br>git diff HEAD   查看工作区和当前版本差异<br>git diff – cache   查看暂存区和当前版本差异<br>git diff 59cf93 59cf712 比较两个版本差异<br>或git diff HEAD~1 HEAD file3.txt比较两个版本file3的差异</p>
<p>git ls-files查看暂存区</p>
<h3 id="gitflow"><a href="#gitflow" class="headerlink" title="gitflow"></a>gitflow</h3><p>main分支：只接受hotfix&#x2F;release的合并，不允许直接push修改；每次合并生成x.x.x版本号（主版本，次版本，修订版本）<br>hotfix:从main分离，修复完合并回main<br>dev:从main&#x2F;hotfix分离,开发完成合并到release<br>release:从dev分离，测试完成合并到main<br>feature-xx:从dev分离，开发完合并到dev</p>
<h3 id="githubflow"><a href="#githubflow" class="headerlink" title="githubflow"></a>githubflow</h3><p>main:直接部署生产环境的分支；禁止直接提交<br>feat&#x2F;dev&#x2F;hotfix&#x2F;release:团队成员从main拉取，工作完成后提交pr合并请求</p>
<h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><p><strong>git add</strong> fileName<br>git add .</p>
<p><strong>git commit filename -m “此为更新说明”</strong></p>
<p><strong>git commit</strong> -am “说明”          暂存+提交</p>
<p>git push                            ssh关联后使用这个命令即可；<br>git push remote_repo xvjin_dev</p>
<p>git checkout –   撤回到最近一次提交状态</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>git rm file.txt                       用ls和git ls-files 可以发现在工作区和暂存区中同时删除了<br>git commit -m “删除”</p>
<p>git clean -f                             强制清空未跟踪文件</p>
<p>git rm -r dir递归删除某目录下所有东西<br>git rm –cached file.txt从缓存区删除</p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p><strong>git pull</strong> origin main                                                        拉取并合并origin 仓库的main分支<br>git fetch origin main                                                       拉取</p>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>git branch xvjin-dev         创建分支<br>git switch xvjin-dev          切换分支<br>git checkout xvjin-dev          切换分支（旧）</p>
<p>git merge xvjin-dev          把xvjin-dev 合并到当前所处分支,且当前分支多出一条提交记录；合并后xvjin-dev 还是存在的，删除需手动<br>(dev)&gt;&gt;git rebase main    将当前dev分支嫁接（变基）到目标分支main上；这种合并形成线性历史，比较干净</p>
<p>git branch -d xvjin-dev     合并后删除分支<br>git branch -D xvjin-dev     强制删除未合并分支</p>
<p>git branch -a                             查看所有分支<br>git remote show origin           查看origin仓库更新记录<br>git log                                    查看本地仓库更新记录</p>
<h2 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h2><p>1）git diff          查看差异？<br>2）手动修改合并失败的文件<br>3）提交修改的文件就自动完成了冲突文件的合并</p>
<p>git merge –abort   中止合并</p>
<h2 id="倒回某个版本"><a href="#倒回某个版本" class="headerlink" title="倒回某个版本"></a>倒回某个版本</h2><p>git reset –soft HEAD^                                       回退到仓库某log版本，保存工作区，暂存区内容<br>git reset –hard HEAD~1                                           回退到仓库某log版本，不保存工作区，暂存区内容<br>git reset –mixed 59cf9334cf957                               回退到仓库某log版本，保存工作区，不保存暂存区内容</p>
<p>git log –oneline –grahp –decorate –all                图形化查看版本号哈希，用于上述回退</p>
<p>git reflog查看历史操作</p>
<p>git checkout – filename 丢弃工作区的修改,用缓存区数据覆盖当前工作区</p>
<h2 id="repo脚本"><a href="#repo脚本" class="headerlink" title="repo脚本"></a>repo脚本</h2><p>多git仓库管理脚本;拿来拉去bsp</p>
<p>下载repo:</p>
<blockquote>
<p>git clone <a href="https://gerrit.googlesource.com/git-repo" title="https://gerrit.googlesource.com/git-repo">https://gerrit.googlesource.com/git-repo</a>  (谷歌官方源)<br>git clone <a href="https://mirrors.tuna.tsinghua.edu.cn/git/git-repo" title="https://mirrors.tuna.tsinghua.edu.cn/git/git-repo">https://mirrors.tuna.tsinghua.edu.cn/git/git-repo</a> (国内清华源)<br>git clone <a href="https://gerrit-googlesource.lug.ustc.edu.cn/git-repo" title="https://gerrit-googlesource.lug.ustc.edu.cn/git-repo">https://gerrit-googlesource.lug.ustc.edu.cn/git-repo</a> (国内中科大源)</p>
</blockquote>
<p><code>.repo/</code> 目录下包含 <code>manifest.xml</code>，这是一个指向 <code>.repo/manifests/</code> 目录中所选清单的符号链接。</p>
<p><strong>repo init</strong>:</p>
<p>若未把目录添加进环境变量,则如此访问命令</p>
<p>..&#x2F;repo&#x2F;<strong>repo init</strong> -u <a href="https://gitee.com/weidongshan/manifests.git">https://gitee.com/weidongshan/manifests.git</a> -b linux-sdk -m imx6ull&#x2F;100ask_imx6ull_linux4.9.88_release.xml  –no-<br>repo-verify</p>
<ul>
<li><code>-u</code>：指定要从中检索清单代码库的网址</li>
<li><code>-b</code>：指定修订版本，即特定的清单分支</li>
<li><code>-m</code>：在代码库中选择清单文件。如果未选择任何清单名称，则选择 default.xml</li>
</ul>
<p><strong>repo sync</strong></p>
<p>..&#x2F;repo&#x2F;<strong>repo sync</strong> -j4</p>
<ul>
<li>初次 <code>repo sync</code> 相当于 <code>git clone</code></li>
<li>如果目标项目已同步过，则 <code>repo sync</code> 相当于更新</li>
</ul>
<p><strong>$ repo start</strong> a203m-dev –all</p>
<p>执行 <code>repo start a203m-dev --all</code> 命令相当于在所有的Git仓库上创建一个名为”a203m-dev”的新分支。这意味着在每个Git仓库中都会创建一个名为”a203m-dev”的分支，这样你就可以在所有项目中同时使用这个分支进行开发工作。</p>
<p>通常情况下，使用该命令可以简化在多个Git仓库中创建同名分支的操作，使得多个项目可以同时切换到同一个开发分支，方便进行跨项目的协同开发。</p>
<p>croot</p>
<p><a href="https://www.jianshu.com/p/00a4ae76186f" title=" git提交代码——先暂存-再更新-然后上传代码 1、git基本操作 在项目中协同开发的时候，会遇到你更新代码之后开发阶段中，同事提交了新的代码，但是你本地代码还未更新同事最新提交的代码，如果直接提交，会产生冲突，这个时候需... https://www.jianshu.com/p/00a4ae76186f"> git提交代码——先暂存-再更新-然后上传代码 1、git基本操作 在项目中协同开发的时候，会遇到你更新代码之后开发阶段中，同事提交了新的代码，但是你本地代码还未更新同事最新提交的代码，如果直接提交，会产生冲突，这个时候需… https://www.jianshu.com/p/00a4ae76186f</a></p>
<h1 id="License"><a href="#License" class="headerlink" title="License"></a>License</h1><p><a href="https://cloud.tencent.com/developer/article/1921909" title=" github常见开源协议概括-腾讯云开发者社区-腾讯云 如果你是信仰开源大法的普通开发者，使用 MIT License 协议即可，它会保留你的版权信息，又允许他人进行修改。 https://cloud.tencent.com/developer/article/1921909"> github常见开源协议概括-腾讯云开发者社区-腾讯云 如果你是信仰开源大法的普通开发者，使用 MIT License 协议即可，它会保留你的版权信息，又允许他人进行修改。 https://cloud.tencent.com/developer/article/1921909</a></p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/lvgl/lvgl/</url>
    <content><![CDATA[<h1 id="lvgl"><a href="#lvgl" class="headerlink" title="lvgl"></a>lvgl</h1><p>专注于嵌入式图形应用开发的功能库</p>
<p>面向对象程序</p>
<p>业务流程  分解为  功能  按不同步骤执行;</p>
<p>lvgl封装了底层驱动程序,并提供了功能函数的接口</p>
]]></content>
  </entry>
  <entry>
    <title>makefile</title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/makefile/makefile/</url>
    <content><![CDATA[<p>C&#x2F;C++等项目中，make工具可进行自动化构建（依据makefile脚本定义的编译规则和依赖关系）</p>
<h1 id="编译规则"><a href="#编译规则" class="headerlink" title="编译规则"></a>编译规则</h1><p>command执行的规则：<br>1）依赖文件晚于目标文件（依赖更新）<br>2）目标文件不存在<br>3）依赖树自底向上执行</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">生成目标:依赖（生成目标所需文件）</span></span><br><span class="line">（tab）依赖文件生成目标的命令</span><br><span class="line"></span><br><span class="line">target ... : prerequisites ...</span><br><span class="line">    command</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">#prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="make-cmd"><a href="#make-cmd" class="headerlink" title="make_cmd"></a>make_cmd</h1><p>执行 make 时，查找“Makefile”，并根据它的指示执行操作，生成第一个目标。<br>“-f”选项指定文件，不再使用名为“Makefile”的文件；<br>“-C”选项指定目录，切换到其他目录里去;<br>可指定目标，不再默认生成第一个目标：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -f Makefile.build </span><br><span class="line"></span><br><span class="line">make -C a/ -f Makefile.build </span><br><span class="line"></span><br><span class="line">make -C a/ -f Makefile.build other_target</span><br></pre></td></tr></table></figure>

<h1 id="自定义make-cmd"><a href="#自定义make-cmd" class="headerlink" title="自定义make_cmd"></a>自定义make_cmd</h1><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#自定义make_cmd</span></span><br><span class="line">伪目标：</span><br><span class="line">  shell_cmd</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 伪目标 和 Makefile 同级目录下 文件/文件夹 重名时make_cmd不会执行；故要用.PHONY显式表示伪目标，定义的是make_cmd而非编译规则</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">  -rm -f hello</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="makefile文件语法"><a href="#makefile文件语法" class="headerlink" title="makefile文件语法"></a>makefile文件语法</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>可理解为变量是字符串流的宏定义</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#常见变量</span></span><br><span class="line">BUILD_DIR = build                                          <span class="comment"># 目标文件夹</span></span><br><span class="line">SRC_DIRS = <span class="variable">$(<span class="built_in">shell</span> pwd)</span>/src                                <span class="comment"># 源文件夹</span></span><br><span class="line">INCLUDE := <span class="variable">$(<span class="built_in">shell</span> pwd)</span>/inc                                <span class="comment"># 头文件夹</span></span><br><span class="line"></span><br><span class="line">CROSS_COMPILE =                                            <span class="comment"># 交叉编译工具头,如：arm-linux-gnueabihf-</span></span><br><span class="line">CC = gcc                                                   <span class="comment"># 编译器设置</span></span><br><span class="line">CFLAGS = -lmath -L ./lib -I <span class="variable">$(INCLUDE)</span> -g -Wall -Wextra -O0     <span class="comment">#-Wextra更多警告</span></span><br><span class="line">SRCS = <span class="variable">$(<span class="built_in">shell</span> find <span class="variable">$(SRC_DIRS)</span> -name &#x27;*.c&#x27;)</span>               <span class="comment"># 根据源文件夹查找所有源文件</span></span><br><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c, <span class="variable">$(BUILD_DIR)</span>/%.o, <span class="variable">$(SRCS)</span>)</span></span><br><span class="line">TARGET = myprogram                                         <span class="comment"># 目标文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#预设变量（用于cmd）</span></span><br><span class="line"><span class="variable">$@</span>                               <span class="comment">#生成目标(target)</span></span><br><span class="line"><span class="variable">$&lt;</span>                               <span class="comment">#第一个依赖文件（prerequisties）</span></span><br><span class="line"><span class="variable">$^</span>                               <span class="comment">#所有依赖文件（依赖的字符串流），以空格分开，不包含重复的依赖文件</span></span><br><span class="line">%.o                               <span class="comment">#通配符；对上一规则依赖项的迭代器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">hello:a.o b.o</span></span><br><span class="line">  gcc -o hello <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">  gcc -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h2><p>:&#x3D;              执行make规则时赋值<br>A&#x3D;$(B)               得到B的最终值<br>A?&#x3D;               若前面已经定义A,则不覆盖前面的赋值<br>+&#x3D;            附加<br>$(X):取X变量的值<br>@+shell命令：执行make时显示执行结果而不显示执行了这条命令的记录<br>all:执行make时，若没指定目标，则执行all下的默认指令或生成其右边的默认生成目标</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">all：a</span><br><span class="line"></span><br><span class="line"><span class="section">a: a.c</span></span><br><span class="line">  gcc -o a a.c</span><br><span class="line">  _______________________________________________</span><br><span class="line">A:=123</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">  @echo $A</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="函数-fun-arg-…"><a href="#函数-fun-arg-…" class="headerlink" title="函数$(fun arg,…)"></a>函数$(fun arg,…)</h2><p>$(wildcard 格式)                               &#x20;</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span>                              <span class="comment">#找到当前目录下所有后缀为.c的文件,生成文件名.c流赋值给src</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>$$\text{$ (patsubst 格式1的字符,格式2的字符,字符串流 )}$$</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o, <span class="variable">$(src)</span>)</span>                                  <span class="comment">#把字符串流中的.c文件替换成.o</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>$(foreach 变量a,字符串流,对a的引用进行的运算):遍历字符串流放入变量a;并执行运算，生成运算后的字符串流</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">A:= a.o b.o</span><br><span class="line">dep_files := <span class="variable">$(<span class="built_in">foreach</span> f, <span class="variable">$(A)</span>, .<span class="variable">$(f)</span>.d)</span>                          <span class="comment"># 最终 dep_files := .a.o.d .b.o.d</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

$$\begin{array}{ll}\text{\$(filter}&\text{\%/,}&\text{\$(C))}\\\text{\$(filter-out}&\text{ \%/,}&\text{\$(C))}\end{array}$$;筛出/排除C中符合%/格式的值

<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">C =a b c d/</span><br><span class="line">D=<span class="variable">$(<span class="built_in">filter</span> %/,<span class="variable">$(C)</span>)</span></span><br><span class="line">E=<span class="variable">$(<span class="built_in">filter</span>-out %/,<span class="variable">$(C)</span>)</span></span><br></pre></td></tr></table></figure>

<h1 id="自动生成依赖"><a href="#自动生成依赖" class="headerlink" title="自动生成依赖"></a>自动生成依赖</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -M c.c//打印出生成c.o的依赖</span><br><span class="line">gcc -M -MF c.d c.c//把依赖写入c.d</span><br><span class="line"></span><br><span class="line">gcc -c -o c.o c.c -MD -MF c.d//编译c.o;把依赖写入c.d</span><br></pre></td></tr></table></figure>

<h1 id="makefile模板？天书"><a href="#makefile模板？天书" class="headerlink" title="makefile模板？天书"></a>makefile模板？天书</h1><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">objs := main.o sub.o</span><br><span class="line">test : <span class="variable">$(objs)</span></span><br><span class="line">  gcc -o test <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line">CFLAGS = -werror -I ./inc -Lname</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成.o文件的依赖文件列表，并列出其中存在的</span></span><br><span class="line"><span class="comment"># .main.o.d .sub.o.d</span></span><br><span class="line">dep_files := <span class="variable">$(<span class="built_in">foreach</span> f, <span class="variable">$(objs)</span>, .<span class="variable">$(f)</span>.d)</span></span><br><span class="line">dep_files := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(dep_files)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 已存在依赖列表不为空，包含进来</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(dep_files)</span>,)</span><br><span class="line">  <span class="keyword">include</span> <span class="variable">$(dep_files)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">%.o : %.c</span><br><span class="line">  gcc <span class="variable">$(CFLAGS)</span> -Wp,-MD,.<span class="variable">$@</span>.d -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#删除.o,可执行</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">  rm *.o test -f</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除.o,可执行,依赖</span></span><br><span class="line"><span class="section">distclean:</span></span><br><span class="line">  rm <span class="variable">$(dep_files)</span> *.o test -f</span><br><span class="line">  </span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:disclean</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>大型项目makefile:<br>参数：<br>1)支持多个目录、多层目录、多个文件；<br>2)支持给所有文件设置编译选项；<br>3)支持给目录设置编译选项；<br>4)支持给某个文件单独设置编译选项；<br>设计：<br>1)Makefile文件确定要编译的当前目录文件和子目录<br>2)Makefile.build文件包含规则<br>3)每个需要编译的子目录都放个Makefile文件，把需要编译的文件编译成<strong>built-in.o</strong><br>4)再把所有子目录的<strong>built-in.o</strong>链接到顶层的<strong>built-in.o</strong><br>5)最后把顶层<strong>built-in.o</strong>链接到<strong>APP****生成可执行文件</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CROSS_COMPILE = <span class="comment"># 交叉编译工具头,如：arm-linux-gnueabihf-</span></span><br><span class="line">AS      = <span class="variable">$(CROSS_COMPILE)</span>as <span class="comment"># 把汇编文件生成目标文件</span></span><br><span class="line">LD      = <span class="variable">$(CROSS_COMPILE)</span>ld <span class="comment"># 链接器，为前面生成的目标代码分配地址空间，将多个目标文件链接成一个库或者一个可执行文件</span></span><br><span class="line">CC      = <span class="variable">$(CROSS_COMPILE)</span>gcc <span class="comment"># 编译器，对 C 源文件进行编译处理，生成汇编文件</span></span><br><span class="line">CPP    = <span class="variable">$(CC)</span> -E</span><br><span class="line">AR      = <span class="variable">$(CROSS_COMPILE)</span>ar <span class="comment"># 打包器，用于库操作，可以通过该工具从一个库中删除或则增加目标代码模块</span></span><br><span class="line">NM     = <span class="variable">$(CROSS_COMPILE)</span>nm <span class="comment"># 查看静态库文件中的符号表</span></span><br><span class="line"></span><br><span class="line">STRIP       = <span class="variable">$(CROSS_COMPILE)</span>strip <span class="comment"># 以最终生成的可执行文件或者库文件作为输入，然后消除掉其中的源码</span></span><br><span class="line">OBJCOPY  = <span class="variable">$(CROSS_COMPILE)</span>objcopy <span class="comment"># 复制一个目标文件的内容到另一个文件中，可用于不同源文件之间的格式转换</span></span><br><span class="line">OBJDUMP = <span class="variable">$(CROSS_COMPILE)</span>objdump <span class="comment"># 查看静态库或则动态库的签名方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 共享到sub-Makefile</span></span><br><span class="line"><span class="keyword">export</span> AS LD CC CPP AR NM</span><br><span class="line"><span class="keyword">export</span> STRIP OBJCOPY OBJDUMP</span><br><span class="line"></span><br><span class="line"><span class="comment">#compile and lib parameter</span></span><br><span class="line"><span class="comment">#编译参数</span></span><br><span class="line"><span class="comment"># -Wall ： 允许发出 GCC 提供的所有有用的报警信息</span></span><br><span class="line"><span class="comment"># -O2 : “-On”优化等级</span></span><br><span class="line"><span class="comment"># -g : 在可执行程序中包含标准调试信息</span></span><br><span class="line"><span class="comment"># -I : 指定头文件路径（可多个）</span></span><br><span class="line"><span class="comment"># LDFLAGS库路径</span></span><br><span class="line"><span class="comment">#CC      := gcc</span></span><br><span class="line">LIBS    :=</span><br><span class="line">LDFLAGS := -L <span class="variable">$(<span class="built_in">shell</span> pwd)</span>/lib</span><br><span class="line">DEFINES := </span><br><span class="line">INCLUDE := -I <span class="variable">$(<span class="built_in">shell</span> pwd)</span>/<span class="keyword">include</span></span><br><span class="line">CFLAGS  := -g -Wall -O2 -g <span class="variable">$(DEFINES)</span> <span class="variable">$(INCLUDE)</span></span><br><span class="line">CXXFLAGS:= <span class="variable">$(CFLAGS)</span> -DHAVE_CONFIG_H</span><br><span class="line"></span><br><span class="line"><span class="comment"># 共享到sub-Makefile</span></span><br><span class="line"><span class="keyword">export</span> CFLAGS LDFLAGS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顶层路径</span></span><br><span class="line">TOPDIR := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="keyword">export</span> TOPDIR</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终目标</span></span><br><span class="line">TARGET := test</span><br><span class="line"></span><br><span class="line"><span class="comment">#自动找把当前目录下所有.c和.cpp文件，并将目标定义为同名.o文件</span></span><br><span class="line">SOURCE  := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span> <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span></span><br><span class="line">OBJS    := <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">patsubst</span> %.cpp,%.o,<span class="variable">$(SOURCE)</span>)</span>)</span><br><span class="line">OBJS += subdir/ <span class="comment"># 需要进入 subdir 这个子目录去寻找文件来编进程序里，具体是哪些文件，由 subdir 目录下的 Makefile 决定。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个目标</span></span><br><span class="line">all : start_recursive_build <span class="variable">$(TARGET)</span></span><br><span class="line">    @echo <span class="variable">$(TARGET)</span> has been built !</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 处理第一个依赖，**转到 Makefile.build 执行**</span></span><br><span class="line"><span class="section">start_recursive_build:</span></span><br><span class="line">    make -C ./ -f <span class="variable">$(TOPDIR)</span>/Makefile.build</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 处理最终目标，把前期处理得出的 built-in.o 用上</span></span><br><span class="line"><span class="variable">$(TARGET)</span> : built-in.o</span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$(TARGET)</span> built-in.o <span class="variable">$(LDFLAGS)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 清理</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f <span class="variable">$(<span class="built_in">shell</span> find -name &quot;*.o&quot;)</span></span><br><span class="line">    rm -f <span class="variable">$(TARGET)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 彻底清理</span></span><br><span class="line"><span class="section">distclean:</span></span><br><span class="line">    rm -f <span class="variable">$(<span class="built_in">shell</span> find -name &quot;*.o&quot;)</span></span><br><span class="line">    rm -f <span class="variable">$(<span class="built_in">shell</span> find -name &quot;*.d&quot;)</span></span><br><span class="line">    rm -f <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>

<p>makefile.build:</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 伪目标</span></span><br><span class="line">PHONY := __build</span><br><span class="line"><span class="section">__build:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空需要的变量</span></span><br><span class="line">OBJS :=</span><br><span class="line">subdir-y :=</span><br><span class="line">EXTRA_CFLAGS :=</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含同级目录Makefile</span></span><br><span class="line"><span class="comment"># 这里要注意，相对路径为 执行本 Makefile.build 的路径</span></span><br><span class="line"><span class="keyword">include</span> Makefile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前 Makefile 需要编译的子目录的目录名</span></span><br><span class="line"><span class="comment"># obj-y := a.o b.o c/ d/</span></span><br><span class="line"><span class="comment"># $(filter %/, $(obj-y))   : c/ d/</span></span><br><span class="line"><span class="comment"># __subdir-y  : c/ d/</span></span><br><span class="line"><span class="comment"># subdir-y    : c d</span></span><br><span class="line">__subdir-y  := <span class="variable">$(<span class="built_in">patsubst</span> %/,%,$(<span class="built_in">filter</span> %/, <span class="variable">$(OBJS)</span>)</span>)</span><br><span class="line">subdir-y  += $(__subdir-y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把子目录的目标定为以下注释</span></span><br><span class="line"><span class="comment"># built-in.o d/built-in.o</span></span><br><span class="line">subdir_objs := <span class="variable">$(<span class="built_in">foreach</span> f,$(subdir-y)</span>,<span class="variable">$(f)</span>/built-in.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前目录需要编进程序的文件名作为，并写为目标</span></span><br><span class="line"><span class="comment"># a.o b.o</span></span><br><span class="line">cur_objs := <span class="variable">$(<span class="built_in">filter</span>-out %/, <span class="variable">$(OBJS)</span>)</span></span><br><span class="line"><span class="comment"># 使修改头文件 .h 后，重新make后可以重新编译（重要）</span></span><br><span class="line">dep_files := <span class="variable">$(<span class="built_in">foreach</span> f,<span class="variable">$(cur_objs)</span>,.<span class="variable">$(f)</span>.d)</span></span><br><span class="line"><span class="comment"># 列出存在的文件</span></span><br><span class="line">dep_files := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(dep_files)</span>)</span></span><br><span class="line"><span class="comment">#不为空则把存在的依赖文件包含进来（依赖文件内容是是源文件-&gt;.o文件的依赖关系）</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(dep_files)</span>,)</span><br><span class="line">  <span class="keyword">include</span> <span class="variable">$(dep_files)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PHONY += $(subdir-y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一个目标；依赖是子目录和built-in.o</span></span><br><span class="line">__build : $(subdir-y) built-in.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 优先编译 子目录的内容</span></span><br><span class="line"><span class="section">$(subdir-y):</span></span><br><span class="line">  make -C <span class="variable">$@</span> -f <span class="variable">$(TOPDIR)</span>/Makefile.build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接成 目标</span></span><br><span class="line">built-in.o : <span class="variable">$(cur_objs)</span> <span class="variable">$(subdir_objs)</span></span><br><span class="line">  <span class="variable">$(LD)</span> -r -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line">dep_file = .<span class="variable">$@</span>.d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 cur_objs 目标</span></span><br><span class="line">%.o : %.c</span><br><span class="line">  <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(EXTRA_CFLAGS)</span> $(CFLAGS_<span class="variable">$@</span>) -Wp,-MD,<span class="variable">$(dep_file)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line">  </span><br><span class="line">.PHONY : <span class="variable">$(PHONY)</span></span><br></pre></td></tr></table></figure>

<p><strong>生成静态链接库</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#target you can change test to what you want</span></span><br><span class="line"><span class="comment">#共享库文件名，lib*.a</span></span><br><span class="line">TARGET  := libtest.a</span><br><span class="line">  </span><br><span class="line"><span class="comment">#compile and lib parameter</span></span><br><span class="line"><span class="comment">#编译参数</span></span><br><span class="line">CC      := gcc</span><br><span class="line">AR      = ar</span><br><span class="line">RANLIB  = ranlib</span><br><span class="line">LIBS    :=</span><br><span class="line">LDFLAGS :=</span><br><span class="line">DEFINES :=</span><br><span class="line">INCLUDE := -I.</span><br><span class="line">CFLAGS  := -g -Wall -O3 <span class="variable">$(DEFINES)</span> <span class="variable">$(INCLUDE)</span></span><br><span class="line">CXXFLAGS:= <span class="variable">$(CFLAGS)</span> -DHAVE_CONFIG_H</span><br><span class="line">  </span><br><span class="line"><span class="comment">#i think you should do anything here</span></span><br><span class="line"><span class="comment">#下面的基本上不需要做任何改动了</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#source file</span></span><br><span class="line"><span class="comment">#源文件，自动找所有.c和.cpp文件，并将目标定义为同名.o文件</span></span><br><span class="line">SOURCE  := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span> <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span></span><br><span class="line">OBJS    := <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">patsubst</span> %.cpp,%.o,<span class="variable">$(SOURCE)</span>)</span>)</span><br><span class="line">  </span><br><span class="line">.PHONY : everything objs clean veryclean rebuild</span><br><span class="line">  </span><br><span class="line">everything : <span class="variable">$(TARGET)</span></span><br><span class="line">  </span><br><span class="line">all : <span class="variable">$(TARGET)</span></span><br><span class="line">  </span><br><span class="line">objs : <span class="variable">$(OBJS)</span></span><br><span class="line">  </span><br><span class="line"><span class="section">rebuild: veryclean everything</span></span><br><span class="line">                </span><br><span class="line">clean :</span><br><span class="line">    rm -fr *.o</span><br><span class="line">    </span><br><span class="line">veryclean : clean</span><br><span class="line">    rm -fr <span class="variable">$(TARGET)</span></span><br><span class="line">  </span><br><span class="line"><span class="variable">$(TARGET)</span> : <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(AR)</span> cru <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(RANLIB)</span> <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>

<p><strong>生成动态链接库</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">######################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">######################################</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#target you can change test to what you want</span></span><br><span class="line"><span class="comment">#共享库文件名，lib*.so</span></span><br><span class="line">TARGET  := libtest.so</span><br><span class="line">  </span><br><span class="line"><span class="comment">#compile and lib parameter</span></span><br><span class="line"><span class="comment">#编译参数</span></span><br><span class="line">CC      := gcc</span><br><span class="line">LIBS    :=</span><br><span class="line">LDFLAGS :=</span><br><span class="line">DEFINES :=</span><br><span class="line">INCLUDE := -I.</span><br><span class="line">CFLAGS  := -g -Wall -O3 <span class="variable">$(DEFINES)</span> <span class="variable">$(INCLUDE)</span></span><br><span class="line">CXXFLAGS:= <span class="variable">$(CFLAGS)</span> -DHAVE_CONFIG_H</span><br><span class="line">SHARE   := -fPIC -shared -o</span><br><span class="line">  </span><br><span class="line"><span class="comment">#i think you should do anything here</span></span><br><span class="line"><span class="comment">#下面的基本上不需要做任何改动了</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#source file</span></span><br><span class="line"><span class="comment">#源文件，自动找所有.c和.cpp文件，并将目标定义为同名.o文件</span></span><br><span class="line">SOURCE  := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span> <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span></span><br><span class="line">OBJS    := <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">patsubst</span> %.cpp,%.o,<span class="variable">$(SOURCE)</span>)</span>)</span><br><span class="line">  </span><br><span class="line">.PHONY : everything objs clean veryclean rebuild</span><br><span class="line">  </span><br><span class="line">everything : <span class="variable">$(TARGET)</span></span><br><span class="line">  </span><br><span class="line">all : <span class="variable">$(TARGET)</span></span><br><span class="line">  </span><br><span class="line">objs : <span class="variable">$(OBJS)</span></span><br><span class="line">  </span><br><span class="line"><span class="section">rebuild: veryclean everything</span></span><br><span class="line">                </span><br><span class="line">clean :</span><br><span class="line">    rm -fr *.o</span><br><span class="line">    </span><br><span class="line">veryclean : clean</span><br><span class="line">    rm -fr <span class="variable">$(TARGET)</span></span><br><span class="line">  </span><br><span class="line"><span class="variable">$(TARGET)</span> : <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$(SHARE)</span> <span class="variable">$@</span> <span class="variable">$(OBJS)</span> <span class="variable">$(LDFLAGS)</span> <span class="variable">$(LIBS)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span>          <span class="comment">#生成.c依赖文件字符串流；找到当前目录下所有.c文件生成字符串流</span></span><br><span class="line"></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span>                                  <span class="comment">#把.c字符串流变成.o字符串流</span></span><br><span class="line"></span><br><span class="line"><span class="section">ALL:math.out                                                        #指定构建树最终结果</span></span><br><span class="line"></span><br><span class="line">a.</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>vi</title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/vi/vi/</url>
    <content><![CDATA[<h2 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h2><p><img src="/image/image_mRZtTG7eZR.png"></p>
<p>vi file_name用vi编辑器打开或创建file_name文件<br>移动光标<br>【h、j、k、l】光标左、下、上、右<br>【ctrl+b】屏幕往”后”移动一页<br>【ctrl+f】屏幕往”前”移动一页</p>
<p>【G】 移动到文件最后一行<br>【gg】 移动到文件第一行<br>【n&lt;Enter&gt;】光标向下移动n行</p>
<p>【0】移动到本行首</p>
<p>【n&lt;space&gt;】光标右移n位</p>
<p>查找与替换<br>【&#x2F;word】 向下寻找word字符串<br>【?word】 向上寻找word字符串<br>【n】 代表重复前一个查找的动作<br>【N】 与n刚好相反，为【反向】进行行前一个查找动作</p>
<p>【:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g】  n1与n2为数字，在第n1与n2行之间查找word1 这个字符串，并将该字符串替换为word2</p>
<p>【:1,$s&#x2F;word1&#x2F;word2&#x2F;gc】 从第一行到最后一行查找word1字符串，并将该字符串替换为word2 ，且在替换前提示用户确认是否进行替换</p>
<p>删除</p>
<p>【x】 为向后删除一个字符 (相当于【del】键)<br><strong>【X】 为向前删除一个字符(相当于【backspace】键)</strong></p>
<p>【dd】 删除光标所在行<br>【ndd】 删除光标所在的向下n行</p>
<p>复制</p>
<p>【yy】 复制光标所在的那一行<br>【nyy】 复制光标所在的向下n列</p>
<p>【y1G】 复制光标所在行到第一行的所有数据<br>【yG】 复制光标所在行到最后一行的所有数据</p>
<p>【y0】 复制光标所在的那个字符到该行行首的所有数据<br>【y$】 复制光标所在的那个字符到该行行尾的所有数据</p>
<p>粘贴</p>
<p>【p】将已复制的数据在光标下一行粘贴上</p>
<p>撤回</p>
<p>【u】 恢复前一个操作<br>【Ctrl+r】重做上一个操作</p>
<p>【.】 是重复前一个操作</p>
<p>【:w】 保存编辑的内容<br>【:w!】强制写入该文件，但跟你对该文件的权限有关<br>【:q!】 不想保存修改强制离开<br>【:wq】 强制写入并保存后离开<br>【:x】 保存后离开</p>
<p>【:w filename】 （另存为filename）<br>【:r filename】 在编辑的数据中，读入另一个文件的数据。即将filename这个文件的内容加到光标所在行后面。</p>
<p>【:n1,n2 w filename】 将n1到n2的内容保存成filename这个文件。<br>【:! command】暂时离开vi 到命令行模式下执行command的显示结果！例如 【:! ls &#x2F;home】即可在 vi 当中察看&#x2F;home底下以ls输出的文件信息！</p>
<p>【:set nu】 显示行号<br>【:set nonu】 与 set nu 相反，为取消行</p>
<p>o向下新增一行<br>————————————————</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/%E5%B7%A5%E7%A8%8B%E8%90%BD%E5%9C%B0%E6%96%B9%E6%B3%95%E8%AE%BA/%E5%B7%A5%E7%A8%8B%E8%90%BD%E5%9C%B0%E6%96%B9%E6%B3%95%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="工程落地方法论"><a href="#工程落地方法论" class="headerlink" title="工程落地方法论"></a>工程落地方法论</h1><p>软件系统构建的方法论</p>
<p><a href="https://time.geekbang.org/column/intro/158?utm_term=zeusLXRY5&utm_source=zhihu-ad&utm_medium=article&utm_campaign=100023701&utm_content=203369797&tab=catalog" title="https://time.geekbang.org/column/intro/158?utm_term=zeusLXRY5&amp;utm_source=zhihu-ad&amp;utm_medium=article&amp;utm_campaign=100023701&amp;utm_content=203369797&amp;tab=catalog">https://time.geekbang.org/column/intro/158?utm_term&#x3D;zeusLXRY5&amp;utm_source&#x3D;zhihu-ad&amp;utm_medium&#x3D;article&amp;utm_campaign&#x3D;100023701&amp;utm_content&#x3D;203369797&amp;tab&#x3D;catalog</a></p>
<p>工程目标<br>1】用户满意度：<br>2】可靠性：在某时间，环境条件下，系统或服务充分执行其预期功能的概率<br>3】流程质量：按时按质按量交付<br>4】可维护性</p>
<p><img src="/image/image_l5LFm-l0B9.png"></p>
<p>cnblogs.com&#x2F;xinz&#x2F;p&#x2F;3803035.html</p>
<p><img src="/image/image_X8jTSSVaTH.png"></p>
<p>软件是否能长期存活取决于是否有可持续商业模式；以及经营不出大问题（财务，管理，开发维护，营销）</p>
<p>软件开发维护的生命周期：</p>
<p>产品规划，时间估计</p>
<p><strong>需求分析</strong>&#x20;<br>软件系统是某个复杂系统的组成部分；首先去弄清楚业务系统的人，事，物，规则信息（抽象角度）；按业务线（某个抽象层次）去构建业务系统的静态组成；以及时间轴上信息流动构建动态系统<br>1）涉众；用户分析<br>2）用例分析<br><strong>3）业务线分类（用例图）<br>4）搞清楚主要业务流程（活动图）</strong><br>5）业务规约整理</p>
<p>面向对象设计<br>1）使用mvc抽象出每个步骤的概念类，并弄清楚<strong>业务步骤流程（顺序图）；可按mvc再分组件架构<br>2）映射到设计类（类图）</strong><br>3）架构设计<br>4）（部署图）</p>
<p>实现（写数据结构和算法）<br>设计最基本的算法和数据结构</p>
<p>测试</p>
<p>发布</p>
<p>维护</p>
<p><strong>软件项目的管理</strong>&#x20;</p>
<p><img src="/image/image_d1APACO-fk.png"></p>
<p><img src="/image/image_DxaHKDf_op.png"></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93&amp;%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93&amp;%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="数据库-大规模数据处理"><a href="#数据库-大规模数据处理" class="headerlink" title="数据库&amp;大规模数据处理"></a>数据库&amp;大规模数据处理</h1><p><a href="sqlite/sqlite.md" title="sqlite">sqlite</a></p>
]]></content>
  </entry>
  <entry>
    <title>数据结构&amp;算法</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><img src="/image/image_xSBKfaiu9r.png"></p>
<p><a href="https://www.hello-algo.com/chapter_computational_complexity/time_complexity/#3-on2" title=" 2.3   时间复杂度 - Hello 算法 动画图解、一键运行的数据结构与算法教程 https://www.hello-algo.com/chapter_computational_complexity/time_complexity/#3-on2"> 2.3   时间复杂度 - Hello 算法 动画图解、一键运行的数据结构与算法教程 https://www.hello-algo.com/chapter_computational_complexity&#x2F;time_complexity&#x2F;#3-on2</a></p>
<h1 id="数据结构-data-structure"><a href="#数据结构-data-structure" class="headerlink" title="数据结构 [data structure]"></a>数据结构 [data structure]</h1><p><strong>数据（信息）组织&#x2F;存储方式；</strong><br>设计目标:简洁描述，即快又省<br>0）建模，把实际情况表示成数据<br>1）根据数据集的形而上性质简洁描述；明确数据集的序结构（遍历）；代数结构（其上的元素操作）；拓扑结构（1对1）；存储方式（实现基础）；数据操作；算法在这套场域和规则的基础上编制<br>序结构：信息按一定规则和结构进行分类、排序和存储；能提高信息操作效率、节省存储<br>2）数据操作尽<strong>快</strong>（增，删，改，查，读取，遍历，合并，极值操作）<br>3）<strong>存储</strong>占用尽量<strong>少</strong></p>
<p><strong>常见数据结构：</strong><br>1）存储方式（物理结构）分类：</p>
<ul>
<li>连续空间存储(<strong>基于数组</strong>)：栈、队列、哈希表、树、堆、图、矩阵、张量（维度 ≥3 的数组）等。</li>
<li>离散空间存储(<strong>基于链表</strong>)：栈、队列、哈希表、树、堆、图等。</li>
</ul>
<p>2）按数据拓扑结构结构分类：</p>
<ul>
<li><strong>线性表</strong>（数据单元1对1）：数组、链表、队列、栈、哈希表（线性序结构，方便遍历操作；数组链表适用于随机数据访问，队列适合层序数据访问；栈适合历史按时序先后数据访问，哈希表是支持随机访问的加密线性表）</li>
<li><strong>树形结构</strong>（一对多的拓扑）：树、堆、哈希表（存在前中后，大小顶堆序结构，依据序结构方便用分治策略层序分类递归处理，按规则判断可以排除一部分数据从而进行高效读取，增删）</li>
<li><strong>网状</strong>（多对多拓扑）：图（其灵活定义的序结构方便数据进行灵活的访问，访问的自由度，路径效率高）</li>
</ul>
<p><a href="%E6%95%B0%E7%BB%84&%E9%93%BE%E8%A1%A8&%E5%88%97%E8%A1%A8/%E6%95%B0%E7%BB%84&%E9%93%BE%E8%A1%A8&%E5%88%97%E8%A1%A8.md" title="数组&amp;链表&amp;列表">数组&amp;链表&amp;列表</a></p>
<p><a href="%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91.md" title="二叉树">二叉树</a></p>
<p><a href="%E5%A0%86heap/%E5%A0%86heap.md" title="堆heap">堆heap</a></p>
<p><a href="%E5%9B%BEgraph/%E5%9B%BEgraph.md" title="图graph">图graph</a></p>
<p><a href="%E6%A0%88/%E6%A0%88.md" title="栈">栈</a></p>
<p><a href="%E9%98%9F%E5%88%97queue/%E9%98%9F%E5%88%97queue.md" title="队列queue">队列queue</a></p>
<p><a href="%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97deque/%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97deque.md" title="双向队列deque">双向队列deque</a></p>
<p><a href="%E5%93%88%E5%B8%8C%E8%A1%A8hash%20table/%E5%93%88%E5%B8%8C%E8%A1%A8hash%20table.md" title="哈希表hash table">哈希表hash table</a></p>
<h1 id="「算法-algorithm」"><a href="#「算法-algorithm」" class="headerlink" title="「算法 algorithm」"></a>「算法 algorithm」</h1><p>有限时间内 解决问题的 操作步骤；有以下特性：</p>
<ul>
<li>解决的问题是明确的，有清晰的输入&#x2F;输出约束</li>
<li>可行性：有限步骤、时间和空间下完成</li>
<li>唯一性：步骤有确定含义，相同输入和运行条件下，输出相同</li>
</ul>
<p><a href="%E7%AE%97%E6%B3%95%E8%AF%84%E4%BC%B0/%E7%AE%97%E6%B3%95%E8%AF%84%E4%BC%B0.md" title="算法评估">算法评估</a></p>
<p><a href="%E9%87%8D%E5%A4%8D%E6%93%8D%E4%BD%9C%EF%BC%88%E8%BF%AD%E4%BB%A3&%E9%80%92%E5%BD%92%EF%BC%89/%E9%87%8D%E5%A4%8D%E6%93%8D%E4%BD%9C%EF%BC%88%E8%BF%AD%E4%BB%A3&%E9%80%92%E5%BD%92%EF%BC%89.md" title="重复操作（迭代&amp;递归）">重复操作（迭代&amp;递归）</a></p>
<h2 id="算法策略："><a href="#算法策略：" class="headerlink" title="算法策略："></a>算法策略：</h2><p>递推</p>
<p>枚举：遍历预先已知的有限选项集（解空间）；逐个验证所有选项取最优（或取正确）</p>
<p><a href="%E5%88%86%E6%B2%BBdivide%20and%20conquer%EF%BC%9A/%E5%88%86%E6%B2%BBdivide%20and%20conquer%EF%BC%9A.md" title="分治divide and conquer：">分治divide and conquer：</a></p>
<p>减治：<br>1）将原问题递归分解为若干子问题，每层分解时通过某种判断排除部分冗余的子问题<br>2）解决最终剩下的最小子问题</p>
<p><a href="%E5%9B%9E%E6%BA%AFbacktracking%20algorithm%EF%BC%9A/%E5%9B%9E%E6%BA%AFbacktracking%20algorithm%EF%BC%9A.md" title="回溯backtracking algorithm：">回溯backtracking algorithm：</a></p>
<p><a href="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20dynamic%20programming/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20dynamic%20programming.md" title="动态规划 dynamic programming">动态规划 dynamic programming</a></p>
<p><a href="%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%20greedy%20algorithm/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%20greedy%20algorithm.md" title="贪心算法 greedy algorithm">贪心算法 greedy algorithm</a></p>
<p>概率</p>
<h2 id="算法场景："><a href="#算法场景：" class="headerlink" title="算法场景："></a>算法场景：</h2><h3 id="1）排序sorting-algorithm："><a href="#1）排序sorting-algorithm：" class="headerlink" title="1）排序sorting algorithm："></a>1）排序sorting algorithm：</h3><p><img src="/image/image_EwohX-uEQg.png"></p>
<p><a href="%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%20selection%20sort/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%20selection%20sort.md" title="选择排序 selection sort">选择排序 selection sort</a></p>
<p><a href="%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%20bubble%20sort;O(n%5E2)/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%20bubble%20sort;O(n%5E2).md" title="冒泡排序 bubble sort;O(n^2)">冒泡排序 bubble sort;O(n^2)</a></p>
<p><a href="%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%20insertion%20sort/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%20insertion%20sort.md" title="插入排序 insertion sort">插入排序 insertion sort</a></p>
<p><a href="%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%20quick%20sort/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%20quick%20sort.md" title="快速排序 quick sort">快速排序 quick sort</a></p>
<p><a href="%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%20merge%20sort%EF%BC%9BO(nlogn)/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%20merge%20sort%EF%BC%9BO(nlogn).md" title="归并排序 merge sort；O(nlogn)">归并排序 merge sort；O(nlogn)</a></p>
<p><a href="%E5%A0%86%E6%8E%92%E5%BA%8F%20heap%20sort%EF%BC%9BO(nlogn)/%E5%A0%86%E6%8E%92%E5%BA%8F%20heap%20sort%EF%BC%9BO(nlogn).md" title="堆排序 heap sort；O(nlogn)">堆排序 heap sort；O(nlogn)</a></p>
<p><a href="%E6%A1%B6%E6%8E%92%E5%BA%8F%20bucket%20sort;O(n)/%E6%A1%B6%E6%8E%92%E5%BA%8F%20bucket%20sort;O(n).md" title="桶排序 bucket sort;O(n)">桶排序 bucket sort;O(n)</a></p>
<p><a href="%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%20counting%20sort%EF%BC%9BO(n)/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%20counting%20sort%EF%BC%9BO(n).md" title="计数排序 counting sort；O(n)">计数排序 counting sort；O(n)</a></p>
<p><a href="%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%20radix%20sort;O(n)/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%20radix%20sort;O(n).md" title="基数排序 radix sort;O(n)">基数排序 radix sort;O(n)</a></p>
<h3 id="2）搜索："><a href="#2）搜索：" class="headerlink" title="2）搜索："></a>2）搜索：</h3><p>枚举策略（适合无序，低频查找数据，无额外开销）O(n)；减治策略（适合数据本身有序结构{注意数组连续存储不适合大量级数据},但往往要对数据预处理，有额外开销：队列，hash,预处理；维护有序性的开销要考虑进去：增删）logn</p>
<p><img src="/image/image_S2bB1ZMQaK.png"></p>
<p>搜索算法的选择还取决于数据体量、搜索性能要求、数据查询与更新频率等。</p>
<p><a href="%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE%E7%9A%84hash%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE%E7%9A%84hash%E4%BC%98%E5%8C%96.md" title="线性查找的hash优化">线性查找的hash优化</a></p>
<p><a href="%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BEbinary%20search;logn/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BEbinary%20search;logn.md" title="二分查找binary search;logn ">二分查找binary search;logn </a></p>
<p><a href="%E6%A0%91%E6%9F%A5%E6%89%BE/%E6%A0%91%E6%9F%A5%E6%89%BE.md" title="树查找">树查找</a></p>
<p><a href="%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2-%E7%94%9F%E6%88%90h%E5%85%83%E7%BB%84%E5%90%88%EF%BC%88%E5%88%86%E9%87%8F%E6%9C%89%E5%BA%8F%E7%BB%93%E6%9E%84%EF%BC%89/%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2-%E7%94%9F%E6%88%90h%E5%85%83%E7%BB%84%E5%90%88%EF%BC%88%E5%88%86%E9%87%8F%E6%9C%89%E5%BA%8F%E7%BB%93%E6%9E%84%EF%BC%89.md" title="暴力搜索/生成h元组合（分量有序结构）">暴力搜索&#x2F;生成h元组合（分量有序结构）</a></p>
<p><a href="%E7%94%9F%E6%88%90%E5%88%86%E9%87%8F%E6%97%A0%E5%BA%8F%E7%BB%93%E6%9E%84%E7%9A%84h%E5%85%83%E7%BB%84%E5%90%88(%E5%AD%90%E9%9B%86-%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98)/%E7%94%9F%E6%88%90%E5%88%86%E9%87%8F%E6%97%A0%E5%BA%8F%E7%BB%93%E6%9E%84%E7%9A%84h%E5%85%83%E7%BB%84%E5%90%88(%E5%AD%90%E9%9B%86-%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98).md" title="生成分量无序结构的h元组合(子集/组合问题)">生成分量无序结构的h元组合(子集&#x2F;组合问题)</a></p>
<h3 id="3）加密"><a href="#3）加密" class="headerlink" title="3）加密"></a>3）加密</h3><h3 id="4）字符串处理"><a href="#4）字符串处理" class="headerlink" title="4）字符串处理"></a>4）字符串处理</h3><p><a href="%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98.md" title="编辑距离问题">编辑距离问题</a></p>
<h3 id="5）分布式-并行计算"><a href="#5）分布式-并行计算" class="headerlink" title="5）分布式&amp;并行计算"></a>5）分布式&amp;并行计算</h3><h3 id="6-正则表达式"><a href="#6-正则表达式" class="headerlink" title="6)正则表达式"></a>6)正则表达式</h3><h3 id="7-汉诺塔问题"><a href="#7-汉诺塔问题" class="headerlink" title="7)汉诺塔问题"></a>7)汉诺塔问题</h3><p><a href="%E6%B1%89%E8%AF%BA%E5%A1%94/%E6%B1%89%E8%AF%BA%E5%A1%94.md" title="汉诺塔">汉诺塔</a></p>
<h3 id="8-数据表设计"><a href="#8-数据表设计" class="headerlink" title="8)数据表设计"></a>8)数据表设计</h3><p><a href="%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.md" title="构建二叉树">构建二叉树</a></p>
<h3 id="9-最优化问题"><a href="#9-最优化问题" class="headerlink" title="9)最优化问题"></a>9)最优化问题</h3><p>暴力搜索，记忆化搜索（分治），dp问题的解决都伴随状态树生成；分治策略的状态转移是自顶向下生成的；dp是根据状态转移方程直接从最小子状态递推得来的；两者都清楚状态转移方程，但dp策略还要求知道最小子状态</p>
<p><a href="DP%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/DP%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98.md" title="DP最优化问题">DP最优化问题</a></p>
<p><a href="%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2-%E8%AE%B0%E5%BF%86%E6%90%9C%E7%B4%A2%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2-%E8%AE%B0%E5%BF%86%E6%90%9C%E7%B4%A2%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98.md" title="暴力搜索/记忆搜索最优化问题">暴力搜索&#x2F;记忆搜索最优化问题</a></p>
<p><a href="0-1%E5%86%B3%E7%AD%96%E6%A0%91%E9%97%AE%E9%A2%98/0-1%E5%86%B3%E7%AD%96%E6%A0%91%E9%97%AE%E9%A2%98.md" title="0-1决策树问题">0-1决策树问题</a></p>
<p><a href="%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E5%8F%98%E7%A7%8D/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E5%8F%98%E7%A7%8D.md" title="完全背包问题及其变种">完全背包问题及其变种</a></p>
<p><a href="%E5%88%86%E6%95%B0%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/%E5%88%86%E6%95%B0%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.md" title="分数背包问题">分数背包问题</a></p>
<p><a href="%E6%9C%80%E5%A4%A7%E5%AE%B9%E9%87%8F%E9%97%AE%E9%A2%98/%E6%9C%80%E5%A4%A7%E5%AE%B9%E9%87%8F%E9%97%AE%E9%A2%98.md" title="最大容量问题">最大容量问题</a></p>
<p><a href="%E6%9C%80%E5%A4%A7%E5%88%87%E5%88%86%E4%B9%98%E7%A7%AF%E9%97%AE%E9%A2%98/%E6%9C%80%E5%A4%A7%E5%88%87%E5%88%86%E4%B9%98%E7%A7%AF%E9%97%AE%E9%A2%98.md" title="最大切分乘积问题">最大切分乘积问题</a></p>
<h3 id="10-组合优化问题"><a href="#10-组合优化问题" class="headerlink" title="10)组合优化问题"></a>10)组合优化问题</h3><p><a href="n%E7%9A%87%E5%90%8E%EF%BC%88%E6%8E%92%E8%AF%BE%E9%97%AE%E9%A2%98%EF%BC%89/n%E7%9A%87%E5%90%8E%EF%BC%88%E6%8E%92%E8%AF%BE%E9%97%AE%E9%A2%98%EF%BC%89.md" title="n皇后（排课问题）">n皇后（排课问题）</a></p>
<h3 id="11-dp问题"><a href="#11-dp问题" class="headerlink" title="11)dp问题"></a>11)dp问题</h3><p><a href="dp%E9%97%AE%E9%A2%98/dp%E9%97%AE%E9%A2%98.md" title="dp问题">dp问题</a></p>
<p><a href="%E6%8E%92%E5%88%97%E6%95%B0%E9%97%AE%E9%A2%98/%E6%8E%92%E5%88%97%E6%95%B0%E9%97%AE%E9%A2%98.md" title="排列数问题">排列数问题</a></p>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>系统编程</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>os提供诸多服务，其中最重要的系统功能为进程通信，协作，网络访问；<br>基于os提供的服务编程，即面向ANSI&#x2F;posix&#x2F;winAPI编程（linux_cmd就是基于os提供的服务编写的程序）;</p>
<p>在大多数类 Unix 系统，可在 &#x2F;usr&#x2F;include 或 &#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;找到ansicC的.h文件；或在C编译器目录下找</p>
<p>POSIX函数man手册:<code>sudo apt-get install manpages-posix</code>大部分头文件在 <strong>&#x2F;usr&#x2F;include</strong></p>
<p><a href="https://www.bilibili.com/video/BV13b4y1Q7YD/?spm_id_from=trigger_reload&vd_source=5e06b5dd11f67d0863cd77450011b67a" title="操作系统原理(合集)_哔哩哔哩_bilibili 操作系统原理(合集)共计7条视频，包括：进程与线程的区别、进程间通信—互斥、进程间通信—同步等，UP主更多精彩视频，请关注UP账号。 https://www.bilibili.com/video/BV13b4y1Q7YD/?spm_id_from=trigger_reload&amp;vd_source=5e06b5dd11f67d0863cd77450011b67a">操作系统原理(合集)_哔哩哔哩_bilibili 操作系统原理(合集)共计7条视频，包括：进程与线程的区别、进程间通信—互斥、进程间通信—同步等，UP主更多精彩视频，请关注UP账号。 https://www.bilibili.com/video/BV13b4y1Q7YD/?spm_id_from&#x3D;trigger_reload&amp;vd_source&#x3D;5e06b5dd11f67d0863cd77450011b67a</a></p>
<p><a href="https://akaedu.github.io/book/index.html" title="   https://akaedu.github.io/book/index.html">   https://akaedu.github.io/book/index.html</a></p>
<p><a href="linux%E6%8C%87%E5%8D%97/linux%E6%8C%87%E5%8D%97.md" title="linux指南">linux指南</a></p>
<p><a href="linux-cmd/linux-cmd.md" title="linux-cmd">linux-cmd</a></p>
<p><a href="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.md" title="内存管理">内存管理</a></p>
<p><a href="%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8%EF%BC%89/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8%EF%BC%89.md" title="进程管理（多任务调度器）">进程管理（多任务调度器）</a></p>
<p><a href="%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%89/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%89.md" title="文件系统（磁盘管理系统）">文件系统（磁盘管理系统）</a></p>
<p><a href="%E6%96%87%E4%BB%B6IO/%E6%96%87%E4%BB%B6IO.md" title="文件IO">文件IO</a></p>
<p><a href="%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.md" title="错误处理">错误处理</a></p>
<p><a href="%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E6%93%8D%E4%BD%9C/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E6%93%8D%E4%BD%9C.md" title="系统时间操作">系统时间操作</a></p>
<p><a href="%E6%96%B0%E9%A1%B5%E9%9D%A2/%E6%96%B0%E9%A1%B5%E9%9D%A2.md" title="新页面">新页面</a></p>
<p><a href="%E6%96%B0%E9%A1%B5%E9%9D%A2_1/%E6%96%B0%E9%A1%B5%E9%9D%A2.md" title="新页面">新页面</a></p>
<p><a href="%E6%96%B0%E9%A1%B5%E9%9D%A2_2/%E6%96%B0%E9%A1%B5%E9%9D%A2.md" title="新页面">新页面</a></p>
<p><a href="https://www.apiref.com/c-zh/t_io.htm" title=" 输入输出函数 - C语言 - API参考文档  https://www.apiref.com/c-zh/t_io.htm"> 输入输出函数 - C语言 - API参考文档  https://www.apiref.com/c-zh/t_io.htm</a></p>
<p><a href="https://blog.csdn.net/newcong0123/article/details/105836737" title=" 【C语言】如何用代码设置多国语言_int main() { setlocale(lc_all, &quot;chs&quot;); // 将环境设置为中文-CSDN博客 文章浏览阅读1.5k次，点赞2次，收藏7次。写在前面的话：版权声明：本文为博主原创文章，转载请注明出处！博主是一个小菜鸟，并且非常玻璃心！如果文中有什么问题，请友好地指出来，博主查证后会进行更正，啾咪~~每篇文章都是博主现阶段的理解，如果理解的更深入的话，博主会不定时更新文章。本文最后更新时间：2020.4.29正文开始函数详解bindtextdomain() 函数bindtextdomain() https://blog.csdn.net/newcong0123/article/details/105836737"> 【C语言】如何用代码设置多国语言_int main() { setlocale(lc_all, “chs”); &#x2F;&#x2F; 将环境设置为中文-CSDN博客 文章浏览阅读1.5k次，点赞2次，收藏7次。写在前面的话：版权声明：本文为博主原创文章，转载请注明出处！博主是一个小菜鸟，并且非常玻璃心！如果文中有什么问题，请友好地指出来，博主查证后会进行更正，啾咪~~每篇文章都是博主现阶段的理解，如果理解的更深入的话，博主会不定时更新文章。本文最后更新时间：2020.4.29正文开始函数详解bindtextdomain() 函数bindtextdomain() https://blog.csdn.net/newcong0123/article/details/105836737</a></p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>编程范式</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/</url>
    <content><![CDATA[<p>面向过程：程序执行就是一组函数顺序执行。为了降低系统复杂度，函数继续切分为子函数</p>
<p>面向对象：程序执行就是一系列数据在对象之间传递（对象包含了数据和操作数据的函数）</p>
<p>函数式编程：</p>
<p>面向过程<br>面向对象Object Oriented Programming：</p>
<p><a href="https://www.zhihu.com/search?q=%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:3051466608%7D" title="函数式编程">函数式编程</a></p>
]]></content>
      <categories>
        <category>编程范式</category>
      </categories>
      <tags>
        <tag>编程范式</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1>]]></content>
  </entry>
  <entry>
    <title>编程语言</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>计算机硬件系统提供了最基础的元结构，并允许通过编程建模的方式达到各种输出的目的；并且具有层次性，</p>
<p>由于复杂模型的需求，在编程语法以及用户自定义数据结构及算法层面又定义了更高层次的元结构；</p>
<p>故编程&#x3D;抽象出模型目的性+设计元结构+搭建模型</p>
<p>进行后两步工作的使用的主要工具就是编程语言</p>
<p>？：计算机硬件（编程语言工具）怎么让人可以自由搭建模型的；怎么让用户可以自定义元结构的</p>
<p><a href="%E6%B1%87%E7%BC%96%EF%BC%9F%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/%E6%B1%87%E7%BC%96%EF%BC%9F%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4.md" title="汇编？机器指令">汇编？机器指令</a></p>
<p><a href="C/C.md" title="C">C</a></p>
<p><a href="C++/C++.md" title="C++">C++</a></p>
<p><a href="python/python.md" title="python">python</a></p>
<p><a href="%E6%96%B0%E9%A1%B5%E9%9D%A2/%E6%96%B0%E9%A1%B5%E9%9D%A2.md" title="新页面">新页面</a></p>
<p><img src="/image/image_jcrgVll1JN.png"></p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="驱动开发"><a href="#驱动开发" class="headerlink" title="驱动开发"></a>驱动开发</h1>]]></content>
  </entry>
  <entry>
    <title>系统输入信号</title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%EF%BC%88%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%EF%BC%89/%E7%B3%BB%E7%BB%9F%E8%BE%93%E5%85%A5%E4%BF%A1%E5%8F%B7/%E7%B3%BB%E7%BB%9F%E8%BE%93%E5%85%A5%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<p>输入通常是时域上的一个函数$y&#x3D;x(t)$</p>
<h1 id="离散-连续信号"><a href="#离散-连续信号" class="headerlink" title="离散&#x2F;连续信号"></a>离散&#x2F;连续信号</h1><p>自变量t若是连续可变的:$y &#x3D; x(t)$<br>自变量n若是定义在离散的时刻点上:$y&#x3D;x[n]$</p>
<p><img src="/image/image_pKoQbsnVBT.png"></p>
<p><img src="/image/image_mnkWT0BFx4.png"></p>
<h1 id="信号能量-功率"><a href="#信号能量-功率" class="headerlink" title="信号能量&#x2F;功率"></a>信号能量&#x2F;功率</h1><p>$\begin{aligned}连续时间信号x(t);t\in[t_{1},t_{2}]\text{ 的总能量为}&amp;\int_{t_1}^{t_2}|x(t)|^2\mathrm{d}t\end{aligned}$（类比$ui&#x3D;u^2&#x2F;R$的积分，大都是这个形式）</p>
<p>$\begin{aligned}<br>离散时间信号x[n];n\in{n_1,…..n_2}\text{的总能量为}\sum_{n&#x3D;n_1}^|x[n]|^2<br>\end{aligned}$</p>
<p>能量的广义积分&#x2F;求和：$\begin{aligned}E_{\infty}&amp;\stackrel{\triangle}{&#x3D;}\lim_{T\to\infty}\int_{-T}^{T}|x(t)|^{2}\mathrm{d}t&#x3D;\int_{-\infty}^{+\infty}|x(t)|^{2}\mathrm{d}t\\E_{\infty}&amp;\stackrel{\triangle}{&#x3D;}\lim_{N\to\infty}\sum_{n&#x3D;-N}^{+N}|x[n]|^{2}&#x3D;\sum_{n&#x3D;-\infty}^{+\infty}|x[n]|^{2}\end{aligned}$；平均功率：$\begin{aligned}P_\infty\triangleq\lim_{T\to\infty}\frac1{2T}\int_{-T}^T|x(t)|^2\operatorname{d}t\\P_\infty\triangleq\lim_{N\to\infty}\frac1{2N+1}\sum_{n&#x3D;-N}^{+N}|x[n]|^2\end{aligned}$</p>
<h1 id="自变量变换"><a href="#自变量变换" class="headerlink" title="自变量变换"></a>自变量变换</h1><p>$y&#x3D;x(at-b)$<br>时移:$x(t-b)$；体现为信号的超前，滞后<br>反转：$x(-t$);录音带倒放是一个典型应用<br>时间尺度放缩：$x(at)$;倍速播放是典型应用</p>
<p>周期信号：$x(t)&#x3D;x(t+T)$;最小正值$T_0$称基波周期<br>奇偶信号(具备对称性)：$x(t)&#x3D;x(-t);x(t)&#x3D;-x(-t)$<br>任意函数f(x)都能拆分成两个对称函数的和：$f(x)&#x3D;\frac{A(x)+B(x)}{2}$$ A(x)&#x3D;f(x)+f(-x)\B(x)&#x3D;f(x)-f(-x)  $</p>
<p><img src="/image/image_jRg6RIm3Yd.png"></p>
<h1 id="典型信号"><a href="#典型信号" class="headerlink" title="典型信号"></a>典型信号</h1><h2 id="指数-x-t-C-mathrm-e-at"><a href="#指数-x-t-C-mathrm-e-at" class="headerlink" title="指数$x(t)&#x3D;C\mathrm{e}^{at}$"></a>指数$x(t)&#x3D;C\mathrm{e}^{at}$</h2><p>可这样分析$x(t)&#x3D;C\mathrm{e}^{at}$$  |e^{a}|&gt;1:指数发散 $or指数增长包络发散；<br>$|e^{a}|&#x3D;1:x(t)为常数or在+-C之间跳跃$；<br>$|e^{a}|&lt;1:指数收敛or包络收敛$</p>
<p>1）实指数：当a，C为实数；<br>$若a&gt;0:\mathrm{e}^{at}指数上升;<br>若a&lt;0:\mathrm{e}^{at}指数下降$</p>
<p><img src="/image/image_Pw7oDyXAw2.png"></p>
<p>2）虚指数:$a&#x3D;j\omega$;$x(t)&#x3D;Ce^{j\omega t}&#x3D;C[cos(\omega t)+jsin(\omega t)]$<br>很显然，它是周期函数；<br>$倒推其基波周期&#x2F;频率：若为周期函数 \-&gt;e^{j\omega t}&#x3D;e^{j\omega (t+T)}&#x3D;e^{j\omega t}\cdot e^{j\omega T} \&#x3D;&gt;e^{j\omega T}&#x3D;cos(\omega T)+jsin(\omega T)&#x3D;1\ &#x3D;&gt;T_{0}&#x3D;2\pi&#x2F;\omega$$e^{j-\omega t}$也是这样；故$\omega ≠0时：T_{0}&#x3D;2\pi&#x2F;|\omega|$$或只要T_0&gt;0:\omega&#x3D;2\pi T_0$</p>
<p>虚指数；天然的周期复指数通常用于作为信号的构成要素（谐波）</p>
<p>3）复指数$a&#x3D;r+j(\omega +\theta)$;<br>$x(t)&#x3D;Ce^{[r+j(\omega +\theta)] t}&#x3D;C\cdot e^{rt}[cos(j(\omega +\theta) t)+jsin(j(\omega +\theta) t) ]$<br>在电学中复指数是正弦信号的相量形式;<br>显然当$r&gt;0;x(t)是指数增长的包络正弦；r&lt;0;x(t)是指数衰减的包络正弦（阻尼衰减震荡）$</p>
<p><img src="/image/image_fXliCornrx.png"></p>
<p>离散复指数的周期性质：<br>1）对于$e^{j\omega t}，当\omega 变化，信号的震荡频率随之变化，周期也随之变化；但对于e^{j\omega n}：有$$e^{j（\omega +2k\pi）n}&#x3D;e^{j\omega n}\cdot [cos(2k\pi n)+jsin(2k\pi n)] &#x3D;e^{j\omega n}$;即对于离散信号,<strong>角频率变化</strong>$+-2k\pi$<strong>，周期不变化</strong>;即w不能是<br>2)$e^{j\omega (n+T)}&#x3D;e^{j\omega n}&#x3D;&gt;e^{j\omega T}&#x3D;1&#x3D;&gt;T&#x3D;2k\pi&#x2F;\omega$；且为了让T是个整数（如果T不是整数，那么移位后整数n点不一定落在上面），要保证$2\pi &#x2F;\omega$ 是有理数</p>
<p><img src="/image/image_do70bpQEls.png"></p>
<h2 id="正弦-x-t-A-cos-omega-0-t-phi"><a href="#正弦-x-t-A-cos-omega-0-t-phi" class="headerlink" title="正弦$x(t)&#x3D;A\cos(\omega_{0}t+\phi)$"></a>正弦$x(t)&#x3D;A\cos(\omega_{0}t+\phi)$</h2><p>根据欧拉关系：<br>$Acos(\omega t+\phi)&#x3D;\frac{A}{2}\cdot (e^{j(\omega t+\phi)}+ e^{-j(\omega t+\phi)})$$Asin(\omega t+\phi)&#x3D;\frac{A}{2}\cdot (e^{j(\omega t+\phi)}- e^{-j(\omega t+\phi)})$$A\cos(\omega_{0}t+\phi)&#x3D;ARe{\mathrm{e}^{\mathrm{j}(\omega_{0}t+\phi)}}$$A\sin(\omega_0t+\phi)&#x3D;AIm{\mathrm{e}^{\mathrm{j}(\omega_0t+\phi)}}$</p>
<h2 id="奇异函数"><a href="#奇异函数" class="headerlink" title="奇异函数"></a>奇异函数</h2><p>奇异函数拥有奇异点（不连续，不可导点）；不是黎曼可积的，其积分是广义积分（瑕积分）：$\int_a^bf(x)dx&#x3D;\lim_{\varepsilon\to0^+}(\int_a^{c-\varepsilon}f(x)dx+\int_{c+\varepsilon}^bf(x)dx+f(c)\cdot2\varepsilon)；C是瑕点$；<br>而奇异函数奇异点进行广义函数求导：<br>eg:计算单位阶跃函数的导数时，可以使用Dirac Delta函数来表示：$\frac d{dx}H(x)&#x3D;\frac d{dx}\left(\frac12+\frac12\mathrm{sgn}(x)\right)&#x3D;\frac d{dx}\left(\frac12\right)+\frac d{dx}\left(\frac12\mathrm{sgn}(x)\right)&#x3D;0+\frac12\frac d{dx}\mathrm{sgn}(x)$<br>其中，sgn(x)是符号函数，当$x&gt;0$时取值为1，当$x&lt;0$时取值为-1；<br>对于符号函数的导数，我们可以使用Dirac Delta函数的一般化微分来表示：$\frac d{dx}$sgn( x) &#x3D; $2\delta( x)$<br>因此，单位阶跃函数的导数可以表示为：$\frac d{dx}H(x)&#x3D;\frac12\frac d{dx}\mathrm{sgn}(x)&#x3D;\frac12\cdot2\delta(x)&#x3D;\delta(x)$</p>
<h3 id="单位冲激-单位脉冲"><a href="#单位冲激-单位脉冲" class="headerlink" title="单位冲激&#x2F;单位脉冲"></a>单位冲激&#x2F;单位脉冲</h3><p>整数域上的单位冲激序列$\left.\delta[n]&#x3D;\left{\begin{array}{ll}0,&amp;n\neq0\1,&amp;n&#x3D;0\end{array}\right.\right.$；离散脉冲序列是离散阶跃序列的一次差分$\delta[n]&#x3D;u[n]-u[n-1]$</p>
<p><img src="/image/image_2GJItgWvyu.png"></p>
<p>时域上的单位脉冲函数：$  \delta_\bigtriangleup(t)&#x3D;  {\begin{array}{ll}0,&amp;n\notin(0,1]\1,&amp;n\in(0,1]\end{array} $;单位脉冲函数是单位阶跃的一次差分函数$  \delta_\bigtriangleup(t)&#x3D; u(n)-u(n-1) $;标准单位脉冲宽，高，面积都是1</p>
<p><img src="/image/image_vkJXXMIWsb.png"></p>
<p>时域上的单位冲激函数：$\delta(t)&#x3D;\lim_{\Delta\to0}\delta_{\Delta}(t)$;单位冲激函数是单位阶跃函数的一阶微分$\delta(t)&#x3D;\frac{\mathrm{d}u(t)}{\mathrm{d}t}$；冲激强度1表示脉冲积分为1；<br>用卷积正式定义：$ x(t)&#x3D;x(t)<em>\delta(t)&#x3D;\delta(t)<em>x(t)&#x3D;\int_{-\infty}^{+\infty}\delta(\tau)x(t-\tau)\operatorname{d}\tau  $；**任何信号与单位冲激的卷积都&#x3D;信号本身</em></em></p>
<p><img src="/image/image_WzHwn-XK2b.png"></p>
<h3 id="单位阶跃"><a href="#单位阶跃" class="headerlink" title="单位阶跃"></a>单位阶跃</h3><p>整数域上的单位阶跃序列：$\left.u[n]&#x3D;\left{\begin{array}{ll}0,&amp;n&lt;0\1,&amp;n\geqslant0\end{array}\right.\right.$;离散阶跃序列是离散冲激序列的求和$u[n]&#x3D;\sum_{k&#x3D;0}^n\delta[n-k]$</p>
<p>时域上的单位阶跃函数：$\left.u(t)&#x3D;\left{\begin{array}{cc}0,&amp;t&lt;0\1,&amp;t&gt;0\end{array}\right.\right.$；阶跃函数是单位冲激函数的积分：$ u(t)&#x3D;\int_{-\infty}^{t}\delta(\tau)\operatorname{d}\tau  $</p>
<p><img src="/image/image_txKFhAxI5G.png"></p>
<p><img src="/image/image_yYSlXX0AO0.png"></p>
<h3 id="单位斜坡"><a href="#单位斜坡" class="headerlink" title="单位斜坡"></a>单位斜坡</h3>]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>线性时不变系统</title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%EF%BC%88%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%EF%BC%89/%E7%BA%BF%E6%80%A7%E6%97%B6%E4%B8%8D%E5%8F%98%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E6%80%A7%E6%97%B6%E4%B8%8D%E5%8F%98%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>输入可表示为<strong>各点值（或微元）与单位冲激的线性组合</strong>（卷积）</p>
<h1 id="离散线性时不变系统求和：卷积和"><a href="#离散线性时不变系统求和：卷积和" class="headerlink" title="离散线性时不变系统求和：卷积和"></a>离散线性时不变系统求和：卷积和</h1><p>单个离散信号可由单位冲激序列表示：$ x[k]&#x3D; x[k]\cdot\delta[n-k]  $<br>离散输入序列可用卷积和表示$x[n]&#x3D;\sum_{k&#x3D;-\infty}^{+\infty}x[k]\delta[n-k]$;由于线性时不变<br>离散输出序列的卷积和：$y[n]&#x3D;\sum_{k&#x3D;-\infty}^{+\infty}x[k]h[n-k]:&#x3D;x[n]*h[n]$;输入与单位冲激响应的卷积</p>
<h1 id="连续线性时不变系统积分：卷积积分"><a href="#连续线性时不变系统积分：卷积积分" class="headerlink" title="连续线性时不变系统积分：卷积积分"></a>连续线性时不变系统积分：卷积积分</h1><p>对连续函数无穷个点求和必引发悖论；尝试对脉冲微元求和取极限表示这个信号函数：$\delta_\Delta(t-k\Delta)$筛出微元$\delta_k$范围内的高</p>
<p><img src="/image/image_PZ8oksCIM1.png"></p>
<p>$ x(t)&#x3D;\lim_{ \bigtriangleup  \to 0} \sum_{k&#x3D;-\infty}^{+\infty} x(k\Delta)\Delta \cdot\delta_\Delta(t-k\Delta)&#x3D;\int\limits_{-\infty}^{+\infty} x(\tau)\delta(t-\tau)d\tau  $$y(t)&#x3D;\lim_{ \bigtriangleup  \to 0} \sum_{k&#x3D;-\infty}^{+\infty} x(k\Delta)\Delta \cdot h (t-k\Delta)&#x3D;\int\limits_{-\infty}^{+\infty} x(\tau)h(t-\tau)d\tau:&#x3D;x(t)* h(t)$</p>
<h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><p>1）卷积交换律</p>
<p><img src="/image/image_J0YGlps6Di.png"></p>
<p><img src="/image/image_fOTL8cecI-.png"></p>
<p>2）卷积结合律：反映了并联系统转换</p>
<p><img src="/image/image_cigZueb9lm.png"></p>
<p><img src="/image/image_qTgkxG-h-C.png"></p>
<p>3）卷积分配律：反应串联转换<br>因果性：</p>
<p><img src="/image/image_OzhkXZcURU.png"></p>
<p><img src="/image/image_2WsphA4Yx7.png"></p>
<p><img src="/image/image_ZMpADX_nby.png"></p>
<p>4）无记忆性：系统任意时刻输出只取决于当前时刻输入；<br>离散时间线性时不变系统$y[n]&#x3D;\sum_{k&#x3D;-\infty}^{+\infty}x[k]h[n-k]:&#x3D;x[n]*h[n]$,能使其满足无记忆的只有：$筛出x[n]项$；<br>$即k≠n时；h[n-k]≠h[0]时：h[n-k]&#x3D;f(\delta (n-k))&#x3D;0;$$k&#x3D;n时；h[0]&#x3D;f(\delta (0))&#x3D;K\delta(0)$$把x[n]项筛出$;<br>综上：$h(n)&#x3D;K\delta (n)$时；当n不为0，响应为0；当n&#x3D;0,把系数筛出<br>5)可逆性：$x(t)*h(t)*h^{-1}(t)&#x3D;x(t)⇒h(t)*h^{-1}(t)&#x3D;\delta (t)$;筛出每一点再求和还是原来的函数<br>6)因果（不可预测）系统：系统任意时刻输出y(t)取决于现在或以往时刻的输入；对于线性时不变系统；只要将卷积式$x(k≤t)$的项筛出；即当$k&gt;t:h[n-k]&#x3D;0⇒h[n-k]&#x3D;Ku[-(n-t)]$<br>7）稳定性：当$x(t)≤A$;$y(t)&#x3D;x(t)*h(t)也要有界$：则必须满足：<br>$\begin{aligned}|y(t)|&amp;&#x3D;\left|\int_{-\infty}^{+\infty}x(\tau)h(t-\tau)\mathrm{d}\tau\right|\\&amp;\leqslant\int_{-\infty}^{+\infty}|x(\tau)||h(t-\tau)|\mathrm{d}\tau\\&amp;\leqslant B\int_{-\infty}^{+\infty}|h(t-\tau)|\mathrm{d}\tau&lt;\infty \end{aligned}$</p>
<h1 id="因果性时不变系统数学表示"><a href="#因果性时不变系统数学表示" class="headerlink" title="因果性时不变系统数学表示"></a>因果性时不变系统数学表示</h1><p>连续系统约束形式通常为 N 阶线性常系数微分方程： $\sum_{k&#x3D;0}^Na_k\frac{\mathrm{d}^ky(t)}{\mathrm{d}t^k}&#x3D;\sum_{k&#x3D;0}^Mb_k\frac{\mathrm{d}^kx(t)}{\mathrm{d}t^k}$; 左边是 y 对 t 的微分式，左边是 $f(t)$, 故可应用<a href="https://www.wolai.com/obTkJRP6HRtsCTYZXeWbdf" title="微分方程">微分方程</a> 的结论；<br>为何一定是常系数：设$x(t)$的响应是$y(t),a_k(t)$ 为常系数时上述等号才成立；<br>为何是时不变： 其解的构造比如说为 $y&#x3D;Ae^{\alpha t}+Be^{\beta t}+Cf(t)$ ;<br>1)当$t&lt;0^+$时0输入：$\left{\begin{array}{ll}&amp;y(0^+)&#x3D;A+B\&amp;y(+\infty)&#x3D;Cf(+\infty)\end{array}\right. .&#x3D;&gt;y&#x3D;e^t(Ae^{\alpha}+$$Be^\beta)+\frac{y(+\infty)}{f(+\infty)}f(t)$<br>2)当$t&lt;0^+$时0状态：$\left{\begin{array}{ll}y(0^+)&#x3D;0&#x3D;A+B+Cf(0^+)\y(+\infty)&#x3D;Cf(+\infty)\end{array}\right .&#x3D;&gt;y&#x3D;$$e^t(Ae^\alpha+Be^\beta)+\frac{y(+\infty)}{f(+\infty)}f(t)$ ;<br>初始松弛状态下： $y(t)&#x3D;A(e^\alpha-e^\beta)e^t+$$\frac{y(+\infty)}{f(+\infty)}f(t)$ ;又因为 $x(t)&#x3D;\int_{-\infty}^{+\infty}x(\tau)\delta(t-\tau)d\tau$ ; 以M&#x3D;1为例⇒$f(t)&#x3D;x(\tau)\delta(t-\tau)d\tau$:<br>$y(\tau)&#x3D;C_1e^{\tau}+C_2 x(\tau)$$y(\tau ≠t)&#x3D;C_1e^{t}$<br>显然是个时不变系统</p>
<p><img src="/image/image_M_LBk-ZuMZ.png"></p>
<p>离散系统约束形式为N阶线性常系数差分方程：$\sum_{k&#x3D;0}^Na_ky[n-k]&#x3D;\sum_{k&#x3D;0}^Mb_kx[n-k]$<a href="https://www.wolai.com/3x3TtF7yvPKh4UQGKBmTC8" title="差分方程">差分方程</a><br>通过观察，这个差分方程可以写成这样：$y[n]&#x3D;\frac{1}{a_{0}}\left (\sum_{k&#x3D;0}^{M}b_{k}x[n-k]-\sum_{k&#x3D;1}^{N}a_{k}y[n-k]\right)$;很显然这是一个因果系统；其当前输出取决于当前和以往输入和以往输出，形成一种递归树的结构（因此是递归方程）；<br>卷积和且松弛条件下：$y[n]&#x3D;\frac{1}{a_{0}}\left (\sum_{k&#x3D;0}^{M}b_{k}\delta[n-k]-\sum_{k&#x3D;1}^{N}a_{k}h[n-k]\right)$:<br>$y[0]&#x3D;\frac{b_0}{a_0}$$y[1]&#x3D;\frac{b_1-b_0}{a_0}$$y[n]&#x3D;\frac{1}{a_0}(b_n\delta[n-k]-\sum_{k&#x3D;1}^{n-1} a_kh[n-k])$&#x3D;$\frac{1}{a_0}(x[n]-\sum_{i&#x3D;0}^{n-1} y[i] )$<br>显然在松弛条件下是因果时不变的</p>
<h1 id="周期函数输入LTI系统的响应"><a href="#周期函数输入LTI系统的响应" class="headerlink" title="周期函数输入LTI系统的响应"></a>周期函数输入LTI系统的响应</h1><p><a href="https://www.wolai.com/kmtG2gVsCfVfhfBbhDMXF9" title="傅里叶分析">傅里叶分析</a>周期为T的函数x(t)&#x3D;$\frac{a’<em>{0}}{2}+\sum</em>{n&#x3D;1}^{+\infty}(a_{n}\cos n\frac{2\pi}{T}t+b_{n}\sin n\frac{2\pi}{T}t)$&#x3D;$\sum_{n&#x3D;-\infty}^{+\infty}C_ne^{jn\frac{2\pi}{T}t}$<br>频谱系数：{$C_k$}:<br>1)$a’<em>0&#x2F;2$&#x3D;$ \frac{1}{2T}\int</em>{0}^{T} x(t)dt  $<br>2)$a_n&#x3D;\frac{1}{T}\int_{0}^{T} x(t)cosn\frac{2\pi}{T}tdt$<br>3)$b_n&#x3D;\frac{1}{T}\int_{0}^{T} x(t)sinn\frac{2\pi}{T}tdt$<br>4)$C_n&#x3D;\frac{1}{T}\int_{0}^{T} x(t)e^{-jn\frac{2\pi}{T}t}dt$<br>可见周期函数可表示为 无穷个 整数倍谐波频率$n\omega$ 指数函数的线性组合；&#x20;<br>又LTI系统中：输出函数是输入函数与单位冲激响应的卷积：<br>y(t)&#x3D;$x(t)*h(t)$&#x3D;$\int_{-\infty}^{+\infty } h(\tau)x(t-\tau)d\tau$$&#x3D;\int_{-\infty}^{+\infty }h(\tau)\sum_{n&#x3D;-\infty}^{+\infty}C_ne^{jn\frac{2\pi}{T}(t-\tau)}d\tau<br>&#x3D;\sum_{n&#x3D;-\infty}^{+\infty}C_ne^{jn\frac{2\pi}{T} t}\int_{-\infty}^{+\infty }h(\tau)e^{-jn\frac{2\pi}{T}\tau}d\tau&#x3D;\sum_{n&#x3D;-\infty}^{+\infty}C_ne^{jn\frac{2\pi}{T} t}H(s)$<br>满足线性时不变性；<br>其中H(s)是单位冲激响应的拉氏变换；$e^{jn\frac{2\pi}{T} t}H(s)$是是指数信号$e^{jn\frac{2\pi}{T} t}$的响应</p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>常见概率分布</title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87/%E5%B8%B8%E8%A7%81%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/%E5%B8%B8%E8%A7%81%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/615643051" title=" 概率分布是什么——一些常见的概率分布 概率分布（probability distribution）是给出事件发生的概率的函数，它是一种通过样本空间（sample space）和事件的概率描述随机事件的方式。一种对概率的定义是用公理来定义，这种定义要求一个事件的概率满足三条… https://zhuanlan.zhihu.com/p/615643051"> 概率分布是什么——一些常见的概率分布 概率分布（probability distribution）是给出事件发生的概率的函数，它是一种通过样本空间（sample space）和事件的概率描述随机事件的方式。一种对概率的定义是用公理来定义，这种定义要求一个事件的概率满足三条… https://zhuanlan.zhihu.com/p/615643051</a></p>
<h1 id="离散随机变量"><a href="#离散随机变量" class="headerlink" title="离散随机变量"></a>离散随机变量</h1><p><a href="https://zhuanlan.zhihu.com/p/480260072" title=" 常见的离散分布 单点分布（一点分布或退化分布）该分布是最简单的离散型分布，表示随机变量x以概率1（只取）取常数a， 其密度函数为： p(x)=\begin{cases}1,\;x=a\\0,\;x eq a\end{cases} ，其分布函数为： F(x)=I\left\{ x\geq a… https://zhuanlan.zhihu.com/p/480260072"> 常见的离散分布 单点分布（一点分布或退化分布）该分布是最简单的离散型分布，表示随机变量x以概率1（只取）取常数a， 其密度函数为： p(x)&#x3D;\begin{cases}1,\;x&#x3D;a\\0,\;x eq a\end{cases} ，其分布函数为： F(x)&#x3D;I\left\{ x\geq a… https://zhuanlan.zhihu.com/p/480260072</a></p>
<h2 id="0-1分布"><a href="#0-1分布" class="headerlink" title="0-1分布"></a>0-1分布</h2><table>
<thead>
<tr>
<th>X</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td>PMF</td>
<td>1-p</td>
<td>p</td>
</tr>
</tbody></table>
<p>基本事件对应的概率质量函数（k为随机变量X的取值，即情况）</p>
<p><img src="/image/image_HSpsPIICK5.png"></p>
<p>随机事件对应的概率分布函数()</p>
<p>$$<br>F(k，p)&#x3D;\left{\begin{array}{cc}0 &amp; , k&lt;0∪k&gt;1 \ 1-p &amp; , 0\le k&lt;1 \ p &amp; , k&#x3D;1\end{array}\right.<br>$$</p>
<h2 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h2><p>n次独立的试验中，每次试验都服从01分布；获得只有0-1取值的n元有序对，分量取1的概率为p；以有序对中<strong>1出现次数</strong>k作为随机变量X的取值</p>
<p>PMF：k∈【0，n】</p>
<p><img src="/image/image_-0PfkXtRu7.png"></p>
<p><img src="/image/image_tYV-qEOg85.png"></p>
<p>CDF</p>
<p><img src="/image/image_JLr0DYoWV7.png"></p>
<h2 id="泊松分布？"><a href="#泊松分布？" class="headerlink" title="泊松分布？"></a>泊松分布？</h2><p>可理解为n无穷大，p（1出现次数）无穷小的二项分布；当n足够大，p足够小时（当乘积⋋&#x3D;np是一个适中的常数时就能使用）；每个随机变量X的取值所对应的概率质量是稳定的</p>
<p><a href="%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83%E6%8E%A8%E5%AF%BC/%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83%E6%8E%A8%E5%AF%BC.md" title="泊松分布推导">泊松分布推导</a></p>
<p>PMF：</p>
<p><img src="/image/image_PRQPXxKIU0.png"></p>
<p><img src="/image/image_LGX5QIEGW_.png"></p>
<p>CDF:</p>
<p><img src="/image/image_eEnn-6J5TP.png"></p>
<h2 id="离散均匀分布"><a href="#离散均匀分布" class="headerlink" title="离散均匀分布"></a>离散均匀分布</h2><p>离散一致分布：随机变量X的n取值k∈{a,…,b}都有相同概率情况</p>
<p><img src="/image/image_yy-etAUMnI.png"></p>
<p>PMF:</p>
<p><img src="/image/image_2O3uRPWfOt.png"></p>
<p>CDF:N+（a-1）&#x3D;k</p>
<p><img src="/image/image_3kQMUhyDv3.png"></p>
<h2 id="几何分布"><a href="#几何分布" class="headerlink" title="几何分布"></a>几何分布</h2><p>n次独立的试验中，每次试验都服从01分布，每次试验事件发生概率为p,以事件首次发生所需试验次数k作为随机变量<br>PMF:</p>
<p><img src="/image/image_WGSHwDS91A.png"></p>
<p>$$<br>p(p,k)&#x3D;p(1-p)^{k-1}<br>$$</p>
<p>CDF:</p>
<p>$$<br>F(p,k)&#x3D;\sum_{i&#x3D;1}^{k} p(1-p)^{i-1}<br>$$</p>
<h2 id="超几何分布"><a href="#超几何分布" class="headerlink" title="超几何分布"></a>超几何分布</h2><p>对有 N个样本，其中K 个有某特定特征的样本空间进行n次非独立试验（无放回）；以n元有序对中具有这一特征的样本数量k为随机变量&#x20;</p>
<p>PMF:</p>
<p><img src="/image/image_HsJRYumoRh.png"></p>
<p><img src="/image/image_kd8BZKrYXe.png"></p>
<p>如此理解：k元有序对（xj1,…xjk）的个数；n-k元有序对（yj1,…yjn-k）个数；两者相乘就是拥有k个1的n元有序对（zj1,…zjn）的个数；除以n元有序对（zj1,…zjn）的个数&#x3D;n中摸到k的概率</p>
<h1 id="连续型随机变量的概率密度函数"><a href="#连续型随机变量的概率密度函数" class="headerlink" title="连续型随机变量的概率密度函数"></a>连续型随机变量的概率密度函数</h1><h2 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h2><h2 id="指数分布？"><a href="#指数分布？" class="headerlink" title="指数分布？"></a>指数分布？</h2><p>PDF</p>
<p><img src="/image/image_dmti4j3Ipv.png"></p>
<p><img src="/image/image_Q2uWci4zQq.png"></p>
<p>CDF:</p>
<p><img src="/image/image_r38sr8vONu.png"></p>
<p>与泊松分布关系？<br>记忆性？</p>
<h2 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h2><p>随机变量X在区间 (a,b) 上取值,且概率密度一致,实质p(x)是一个斜坡函数</p>
<p>PDF:</p>
<p><img src="/image/image_7q86tH-kEI.png"></p>
<p>CDF:</p>
<p><img src="/image/image_errAVLxWJs.png"></p>
<h2 id="伽马分布"><a href="#伽马分布" class="headerlink" title="伽马分布"></a>伽马分布</h2><h1 id="多维分布"><a href="#多维分布" class="headerlink" title="多维分布"></a>多维分布</h1><h2 id="二维均匀分布"><a href="#二维均匀分布" class="headerlink" title="二维均匀分布"></a>二维均匀分布</h2><p>设G是平面上有界区域,面积为 A,若二维随机变量$(X,Y)∈G$具有概率密度$f(x,y)&#x3D;\begin{cases}1&#x2F;A,\quad\mathrm{(x,y)\in C}\0,\quad\text{其它}\end{cases}$<br>CDF:若区域$G_{1}$是G内的面积为A$_{1}$的子区域，则有$P((X,Y)\in G_1)&#x3D;\underset{G_1}{\operatorname*{\iint}}1&#x2F;Adxdy&#x3D;A_1&#x2F;A$</p>
<h2 id="二维正态分布（稍等）"><a href="#二维正态分布（稍等）" class="headerlink" title="二维正态分布（稍等）"></a>二维正态分布（稍等）</h2><p>设二维随机变量(X,Y)具有概率密度:</p>
<p>$$<br>f(x,y)&#x3D;\frac1{2\pi\sigma_1\sigma_2\sqrt{1-\rho^2}}e^{-\frac1{2(1-\rho^2)}[\frac{(x-\mu_1)^2}{\sigma_1^2}-2\rho\frac{(x-\mu_1)(y-\mu_2)}{\sigma_1\sigma_2}+\frac{(y-\mu_2)^2}{\sigma_2^2}]};-\infty&lt;x&lt;+\infty,-\infty&lt;y&lt;+\infty\<br>其中\mu_1,\mu_2,\sigma_1(&gt;0),\sigma_2(&gt;0),\rho(|\rho|&lt;1)均为常数，则称</p>
<p>(X,Y)\text{服从参数为}\mu_1,\sigma_1^2,\mu_2,\sigma_2^2,</p>
<p>\text{记为 }(X,Y)\thicksim N(\mu_1,\sigma_1^2;\mu_2,\sigma_2^2;\rho).</p>
<p>$$</p>
<h1 id="边缘分布"><a href="#边缘分布" class="headerlink" title="边缘分布"></a>边缘分布</h1><p><a href="%E6%96%B0%E9%A1%B5%E9%9D%A2/%E6%96%B0%E9%A1%B5%E9%9D%A2.md" title="新页面">新页面</a></p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h1 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h1>]]></content>
  </entry>
  <entry>
    <title>集合论语言描述的随机现象</title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87/%E9%9B%86%E5%90%88%E8%AE%BA%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E7%9A%84%E9%9A%8F%E6%9C%BA%E7%8E%B0%E8%B1%A1/%E9%9B%86%E5%90%88%E8%AE%BA%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E7%9A%84%E9%9A%8F%E6%9C%BA%E7%8E%B0%E8%B1%A1/</url>
    <content><![CDATA[<p>Ω样本空间: 随机试验中所有w基本事件所构成的集合</p>
<p>A事件域：Ω的可测子集</p>
<p>事件运算：</p>
<p><img src="/image/image_Ytry9AjZgp.png"></p>
<p>运算后的事件域解释</p>
<p><img src="/image/image_R8a13JsMDr.png"></p>
<p>当事件 A U B发生，必有事件 A或事件B发生</p>
<p><img src="/image/image_me8O1Pwq0q.png"></p>
<p>互斥（不相容）：A∩B &#x3D; ∅；不存在A，B同时发生的事件</p>
<p><img src="/image/image_wR70I7aYqo.png"></p>
<p>互逆&#x2F;互补：</p>
<p><img src="/image/image_Lsgyhv3dbE.png"></p>
<p>A▲B 对称差，有 A▲B &#x3D; AUB-AB &#x3D; AB’U A’B<br>当事件 A ▲ B发生,事件A,B 中恰有一个事件发生</p>
<p><img src="/image/image_IOhz7ieh6S.png"></p>
<p>集合运算满足</p>
<p><img src="/image/image_bfLusNRMAR.png"></p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>事件响应</title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/GUI%E7%BC%96%E7%A8%8B/%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94/%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94/</url>
    <content><![CDATA[<h2 id="回调函数："><a href="#回调函数：" class="headerlink" title="回调函数："></a>回调函数：</h2><p>1）其他页面下控件事件响应:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A页面控件触发</span></span><br><span class="line"><span class="type">static</span> ret_OK <span class="title function_">A_callback</span><span class="params">(<span class="type">void</span>* ctx,event* e)</span>&#123;</span><br><span class="line">    <span class="comment">//传递上下文至B页面（ex:哪个控件触发的）</span></span><br><span class="line">    <span class="comment">//访问B页面窗口（窗口管理器子控件）</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//B页面控件响应</span></span><br><span class="line"><span class="type">static</span> ret_OK <span class="title function_">B_callback</span><span class="params">(<span class="type">void</span>* ctx,event* e)</span>&#123;</span><br><span class="line">    <span class="comment">//根据上下文选择更新 B 页显示内容（若需要）</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册B_callback的响应事件为</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/AWTK/awtk%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%90%AD%E5%BB%BA/awtk%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="awtk基础设施搭建"><a href="#awtk基础设施搭建" class="headerlink" title="awtk基础设施搭建"></a>awtk基础设施搭建</h1><p>确定PC端哪个系统开发；安装依赖后→下载awtk→运行其下的依赖检测工具→编译（这里是用scons工具）</p>
<p><img src="/image/image_NvwKJiA-l5.png"></p>
<h1 id="awtk文件目录结构"><a href="#awtk文件目录结构" class="headerlink" title="awtk文件目录结构"></a>awtk文件目录结构</h1><p><img src="/image/image_G35d6BFTAZ.png"></p>
<h1 id="应用目录结构"><a href="#应用目录结构" class="headerlink" title="应用目录结构"></a>应用目录结构</h1><p><img src="/image/image__g0AVsvkTU.png"></p>
<p>建议使用 AWStudio 中内置的 AWTK Designer 工具新建项目，以上文件以及目录都会 自动生成</p>
<h2 id="源码目录"><a href="#源码目录" class="headerlink" title="源码目录"></a>源码目录</h2><p><img src="/image/image_aspn0Hp4ZJ.png"></p>
<p><img src="/image/image_uFDdau9oWy.png"></p>
<h2 id="资源目录"><a href="#资源目录" class="headerlink" title="资源目录"></a>资源目录</h2><p><img src="/image/image_uwAaqtrUGi.png"></p>
<p>应用运行时将使用 res 目录下的资源，该目录通过打包资源自动生成，如果修改了 design 目录下的资源，则需要重新打包资源让其生效</p>
<h3 id="image目录"><a href="#image目录" class="headerlink" title="image目录"></a>image目录</h3><p><img src="/image/image_lKdbcDU_qo.png"></p>
<p>AWTK 运行时会优先在 x1、x2、x3 目录中的其中一个查找图片（比如 LCD 的 DPR&#x3D;1， 则在 x1 目录），如果找不到，则在 xx 目录中查找。对于嵌入式系统，一般只需要 x1 或 xx 的图片。如果开发环境使用高清的 PC 显示器，为了方便 PC 上看效果，建议也准备一套 x2 或 x3 的图片</p>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>在 AWTK 目录下有个 awtk_config.py 文件（被 SConstruct 引用），在这个文件中可以通 过定义不同含义的宏实现不同的效果；修改 awtk_config.py 文件后，需要重新编译 awtk</p>
<h2 id="渲染模式选择"><a href="#渲染模式选择" class="headerlink" title="渲染模式选择"></a>渲染模式选择</h2><p>GL3&#x2F; GLES2&#x2F; GLES3： 基 于 OpenGL&#x2F; GLES 实 现 （nanovg 内 置） ， 由 宏 WITH_NANOVG_GL 决定。适合支持 OpenGL 硬件加速的平台<br>AGGE：基于 agge 实现。纯软件实现，渲染效果一般，由宏 WITH_NANOVG_AGGE 决定。适合没有 GPU 的嵌入式平台</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># awtkawtk_config.py ...</span><br><span class="line"> VGCANVAS=<span class="string">&#x27;NANOVG&#x27;</span> </span><br><span class="line"> <span class="keyword">if</span> OS_NAME == <span class="string">&#x27;Windows&#x27;</span>: </span><br><span class="line">     TK_ROOT=TK_ROOT.replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;\\\\&#x27;</span>); </span><br><span class="line">     NANOVG_BACKEND=<span class="string">&#x27;GLES2&#x27;</span> </span><br><span class="line"> <span class="keyword">else</span>: NANOVG_BACKEND=<span class="string">&#x27;GL3&#x27;</span></span><br><span class="line"> #VGCANVAS=<span class="string">&#x27;CAIRO&#x27;</span> </span><br><span class="line"> #NANOVG_BACKEND=<span class="string">&#x27;GLES2&#x27;</span> </span><br><span class="line"> #NANOVG_BACKEND=<span class="string">&#x27;GLES3&#x27;</span> </span><br><span class="line"> #NANOVG_BACKEND=<span class="string">&#x27;AGG&#x27;</span> </span><br><span class="line"> #NANOVG_BACKEND=<span class="string">&#x27;BGFX&#x27;</span> </span><br><span class="line"> #NANOVG_BACKEND=<span class="string">&#x27;AGGE&#x27;</span> </span><br></pre></td></tr></table></figure>

<p>当 VGCANVAS&#x3D;’NANOVG’时，对于常用的 AGGE 和 OpenGL 渲染模式又可以细分&#x20;<br>1) AGGE-BGR565：表示运行时绘图使用 AGGE 引擎，LCD Frame Buffer 的格式为 BGR565<br>2) AGGE-BGRA8888：表示运行时绘图使用 AGGE 引擎，帧数据像素格式为 BGRA8888<br>3) AGGE-MONO：表示运行时绘图使用 AGGE 引擎，LCD Frame Buffer 的格式为 MONO （黑白）</p>
<p>1）OpenGL-GLES2：表示运行时绘图使用 GLES2 引擎，建议在 Windows 平台使用<br>2）OpenGL-GL3：表示运行时绘图使用 GL3 引擎，建议非在 Windows 平台使用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># 使用 AGGE 渲染模式 </span><br><span class="line">NANOVG_BACKEND=<span class="string">&#x27;AGGE&#x27;</span> </span><br><span class="line"># 基于 Frame Buffer 实现彩色 LCD（BGR565或BGRA8888格式使用该参数） </span><br><span class="line">LCD=<span class="string">&#x27;SDL_FB&#x27;</span></span><br><span class="line"># 基于 Frame Buffer 实现黑白 LCD（MOMO格式使用该参数） </span><br><span class="line"># LCD=<span class="string">&#x27;SDL_FB_MONO&#x27;</span></span><br><span class="line"> </span><br><span class="line"># FRAME_BUFFER_FORMAT=<span class="string">&#x27;bgr565&#x27;</span> </span><br><span class="line"># 帧缓冲颜色格式为 BGR565 </span><br><span class="line"># FRAME_BUFFER_FORMAT=<span class="string">&#x27;bgra8888&#x27;</span> </span><br><span class="line"># 帧缓冲颜色格式为 BGRA888</span><br><span class="line">------------------------------------------</span><br><span class="line">NANOVG_BACKEND=<span class="string">&#x27;GLES2&#x27;</span> </span><br><span class="line"># 使用 OpenGL-GLES2 渲染模式 </span><br><span class="line"># NANOVG_BACKEND=<span class="string">&#x27;GL3&#x27;</span> </span><br><span class="line"># 使用 OpenGL-GL3 渲染模式</span><br><span class="line"></span><br><span class="line">LCD=<span class="string">&#x27;SDL_GPU&#x27;</span> </span><br><span class="line"># 基于 GPU 实现 LCD</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="是否支持png-jpeg图片"><a href="#是否支持png-jpeg图片" class="headerlink" title="是否支持png&#x2F;jpeg图片"></a>是否支持png&#x2F;jpeg图片</h2><h2 id="是否使用点阵字体"><a href="#是否使用点阵字体" class="headerlink" title="是否使用点阵字体"></a>是否使用点阵字体</h2><h2 id="是否启用软键盘"><a href="#是否启用软键盘" class="headerlink" title="是否启用软键盘"></a>是否启用软键盘</h2><h2 id="是否启用中文输入法"><a href="#是否启用中文输入法" class="headerlink" title="是否启用中文输入法"></a>是否启用中文输入法</h2><h2 id="是否启用联想功能"><a href="#是否启用联想功能" class="headerlink" title="是否启用联想功能"></a>是否启用联想功能</h2><h2 id="是否有标准内存分配函数"><a href="#是否有标准内存分配函数" class="headerlink" title="是否有标准内存分配函数"></a>是否有标准内存分配函数</h2><h2 id="是否支持文件系统"><a href="#是否支持文件系统" class="headerlink" title="是否支持文件系统"></a>是否支持文件系统</h2><h2 id="是否在嵌入式系统运行"><a href="#是否在嵌入式系统运行" class="headerlink" title="是否在嵌入式系统运行"></a>是否在嵌入式系统运行</h2><p>以上略，参考官方开发手册</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/GUI%E7%BC%96%E7%A8%8B/%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1-%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1-%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="交互设计-界面设计"><a href="#交互设计-界面设计" class="headerlink" title="交互设计&#x2F;界面设计"></a>交互设计&#x2F;界面设计</h1>]]></content>
  </entry>
  <entry>
    <title>界面描述</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/AWTK/%E7%95%8C%E9%9D%A2%E6%8F%8F%E8%BF%B0/%E7%95%8C%E9%9D%A2%E6%8F%8F%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><p><img src="/image/image_abCHHaqk4d.png"></p>
<p>浅色为可复用部分；开发完成后编译打包下载<br>定制控件：手写XML<br>一般情况：AWTK Designer</p>
<h1 id="入口main"><a href="#入口main" class="headerlink" title="入口main"></a>入口main</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;awtk.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">BEGIN_C_DECLS </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> AWTK_WEB </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;assets.inc&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/*AWTK_WEB*/</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../res/assets.inc&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*AWTK_WEB*/</span> </span></span><br><span class="line">END_C_DECLS</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">ret_t</span> <span class="title function_">application_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">ret_t</span> <span class="title function_">application_exit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;awtk_main.inc&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>1）接口兼容<br>BEGIN_C_DECLS和END_C_DECLS宏:C++因为有函数重载特性导致在C&#x2F;C++混合编程时接口不兼容；需要告诉C++编译器使用C调用标准；extern “C”{}编译器会将包含在{}中代码按C调用约定进行处理，以便与其他使用C语言编写的代码进行兼容。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* C++ needs to know that types and declarations are C, not C++.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  __cplusplus</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __BEGIN_DECLS  extern <span class="string">&quot;C&quot;</span> &#123;</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __END_DECLS  &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __BEGIN_DECLS</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __END_DECLS</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个语法糖，如果是在c++中，则__BEGIN_DECLS和__END_DECLS表示 extern &quot;C&quot; &#123;&#125;，在C中，则表示无意义</span></span><br></pre></td></tr></table></figure>

<p>2）资源载入<br>#ifdef和#else指令判断是否为AWTK_WEB环境，如果是，则使用#include “assets.inc”引入资源文件；如果不是，则使用#include “..&#x2F;res&#x2F;assets.inc”引入资源文件<br>3）声明外部的应用初始化和退出函数<br>extern关键字声明了两个函数：application_init和application_exit（应用初始化和退出析构函数）</p>
<h1 id="应用初始化"><a href="#应用初始化" class="headerlink" title="应用初始化"></a>应用初始化</h1><p>&#x20;application_init 和 application_exit，这两 个函数分别在进入 awtk 事件循环的前后执行，它们在 application.c 中实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...... </span><br><span class="line"><span class="comment">/* 当程序初始化完成时调用，全局只触发一次。有初始化需求可以自己在此处添加 */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">ret_t</span> <span class="title function_">application_on_launch</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> RET_OK; </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="comment">/* 当程序退出时调用，全局只触发一次。如有初始化的数据需要释放，在此函数内释放 */</span> </span><br><span class="line"><span class="type">static</span> <span class="type">ret_t</span> <span class="title function_">application_on_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> RET_OK; </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="comment">/* 初始化程序 */</span> </span><br><span class="line"> <span class="type">ret_t</span> <span class="title function_">application_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">   custom_widgets_register(); </span><br><span class="line">   application_on_launch();</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(APP_SYSTEM_BAR) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="comment">/* 如果存在指定的系统栏，则打开指定的顶部系统栏 */</span> </span><br><span class="line">   navigator_to(APP_SYSTEM_BAR); </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(APP_BOTTOM_SYSTEM_BAR) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="comment">/* 如果存在指定的系统栏，则打开指定的底部系统栏 */</span> </span><br><span class="line">   navigator_to(APP_BOTTOM_SYSTEM_BAR); </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="comment">/* 打开设定的主界面窗口 */</span> </span><br><span class="line">   <span class="keyword">return</span> navigator_to(APP_START_PAGE); </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"> <span class="comment">/* 退出程序 */</span> </span><br><span class="line"><span class="type">ret_t</span> <span class="title function_">application_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">   application_on_exit();</span><br><span class="line">   log_debug(<span class="string">&quot;application_exit\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> RET_OK; </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="窗口初始化"><a href="#窗口初始化" class="headerlink" title="窗口初始化"></a>窗口初始化</h1><p>在 AWTK 中，通常会为每个窗口配置一个 c 文件，例如 home_page.c，并在该文件中进 行窗口初始化，用户可以按需在初始化函数中添加内容，对该窗口的操作也在这个文件中实 现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ret_t</span> <span class="title function_">home_page_init</span><span class="params">(<span class="type">widget_t</span>* win, <span class="type">void</span>* ctx)</span> &#123;</span><br><span class="line">    (<span class="type">void</span>)ctx; </span><br><span class="line">    return_value_if_fail(win != <span class="literal">NULL</span>, RET_BAD_PARAMS);</span><br><span class="line">     <span class="comment">/* 遍历 win 窗口的子控件，visit_init_child 是遍历时的回调函数 */</span> </span><br><span class="line">     widget_foreach(win, visit_init_child, win);</span><br><span class="line">     <span class="keyword">return</span> RET_OK; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>打开并初始化窗口</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ret_t</span> <span class="title function_">application_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"> <span class="comment">/* 调用 AWTK 原生 API 打开 home_page 窗口 */</span> </span><br><span class="line">    <span class="type">widget_t</span>* win = window_open(<span class="string">&quot;home_page&quot;</span>);</span><br><span class="line">     <span class="comment">/* 初始化 home_page 窗口 */</span> </span><br><span class="line">    home_page_init(win, <span class="literal">NULL</span>); </span><br><span class="line">    <span class="keyword">return</span> RET_OK;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/GUI%E7%BC%96%E7%A8%8B/%E5%9B%BD%E9%99%85%E5%8C%96/%E5%9B%BD%E9%99%85%E5%8C%96/</url>
    <content><![CDATA[<h1 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h1>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/GUI%E7%BC%96%E7%A8%8B/%E6%8E%A7%E4%BB%B6%E5%8A%A8%E7%94%BB/%E6%8E%A7%E4%BB%B6%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<h1 id="控件动画"><a href="#控件动画" class="headerlink" title="控件动画"></a>控件动画</h1>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/GUI%E7%BC%96%E7%A8%8B/%E6%96%B0%E9%A1%B5%E9%9D%A2/%E6%96%B0%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="新页面"><a href="#新页面" class="headerlink" title="新页面"></a>新页面</h1>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/GUI%E7%BC%96%E7%A8%8B/%E7%8E%AF%E5%BD%A2%E6%8E%A7%E4%BB%B6%E6%89%8B%E5%8A%BF%E6%BB%91%E5%8A%A8%E4%BA%A4%E4%BA%92/%E7%8E%AF%E5%BD%A2%E6%8E%A7%E4%BB%B6%E6%89%8B%E5%8A%BF%E6%BB%91%E5%8A%A8%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<h1 id="环形控件手势滑动交互"><a href="#环形控件手势滑动交互" class="headerlink" title="环形控件手势滑动交互"></a>环形控件手势滑动交互</h1>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93&amp;%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/sqlite/sqlite/</url>
    <content><![CDATA[<h1 id="sqlite"><a href="#sqlite" class="headerlink" title="sqlite"></a>sqlite</h1><p><a href="https://zhiguoxin.blog.csdn.net/article/details/127224878?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-127224878-blog-52566005.235%5Ev36%5Epc_relevant_default_base&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-127224878-blog-52566005.235%5Ev36%5Epc_relevant_default_base&utm_relevant_index=4" title=" Linux下轻量级数据库-SQLite3（嵌入式设备）_linux 小型数据库_果果小师弟的博客-CSDN博客 在嵌入式linux下使用数据库sqlite3的一些简单操作 https://zhiguoxin.blog.csdn.net/article/details/127224878?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-127224878-blog-52566005.235^v36^pc_relevant_default_base&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-127224878-blog-52566005.235^v36^pc_relevant_default_base&amp;utm_relevant_index=4"> Linux下轻量级数据库-SQLite3（嵌入式设备）_linux 小型数据库_果果小师弟的博客-CSDN博客 在嵌入式linux下使用数据库sqlite3的一些简单操作 https://zhiguoxin.blog.csdn.net/article/details/127224878?spm=1001.2101.3001.6650.3&amp;utm_medium&#x3D;distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-127224878-blog-52566005.235^v36^pc_relevant_default_base&amp;depth_1-utm_source&#x3D;distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-127224878-blog-52566005.235^v36^pc_relevant_default_base&amp;utm_relevant_index&#x3D;4</a></p>
]]></content>
  </entry>
  <entry>
    <title>DP最优化问题</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/DP%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/DP%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><strong>原问题的最优解是从子问题的最优解构建得来</strong>（<strong>由最优子结构递推出全局最优解</strong>）</p>
<p><img src="/image/image_0es9OO7gl5.png"></p>
<p>阶数高时；到i阶最小代价$f(i)&#x3D;min[f(i-1),f(i-2)]+cost(x);x\in{1,2}$等于到前两阶的最小代价其中小的那一个+跳一次的成本；<strong>最优子结构</strong>构成的递推式导出全局最优解；本质上还是dp问题<br>dp策略：<br>1）当前状态由前2个状态决定；声明两个变量存储状态<br>2）变量存进初状态<br>3）根据状态转移方程，迭代地进行递推</p>
<p><img src="/image/image_eDlj7mUi7j.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 爬楼梯最小代价：动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairsDP</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;cost)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = cost.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> cost[n];</span><br><span class="line">    <span class="comment">// 初始化 dp 表，用于存储子问题的解</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 初始状态：预设最小子问题的解</span></span><br><span class="line">    dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">2</span>] = cost[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 状态转移：从较小子问题逐步求解较大子问题</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>]) + cost[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 爬楼梯最小代价：空间优化后的动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairsDPComp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;cost)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = cost.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> cost[n];</span><br><span class="line">    <span class="type">int</span> a = cost[<span class="number">1</span>], b = cost[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = b;</span><br><span class="line">        b = <span class="built_in">min</span>(a, tmp) + cost[i];</span><br><span class="line">        a = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>与<a href="../%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2-%E8%AE%B0%E5%BF%86%E6%90%9C%E7%B4%A2%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2-%E8%AE%B0%E5%BF%86%E6%90%9C%E7%B4%A2%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98.md" title="暴力搜索/记忆搜索最优化问题">暴力搜索&#x2F;记忆搜索最优化问题</a>相同问题的dp策略解法：<br>求$[0,0]→[i,j]$的最小路径和<br>1）状态转移方程：<br>$f(i,j)&#x3D;min{f(i-1,j),f(i,j-1)}+grid(i,j);i,j&gt;0$$f(0,j)&#x3D;f(0,j-1)+grid(0,j)$$f(i,0)&#x3D;f(i-1,0)+grid(i,0)$<br>2初始状态：f(0,0)&#x3D;1</p>
<p><img src="/image/image_ixQIyrTz99.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 最小路径和：动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minPathSumDP</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = grid.<span class="built_in">size</span>(), m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 状态转移：首行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 状态转移：首列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 状态转移：其余行列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>空间优化：哪些要预存储，哪些可以用到再算O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 最小路径和：空间优化后的动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minPathSumDPComp</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = grid.<span class="built_in">size</span>(), m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="comment">// 状态转移：首行</span></span><br><span class="line">    dp[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">        dp[j] = dp[j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 状态转移：其余行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 状态转移：首列</span></span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 状态转移：其余列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">min</span>(dp[j - <span class="number">1</span>], dp[j]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>dp问题</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/dp%E9%97%AE%E9%A2%98/dp%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><a href="../%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20dynamic%20programming/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20dynamic%20programming.md" title="动态规划 dynamic programming">动态规划 dynamic programming</a>常规dp问题参考</p>
<p>带约束dp问题</p>
<p><img src="/image/image_kWGH-jvESy.png"></p>
<p><img src="/image/image_mC-XJL5Geq.png"></p>
<p><img src="/image/image_sxGmjf9o_z.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 带约束爬楼梯：动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">climbingStairsConstraintDP</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化 dp 表，用于存储子问题的解</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 初始状态：预设最小子问题的解</span></span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 状态转移：从较小子问题逐步求解较大子问题</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        dp[i][<span class="number">2</span>] = dp[i - <span class="number">2</span>][<span class="number">1</span>] + dp[i - <span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">1</span>] + dp[n][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/image/image_Y0zcmhvvEu.png"></p>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>0-1决策树问题</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/0-1%E5%86%B3%E7%AD%96%E6%A0%91%E9%97%AE%E9%A2%98/0-1%E5%86%B3%E7%AD%96%E6%A0%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><img src="/image/image_WT4ZBmASeA.png"></p>
<p>有n个选项；每个选项只能选择一次；那么可以进行n轮0-1决策；求前n轮决策最优解<br><strong>第i轮决策后最大价值</strong>状态转移方程：<br>$f(i,c)&#x3D;f(i-1,c-wgt(i-1))+val(i-1)$;i-1轮决策选择了1<br>$f(i,c)&#x3D;f(i-1,c)$;i-1轮决策选择了0<br>$&#x3D;&gt;f(i,c)&#x3D;max(f(i-1,c),f(i-1,c-wgt(i-1))+val(i-1))$&#x2F;&#x2F;代码按这个来写<br>边界条件：</p>
<ol>
<li>$f(0,c)&#x3D;0||f(i,0)&#x3D;0$最小子结构</li>
<li>c≥0&amp;&amp;c-wgt(i-1)≥0重量约束</li>
</ol>
<h1 id="暴力搜索"><a href="#暴力搜索" class="headerlink" title="暴力搜索"></a>暴力搜索</h1><p>怎么看都像是一种分治（又像枚举）：<strong>第i轮决策后最大价值</strong>&#x3D;i-1轮决策后最大价值+第i轮决策增加的价值</p>
<p><img src="/image/image__xDeSUU6X6.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 0-1 背包：暴力搜索 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsackDFS</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;wgt, vector&lt;<span class="type">int</span>&gt; &amp;val, <span class="type">int</span> i, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若已选完所有物品或背包无容量，则返回价值 0</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> || c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若超过背包容量，则只能不放入背包</span></span><br><span class="line">    <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">knapsackDFS</span>(wgt, val, i - <span class="number">1</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算不放入和放入物品 i 的最大价值</span></span><br><span class="line">    <span class="type">int</span> no = <span class="built_in">knapsackDFS</span>(wgt, val, i - <span class="number">1</span>, c);</span><br><span class="line">    <span class="type">int</span> yes = <span class="built_in">knapsackDFS</span>(wgt, val, i - <span class="number">1</span>, c - wgt[i - <span class="number">1</span>]) + val[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 返回两种方案中价值更大的那一个</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(no, yes);</span><br><span class="line">&#125;<span class="comment">//O(2^n)???????</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h1><p>二维数组mem存储结果，O(n*cap)取决于二维数组排列数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 0-1 背包：记忆化搜索 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsackDFSMem</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;wgt, vector&lt;<span class="type">int</span>&gt; &amp;val, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;mem, <span class="type">int</span> i, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若已选完所有物品或背包无容量，则返回价值 0</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> || c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若已有记录，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (mem[i][c] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mem[i][c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若超过背包容量，则只能不放入背包</span></span><br><span class="line">    <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">knapsackDFSMem</span>(wgt, val, mem, i - <span class="number">1</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算不放入和放入物品 i 的最大价值</span></span><br><span class="line">    <span class="type">int</span> no = <span class="built_in">knapsackDFSMem</span>(wgt, val, mem, i - <span class="number">1</span>, c);</span><br><span class="line">    <span class="type">int</span> yes = <span class="built_in">knapsackDFSMem</span>(wgt, val, mem, i - <span class="number">1</span>, c - wgt[i - <span class="number">1</span>]) + val[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 记录并返回两种方案中价值更大的那一个</span></span><br><span class="line">    mem[i][c] = <span class="built_in">max</span>(no, yes);</span><br><span class="line">    <span class="keyword">return</span> mem[i][c];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h1><p>可以发现，决策树的dp策略就是从最底下的f(0,0)递推到f(3,c)；按状态表顺序递推</p>
<p><img src="/image/image_PehDFV8HkR.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 0-1 背包：动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsackDP</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;wgt, vector&lt;<span class="type">int</span>&gt; &amp;val, <span class="type">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = wgt.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(cap + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">//行迭代</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">1</span>; c &lt;= cap; c++) &#123;<span class="comment">//列迭代</span></span><br><span class="line">            <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) &#123;</span><br><span class="line">                <span class="comment">// 若超过背包容量，则不选物品 i</span></span><br><span class="line">                dp[i][c] = dp[i - <span class="number">1</span>][c];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不选和选物品 i 这两种方案的较大值</span></span><br><span class="line">                dp[i][c] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][c], dp[i - <span class="number">1</span>][c - wgt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][cap];</span><br><span class="line">&#125;<span class="comment">//O(n*cap)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>由于每行状态的计算只与其上一行的状态有关，因此我们可以使用两个数组滚动前进，将空间复杂度从 O(n^2) 将低至 O(n) 。</p>
<p>进一步思考，我们是否可以仅用一个数组实现空间优化呢？观察可知，每个状态都是由正上方或左上方的格子转移过来的。假设只有一个数组，当开始遍历第 i 行时，该数组存储的仍然是第 i−1 行的状态。</p>
<ul>
<li>如果采取正序遍历，那么遍历到 dp[i,j] 时，左上方 dp[i-1,j]~ dp[i-1,j-1]值可能已经被覆盖，此时就无法得到正确的状态转移结果。</li>
<li>如果采取倒序遍历，则不会发生覆盖问题，状态转移可以正确进行。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 0-1 背包：空间优化后的动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsackDPComp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;wgt, vector&lt;<span class="type">int</span>&gt; &amp;val, <span class="type">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = wgt.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(cap + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 倒序遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c = cap; c &gt;= <span class="number">1</span>; c--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &lt;= c) &#123;</span><br><span class="line">                <span class="comment">// 不选和选物品 i 这两种方案的较大值</span></span><br><span class="line">                dp[c] = <span class="built_in">max</span>(dp[c], dp[c - wgt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[cap];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>n皇后（排课问题）</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/n%E7%9A%87%E5%90%8E%EF%BC%88%E6%8E%92%E8%AF%BE%E9%97%AE%E9%A2%98%EF%BC%89/n%E7%9A%87%E5%90%8E%EF%BC%88%E6%8E%92%E8%AF%BE%E9%97%AE%E9%A2%98%EF%BC%89/</url>
    <content><![CDATA[<p>n维向量空间+一些约束条件构成的解空间生成问题</p>
<p><img src="/image/image_OqEuExVZUa.png"></p>
<p>回溯策略：回溯枚举n*n矩阵解空间，并判断是否满足约束(具体是按行枚举，因为每行只能放一个，最多能放n行，每行n种放法，这样只用判断是否满足列，斜约束)；到这里O(n^2)；爆炸；所以要抽象出约束函数剪枝</p>
<p><img src="/image/image_PPHngzSPSB.png"></p>
<p><img src="/image/image_A7moa_O8px.png"></p>
<p>1）遍历所有列可能，先放第一行；再递归地放下一行<br>2）每放进一个数生成3个约束函数；其子树矩阵没加一个数判断一次</p>
<p><img src="/image/image_SJlx46KdF1.png"></p>
<p><img src="/image/image_NVxkbKy2Dh.png"></p>
<p>通过放缩因子判断</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 回溯算法：N 皇后 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> n, vector&lt;vector&lt;string&gt;&gt; &amp;state, vector&lt;vector&lt;vector&lt;string&gt;&gt;&gt; &amp;res, vector&lt;<span class="type">bool</span>&gt; &amp;cols,</span></span></span><br><span class="line"><span class="params"><span class="function">               vector&lt;<span class="type">bool</span>&gt; &amp;diags1, vector&lt;<span class="type">bool</span>&gt; &amp;diags2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当放置完所有行时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(state);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有列可能</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="comment">// 计算该格子对应的主对角线和副对角线</span></span><br><span class="line">        <span class="type">int</span> diag1 = row - col + n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> diag2 = row + col;</span><br><span class="line">        <span class="comment">// 剪枝：不允许该格子所在列、主对角线、副对角线存在皇后</span></span><br><span class="line">        <span class="keyword">if</span> (!cols[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2]) &#123;</span><br><span class="line">            <span class="comment">// 尝试：将皇后放置在该格子</span></span><br><span class="line">            state[row][col] = <span class="string">&quot;Q&quot;</span>;</span><br><span class="line">            cols[col] = diags1[diag1] = diags2[diag2] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 放置下一行</span></span><br><span class="line">            <span class="built_in">backtrack</span>(row + <span class="number">1</span>, n, state, res, cols, diags1, diags2);</span><br><span class="line">            <span class="comment">// 回退：将该格子恢复为空位</span></span><br><span class="line">            state[row][col] = <span class="string">&quot;#&quot;</span>;</span><br><span class="line">            cols[col] = diags1[diag1] = diags2[diag2] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求解 N 皇后 */</span></span><br><span class="line">vector&lt;vector&lt;vector&lt;string&gt;&gt;&gt; <span class="built_in">nQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// 初始化 n*n 大小的棋盘，其中 &#x27;Q&#x27; 代表皇后，&#x27;#&#x27; 代表空位</span></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">state</span>(n, <span class="built_in">vector</span>&lt;string&gt;(n, <span class="string">&quot;#&quot;</span>));</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">cols</span><span class="params">(n, <span class="literal">false</span>)</span></span>;           <span class="comment">// 记录列是否有皇后</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">diags1</span><span class="params">(<span class="number">2</span> * n - <span class="number">1</span>, <span class="literal">false</span>)</span></span>; <span class="comment">// 记录主对角线是否有皇后</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">diags2</span><span class="params">(<span class="number">2</span> * n - <span class="number">1</span>, <span class="literal">false</span>)</span></span>; <span class="comment">// 记录副对角线是否有皇后</span></span><br><span class="line">    vector&lt;vector&lt;vector&lt;string&gt;&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">backtrack</span>(<span class="number">0</span>, n, state, res, cols, diags1, diags2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/image/image_GuWMsZYRcm.png"></p>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>每个「父节点 parent node」都有两个引用（指针），分别指向「左子节点 left-child node」和「右子节点 right-child node」，节点的左子节点及其以下节点形成的树称为该节点的「左子树 left subtree」，同理可得「右子树 right subtree」。</p>
<p><strong>在二叉树中，除叶节点外，其他所有节点都包含子节点和非空子树</strong>。</p>
<p><img src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/binary_tree_definition.png"></p>
<h3 id="常见术语"><a href="#常见术语" class="headerlink" title="常见术语"></a>常见术语</h3><ul>
<li>「根节点 root node」：位于二叉树顶层的节点，没有父节点。</li>
<li>「叶节点 leaf node」：没有子节点的节点，其两个指针均指向 None 。</li>
<li>「边 edge」：连接两个节点的线段，即节点引用（指针）。</li>
<li>节点所在的「层 level」：从顶至底递增，根节点所在层为 1 。</li>
<li>节点的「度 degree」：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。</li>
<li>二叉树的「高度 height」：从根节点到最远叶节点所经过的边的数量。</li>
<li>节点的「深度 depth」：从根节点到该节点所经过的边的数量。</li>
<li>节点的「高度 height」：从最远叶节点到该节点所经过的边的数量。</li>
</ul>
<p><img src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/binary_tree_terminology.png"></p>
<h3 id="链表实现下二叉树基本操作"><a href="#链表实现下二叉树基本操作" class="headerlink" title="链表实现下二叉树基本操作"></a>链表实现下二叉树基本操作</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 二叉树节点结构体 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;          <span class="comment">// 节点值</span></span><br><span class="line">    TreeNode *left;   <span class="comment">// 左子节点指针</span></span><br><span class="line">    TreeNode *right;  <span class="comment">// 右子节点指针</span></span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;<span class="comment">//链表实现的二叉树节点</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-初始化二叉树"><a href="#1-初始化二叉树" class="headerlink" title="1.   初始化二叉树"></a>1.   初始化二叉树</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化二叉树 */</span></span><br><span class="line"><span class="comment">// 初始化节点</span></span><br><span class="line">TreeNode* n1 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">TreeNode* n2 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">TreeNode* n3 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">TreeNode* n4 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">TreeNode* n5 = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 构建引用指向（即指针）</span></span><br><span class="line">n1-&gt;left = n2;</span><br><span class="line">n1-&gt;right = n3;</span><br><span class="line">n2-&gt;left = n4;</span><br><span class="line">n2-&gt;right = n5;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-插入与删除节点"><a href="#2-插入与删除节点" class="headerlink" title="2.   插入与删除节点"></a>2.   插入与删除节点</h4><p><img src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/binary_tree_add_remove.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 插入与删除节点 */</span></span><br><span class="line">TreeNode* P = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 在 n1 -&gt; n2 中间插入节点 P</span></span><br><span class="line">n1-&gt;left = P;</span><br><span class="line">P-&gt;left = n2;</span><br><span class="line"><span class="comment">// 删除节点 P</span></span><br><span class="line">n1-&gt;left = n2;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>插入节点可能会改变二叉树的原有逻辑结构，而删除节点通常意味着删除该节点及其所有子树。因此，在二叉树中，插入与删除操作通常是由一套操作配合完成的，以实现有实际意义的操作。</p>
<h3 id="常见二叉树类型"><a href="#常见二叉树类型" class="headerlink" title="常见二叉树类型"></a>常见二叉树类型</h3><h4 id="1-完美二叉树-perfect-binary-tree"><a href="#1-完美二叉树-perfect-binary-tree" class="headerlink" title="1.   完美二叉树 perfect binary tree"></a>1.   完美二叉树 perfect binary tree</h4><p>完美二叉树中，叶节点的度为 0 ，其余所有节点的度都为 2 ；若树高度为 ℎ ，节点总数为 $ 2^{ℎ+1} −1  $，呈现指数级关系，反映自然界常见的细胞分裂现象</p>
<p><img src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/perfect_binary_tree.png"></p>
<h4 id="2-完全二叉树-complete-binary-tree"><a href="#2-完全二叉树-complete-binary-tree" class="headerlink" title="2.   完全二叉树 complete binary tree"></a>2.   完全二叉树 complete binary tree</h4><p>只有底层节点未填满，且靠左填充</p>
<p><img src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/complete_binary_tree.png"></p>
<h4 id="3-完满二叉树full-binary-tree"><a href="#3-完满二叉树full-binary-tree" class="headerlink" title="3.   完满二叉树full binary tree"></a>3.   完满二叉树full binary tree</h4><p>除了叶节点之外，其余所有节点都有两个子节点。</p>
<p><img src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/full_binary_tree.png"></p>
<h4 id="4-平衡二叉树balanced-binary-tree"><a href="#4-平衡二叉树balanced-binary-tree" class="headerlink" title="4.   平衡二叉树balanced binary tree"></a>4.   平衡二叉树balanced binary tree</h4><p>任意节点的左子树和右子树的高度之差的绝对值不超过 1 。</p>
<p><img src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/balanced_binary_tree.png"></p>
<h3 id="x20-二叉树退化"><a href="#x20-二叉树退化" class="headerlink" title="&#x20;二叉树退化"></a>&#x20;二叉树退化</h3><p>二叉树的每层节点都被填满时，达到“完美二叉树”；而当所有节点都偏向一侧时，二叉树退化为“链表”;即二叉树的最佳与最差结构</p>
<ul>
<li>完美二叉树是理想情况，可以充分发挥二叉树“分治”的优势。</li>
<li>链表则是另一个极端，各项操作都变为线性操作，时间复杂度退化至 O(n) 。</li>
</ul>
<p><img src="https://www.hello-algo.com/chapter_tree/binary_tree.assets/binary_tree_best_worst_cases.png"></p>
<p>在最佳和最差结构下，二叉树的叶节点数量、节点总数、高度等达到极大或极小值。</p>
<p><img src="/image/image_QFfvRnUeAg.png"></p>
<h3 id="x20-二叉树遍历"><a href="#x20-二叉树遍历" class="headerlink" title="&#x20;二叉树遍历??????"></a>&#x20;二叉树遍历??????</h3><h4 id="层序遍历level-order-traversal「广度优先遍历-breadth-first-traversal」"><a href="#层序遍历level-order-traversal「广度优先遍历-breadth-first-traversal」" class="headerlink" title="层序遍历level-order traversal「广度优先遍历 breadth-first traversal」"></a>层序遍历level-order traversal「广度优先遍历 breadth-first traversal」</h4><p>从顶层到底层，每层从左到右访问节点遍历二叉树</p>
<p><img src="https://www.hello-algo.com/chapter_tree/binary_tree_traversal.assets/binary_tree_bfs.png"></p>
<p>广度优先遍历通常借助“队列”来实现。队列遵循“先进先出”的规则，而广度优先遍历则遵循“逐层推进”的规则，两者背后的思想是一致的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 层序遍历 */</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化队列，加入根节点</span></span><br><span class="line">    queue&lt;TreeNode *&gt; queue;</span><br><span class="line">    queue.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="comment">// 初始化一个列表，用于保存遍历序列</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="comment">//逐层推进的思路</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) &#123;<span class="comment">//不是空树</span></span><br><span class="line">        TreeNode *node = queue.<span class="built_in">front</span>();</span><br><span class="line">        queue.<span class="built_in">pop</span>();              <span class="comment">// 队列出队</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">// 保存节点值</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>)<span class="comment">//下层入队</span></span><br><span class="line">            queue.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 左子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">            queue.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 右子节点入队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>**时间复杂度 **O(n)：所有节点被访问一次，使用O(n) 时间，其中 n 为节点数量。</li>
<li>**空间复杂度 **O(n)：在最差情况下，即满二叉树时，遍历到最底层之前，队列中最多同时存在 (n+1)&#x2F;2 个节点，占用O(n) 空间。</li>
</ul>
<h4 id="前序、中序、后序遍历「深度优先遍历-depth-first-traversal」"><a href="#前序、中序、后序遍历「深度优先遍历-depth-first-traversal」" class="headerlink" title="???前序、中序、后序遍历「深度优先遍历 depth-first traversal」"></a>???前序、中序、后序遍历「深度优先遍历 depth-first traversal」</h4><p>前序：中左右<br>中序：左中右顺序<br>后序：左右中</p>
<p><img src="https://www.hello-algo.com/chapter_tree/binary_tree_traversal.assets/binary_tree_dfs.png"></p>
<p>深度优先搜索通常基于递归实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 前序遍历 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">preOrder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">preOrder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 中序遍历 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：左子树 -&gt; 根节点 -&gt; 右子树</span></span><br><span class="line">    <span class="built_in">inOrder</span>(root-&gt;left);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">inOrder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 后序遍历 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postOrder</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：左子树 -&gt; 右子树 -&gt; 根节点</span></span><br><span class="line">    <span class="built_in">postOrder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">postOrder</span>(root-&gt;right);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>深度优先搜索也可以基于迭代实现，有兴趣的同学可以自行研究。</p>
<p>以下是前序遍历二叉树的递归过程，其可分为“递”和“归”两个逆向的部分。</p>
<ol>
<li>“递”表示开启新方法，程序在此过程中访问下一个节点。</li>
<li>“归”表示函数返回，代表当前节点已经访问完毕。</li>
</ol>
<p><img src="/image/image_smmUSu-iBY.png"></p>
<ul>
<li>**时间复杂度 O(n)**：所有节点被访问一次，使用 <strong>O(n)</strong> 时间。</li>
<li>**空间复杂度 O(n)**：在最差情况下，即树退化为链表时，递归深度达到 n，系统占用 <strong>O(n)</strong> 栈帧空间。</li>
</ul>
<h3 id="二叉树数组实现"><a href="#二叉树数组实现" class="headerlink" title="二叉树数组实现"></a>二叉树数组实现</h3><h4 id="x20-表示完美二叉树"><a href="#x20-表示完美二叉树" class="headerlink" title="&#x20;表示完美二叉树"></a>&#x20;表示完美二叉树</h4><p>将所有节点按照层序遍历的顺序存储在一个数组中，则每个节点都对应唯一数组索引。</p>
<p>根据层序遍历的特性，我们可以推导出父节点索引与子节点索引之间的“映射公式”：<strong>若节点的索引为 i ，则该节点的左子节点索引为 2i+1 ，右子节点索引为 2i+2</strong> 。next展示了各个节点索引之间的映射关系。</p>
<p><img src="https://www.hello-algo.com/chapter_tree/array_representation_of_tree.assets/array_representation_binary_tree.png"></p>
<p><strong>映射公式的角色相当于链表中的指针</strong>。给定数组中的任意一个节点，我们都可以通过映射公式来访问它的左（右）子节点。</p>
<h4 id="表示任意二叉树"><a href="#表示任意二叉树" class="headerlink" title="表示任意二叉树"></a>表示任意二叉树</h4><p>完美二叉树是一个特例，在二叉树的中间层通常存在许多 None 。由于层序遍历序列并不包含这些 None ，因此我们无法仅凭该序列来推测 None 的数量和分布位置。<strong>这意味着存在多种二叉树结构都符合该层序遍历序列</strong>。</p>
<p>next所示，给定一个非完美二叉树，上述的数组表示方法已经失效。</p>
<p><img src="https://www.hello-algo.com/chapter_tree/array_representation_of_tree.assets/array_representation_without_empty.png"></p>
<p><strong>在层序遍历序列中显式地写出所有 None</strong>处理后，层序遍历序列就可以唯一表示二叉树了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 二叉树的数组表示 */</span></span><br><span class="line"><span class="comment">// 使用 int 最大值 INT_MAX 标记空位</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; tree = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, INT_MAX, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, INT_MAX, INT_MAX, <span class="number">12</span>, INT_MAX, INT_MAX, <span class="number">15</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://www.hello-algo.com/chapter_tree/array_representation_of_tree.assets/array_representation_with_empty.png"></p>
<p>值得说明的是，<strong>完全二叉树非常适合使用数组来表示</strong>。回顾完全二叉树的定义，None 只出现在最底层且靠右的位置，<strong>因此所有 None 一定出现在层序遍历序列的末尾</strong>。</p>
<p>这意味着使用数组表示完全二叉树时，可以省略存储所有 None ，非常方便。</p>
<p><img src="https://www.hello-algo.com/chapter_tree/array_representation_of_tree.assets/array_representation_complete_binary_tree.png"></p>
<p>以下代码实现了一个基于数组表示的二叉树，包括以下几种操作。</p>
<ul>
<li>给定某节点，获取它的值、左（右）子节点、父节点。</li>
<li>获取前序遍历、中序遍历、后序遍历、层序遍历序列。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 数组表示下的二叉树类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayBinaryTree</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 深度优先遍历 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, string order, vector&lt;<span class="type">int</span>&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若为空位，则返回</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">val</span>(i) == INT_MAX)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (order == <span class="string">&quot;pre&quot;</span>)</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in">val</span>(i));</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="built_in">left</span>(i), order, res);</span><br><span class="line">        <span class="comment">// 中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (order == <span class="string">&quot;in&quot;</span>)</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in">val</span>(i));</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="built_in">right</span>(i), order, res);</span><br><span class="line">        <span class="comment">// 后序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (order == <span class="string">&quot;post&quot;</span>)</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in">val</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="built_in">ArrayBinaryTree</span>(vector&lt;<span class="type">int</span>&gt; arr) &#123;</span><br><span class="line">        tree = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 节点数量 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tree.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取索引为 i 节点的值 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">val</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若索引越界，则返回 INT_MAX ，代表空位</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= <span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">return</span> tree[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取索引为 i 节点的左子节点的索引 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">left</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取索引为 i 节点的右子节点的索引 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">right</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取索引为 i 节点的父节点的索引 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">parent</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 层序遍历 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">levelOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="comment">// 直接遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">val</span>(i) != INT_MAX)</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="built_in">val</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 前序遍历 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="string">&quot;pre&quot;</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 中序遍历 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="string">&quot;in&quot;</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 后序遍历 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="string">&quot;post&quot;</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="优势与局限性"><a href="#优势与局限性" class="headerlink" title="优势与局限性"></a>优势与局限性</h4><p>二叉树的数组表示主要有以下优点。</p>
<ul>
<li>数组存储在连续的内存空间中，对缓存友好，访问与遍历速度较快。</li>
<li>不需要存储指针，比较节省空间。</li>
<li>允许随机访问节点。</li>
</ul>
<p>然而，数组表示也存在一些局限性。</p>
<ul>
<li>数组存储需要连续内存空间，因此不适合存储数据量过大的树。</li>
<li>增删节点需要通过数组插入与删除操作实现，效率较低。</li>
<li>当二叉树中存在大量 None 时，数组中包含的节点数据比重较低，空间利用率较低。</li>
</ul>
<h3 id="二叉搜索树binary-search-tree"><a href="#二叉搜索树binary-search-tree" class="headerlink" title="二叉搜索树binary search tree"></a>二叉搜索树binary search tree</h3><p>对于任意父节点：左子节点值&lt;父节点值&lt;右子节点值⇒那么，左子树中所有节点的值 &lt; 根节点的值 &lt; 右子树中所有节点的值</p>
<p><img src="/image/image__at4VQbJmK.png"></p>
<h4 id="二叉搜索树操作"><a href="#二叉搜索树操作" class="headerlink" title="二叉搜索树操作"></a>二叉搜索树操作</h4><p>1.   查找节点</p>
<p>给定目标值 <code>num</code> 。声明当前节点 <code>cur</code> ，从二叉树根节点 <code>root</code> 出发，循环比较节点值 <code>cur.val</code> 和 <code>num</code> 间大小关系</p>
<ul>
<li>若 <code>cur.val &lt; num</code> ，说明目标节点在 <code>cur</code> 的右子树中，因此执行 <code>cur = cur.right</code>&#x20;</li>
<li>若 <code>cur.val &gt; num</code> ，说明目标节点在 <code>cur</code> 的左子树中，因此执行 <code>cur = cur.left</code>&#x20;</li>
<li>若 <code>cur.val = num</code> ，说明找到目标节点，跳出循环并返回该节点</li>
</ul>
<p>二叉搜索树的查找操作与二分查找算法的工作原理一致，都是每轮排除一半情况。<strong>循环次数最多为二叉树的高度</strong>，当二叉树平衡时，时间复杂度 O(log⁡n)&#x20;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 查找节点 */</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">search</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;<span class="comment">//搜索操作的循环次数是高度2^h-1=n  =&gt; h=logn</span></span><br><span class="line">    TreeNode *cur = root;</span><br><span class="line">    <span class="comment">// 循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 目标节点在 cur 的右子树中</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &lt; num)</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        <span class="comment">// 目标节点在 cur 的左子树中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;val &gt; num)</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        <span class="comment">// 找到目标节点，跳出循环</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回目标节点</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.   插入节点</p>
<p>给定一个待插入元素 <code>num</code></p>
<ol>
<li><strong>查找插入位置</strong>：与查找操作相似，从根节点出发，根据当前节点值和 <code>num</code> 的大小关系循环向下搜索，直到越过叶节点（遍历至 None ）时跳出循环。</li>
<li><strong>在该位置插入节点</strong>：初始化节点 <code>num</code> ，将该节点置于 None 的位置。</li>
</ol>
<p><img src="https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/bst_insert.png"></p>
<ul>
<li>二叉搜索树不允许存在重复节点，否则将违反其定义。因此，若待插入节点在树中已存在，则不执行插入，直接返回。</li>
<li>为了实现插入节点，我们需要借助节点 <code>pre</code> 保存上一轮循环的节点。这样在遍历至 None 时，我们可以获取到其父节点，从而完成节点插入操作。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 插入节点 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若树为空，则初始化根节点</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(num);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *cur = root, *pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到重复节点，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val == num)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="comment">// 插入位置在 cur 的右子树中</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &lt; num)</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        <span class="comment">// 插入位置在 cur 的左子树中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(num);</span><br><span class="line">    <span class="keyword">if</span> (pre-&gt;val &lt; num)</span><br><span class="line">        pre-&gt;right = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pre-&gt;left = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>与查找节点相同，插入节点使用 O(log⁡n) 时间。</p>
<p>3.   删除节点</p>
<p>先在二叉树中查找到目标节点，再将其从二叉树中删除。</p>
<p>因此，我们需要根据目标节点的子节点数量，共分为 0、1 和 2 这三种情况，执行对应的删除节点操作。</p>
<p>当待删除节点的度为 0 时，表示该节点是叶节点，可以直接删除。</p>
<p><img src="https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/bst_remove_case1.png"></p>
<p>当待删除节点的度为 1 时，将待删除节点替换为其子节点即可</p>
<p><img src="https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/bst_remove_case2.png"></p>
<p>当待删除节点的度为 2 ，无法直接删除它，而需要使用一个节点替换该节点。由于要保持二叉搜索树“左 &lt; 根 &lt; 右”的性质，<strong>因此这个节点可以是右子树最小节点或左子树最大节点</strong></p>
<p>假设我们选择右子树的最小节点（即中序遍历的下一个节点）</p>
<ol>
<li>找到待删除节点在“中序遍历序列”中的下一个节点，记为 <code>tmp</code> 。</li>
<li>将 <code>tmp</code> 的值覆盖待删除节点的值，并在树中递归删除节点 <code>tmp</code> 。</li>
</ol>
<p><img src="/image/image_hinXL8r9P-.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 删除节点 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若树为空，直接提前返回</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    TreeNode *cur = root, *pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 循环查找，越过叶节点后跳出</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到待删除节点，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val == num)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="comment">// 待删除节点在 cur 的右子树中</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &lt; num)</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        <span class="comment">// 待删除节点在 cur 的左子树中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若无待删除节点，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 子节点数量 = 0 or 1</span></span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;left == <span class="literal">nullptr</span> || cur-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 当子节点数量 = 0 / 1 时， child = nullptr / 该子节点</span></span><br><span class="line">        TreeNode *child = cur-&gt;left != <span class="literal">nullptr</span> ? cur-&gt;left : cur-&gt;right;</span><br><span class="line">        <span class="comment">// 删除节点 cur</span></span><br><span class="line">        <span class="keyword">if</span> (cur != root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre-&gt;left == cur)</span><br><span class="line">                pre-&gt;left = child;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pre-&gt;right = child;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若删除节点为根节点，则重新指定根节点</span></span><br><span class="line">            root = child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        <span class="keyword">delete</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子节点数量 = 2</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取中序遍历中 cur 的下一个节点</span></span><br><span class="line">        TreeNode *tmp = cur-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (tmp-&gt;left != <span class="literal">nullptr</span>) &#123;<span class="comment">//没到叶节点就继续往下递（搜索操作的循环次数是高度2^h-1=n  =&gt; h=logn）</span></span><br><span class="line">            tmp = tmp-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tmpVal = tmp-&gt;val;</span><br><span class="line">        <span class="comment">// 递归删除节点 tmp</span></span><br><span class="line">        <span class="built_in">remove</span>(tmp-&gt;val);</span><br><span class="line">        <span class="comment">// 用 tmp 覆盖 cur</span></span><br><span class="line">        cur-&gt;val = tmpVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.   中序遍历有序</p>
<p>二叉树中序遍历遵循“左 → 根 → 右”的遍历顺序，而二叉搜索树满足“左子节点 &lt; 根节点 &lt; 右子节点”的大小关系。</p>
<p>这意味着在二叉搜索树中进行中序遍历时，总是会优先遍历下一个最小节点，从而得出一个重要性质：<strong>二叉搜索树的中序遍历序列是升序的</strong>。利用中序遍历升序的性质，我们在<strong>二叉搜索树中获取有序数据仅需 O(n) 时间</strong>，无须进行额外的排序操作，非常高效。</p>
<p><img src="https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/bst_inorder_traversal.png"></p>
<p>5.构建2×搜素树：递归的找中点</p>
<h4 id="二叉搜索树效率"><a href="#二叉搜索树效率" class="headerlink" title="二叉搜索树效率"></a>二叉搜索树效率</h4><p>给定一组数据，我们考虑使用数组或二叉搜索树存储。<strong>二叉搜索树各项操作的时间复杂度都是对数阶，具有稳定高效的性能表现。只有在高频添加、低频查找删除的场景下，数组比二叉搜索树效率高</strong></p>
<p><img src="/image/image_iW2pJ4sAYu.png"></p>
<p>在理想情况下，二叉搜索树是“平衡”的，这样就可以在 log⁡n 轮循环内查找任意节点。</p>
<p>在二叉搜索树中不断地插入和删除节点，可能导致二叉树退化为链表，各种操作的时间复杂度退化为 O(n)&#x20;</p>
<p><img src="https://www.hello-algo.com/chapter_tree/binary_search_tree.assets/bst_degradation.png"></p>
<h4 id="二叉搜索树常见应用"><a href="#二叉搜索树常见应用" class="headerlink" title="二叉搜索树常见应用"></a>二叉搜索树常见应用</h4><ul>
<li>用作系统中的多级索引，实现高效的查找、插入、删除操作。</li>
<li>作为某些搜索算法的底层数据结构。</li>
<li>用于存储数据流，以保持其有序状态。</li>
</ul>
<h3 id="AVL-树-x20"><a href="#AVL-树-x20" class="headerlink" title="AVL 树&#x20;"></a>AVL 树&#x20;</h3><p>二叉树退化为链表时(不平衡时)。查，增删操作的时间复杂度从 O(h) 近似为 O(n)；<br>AVL 树「平衡二叉搜索树 balanced binary search tree」可以使失衡节点重新恢复平衡（自平衡）</p>
<p>自平衡策略：<br>平衡树的定义为任意节点左右子树高度差绝对值≤1；$|h(ltree)-h(rtree)|≤1$；(设null节点的节点高度为-1;)使每个节点存储节点高度；计算每个节点的平衡因子;从上往下找失衡节点<br>1）失衡节点$f&gt;1$；子节点$f\geq0$⇒右旋（&#x3D;0就是所谓特殊情况）<br>2）失衡节点$f&gt;1$；子节点$f&lt;0$⇒对换再右旋<br>3）失衡节点$f&lt;-1$；子节点$f\leq0$⇒左旋<br>4）失衡节点$f&lt;-1$；子节点$f&gt;0$⇒对换再左旋</p>
<p><img src="/image/image_VdnyumwKHh.png"></p>
<p><img src="/image/image_yX4BF8hzii.png"></p>
<p>右旋特例：节点 <code>child</code> 有右子节点（记为 <code>grandChild</code> ），要在右旋中添加一步：将 <code>grandChild</code> 作为 <code>node</code> 的左子节点</p>
<p><img src="/image/image_SaFp0a3H0D.png"></p>
<p>左旋特例：节点 <code>child</code> 有左子节点（记为 <code>grandChild</code> ），要在左旋中添加一步：将 <code>grandChild</code> 作为 <code>node</code> 的右子节点</p>
<p><img src="/image/image_sEPNyOfIIa.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* AVL 树节点类 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val&#123;&#125;;          <span class="comment">// 节点值</span></span><br><span class="line">    <span class="type">int</span> height = <span class="number">0</span>;     <span class="comment">// 节点高度</span></span><br><span class="line">    TreeNode *left&#123;&#125;;   <span class="comment">// 左子节点</span></span><br><span class="line">    TreeNode *right&#123;&#125;;  <span class="comment">// 右子节点</span></span><br><span class="line">    <span class="built_in">TreeNode</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TreeNode</span><span class="params">(<span class="type">int</span> x)</span> : val(x)&#123;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取平衡因子 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">balanceFactor</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空节点平衡因子为 0</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 节点平衡因子 = 左子树高度 - 右子树高度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">height</span>(node-&gt;left) - <span class="built_in">height</span>(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取节点高度 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空节点高度为 -1 ，叶节点高度为 0</span></span><br><span class="line">    <span class="keyword">return</span> node == <span class="literal">nullptr</span> ? <span class="number">-1</span> : node-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更新节点高度 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateHeight</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点高度等于最高子树高度 + 1</span></span><br><span class="line">    node-&gt;height = <span class="built_in">max</span>(<span class="built_in">height</span>(node-&gt;left), <span class="built_in">height</span>(node-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 右旋操作 */</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">rightRotate</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    TreeNode *child = node-&gt;left;</span><br><span class="line">    TreeNode *grandChild = child-&gt;right;<span class="comment">//处理了特殊情况</span></span><br><span class="line">    <span class="comment">// 以 child 为原点，将 node 向右旋转</span></span><br><span class="line">    child-&gt;right = node;</span><br><span class="line">    node-&gt;left = grandChild;</span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    <span class="built_in">updateHeight</span>(node);</span><br><span class="line">    <span class="built_in">updateHeight</span>(child);</span><br><span class="line">    <span class="comment">// 返回旋转后子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 左旋操作 */</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">leftRotate</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    TreeNode *child = node-&gt;right;</span><br><span class="line">    TreeNode *grandChild = child-&gt;left;</span><br><span class="line">    <span class="comment">// 以 child 为原点，将 node 向左旋转</span></span><br><span class="line">    child-&gt;left = node;</span><br><span class="line">    node-&gt;right = grandChild;</span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    <span class="built_in">updateHeight</span>(node);</span><br><span class="line">    <span class="built_in">updateHeight</span>(child);</span><br><span class="line">    <span class="comment">// 返回旋转后子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行旋转操作，使该子树重新恢复平衡 */</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">rotate</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取节点 node 的平衡因子</span></span><br><span class="line">    <span class="type">int</span> _balanceFactor = <span class="built_in">balanceFactor</span>(node);</span><br><span class="line">    <span class="comment">// 左偏树</span></span><br><span class="line">    <span class="keyword">if</span> (_balanceFactor &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">balanceFactor</span>(node-&gt;left) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 右旋</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">rightRotate</span>(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 先左旋后右旋</span></span><br><span class="line">            node-&gt;left = <span class="built_in">leftRotate</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">rightRotate</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右偏树</span></span><br><span class="line">    <span class="keyword">if</span> (_balanceFactor &lt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">balanceFactor</span>(node-&gt;right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 左旋</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">leftRotate</span>(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 先右旋后左旋</span></span><br><span class="line">            node-&gt;right = <span class="built_in">rightRotate</span>(node-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">leftRotate</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 平衡树，无须旋转，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="AVL-树常用操作"><a href="#AVL-树常用操作" class="headerlink" title="AVL 树常用操作"></a>AVL 树常用操作</h4><p>在bst基础上递归逐级返回父节点时加个自平衡操作</p>
<p>1.   插入节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 插入节点 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    root = <span class="built_in">insertHelper</span>(root, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 递归插入节点（辅助方法） */</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">insertHelper</span><span class="params">(TreeNode *node, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);<span class="comment">//返回上级递归函数，由父节点左右指针存储</span></span><br><span class="line">    <span class="comment">/* 1. 查找插入位置，并插入节点 */</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; node-&gt;val)</span><br><span class="line">        node-&gt;left = <span class="built_in">insertHelper</span>(node-&gt;left, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; node-&gt;val)</span><br><span class="line">        node-&gt;right = <span class="built_in">insertHelper</span>(node-&gt;right, val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> node;    <span class="comment">// 重复节点不插入，直接返回</span></span><br><span class="line">    <span class="built_in">updateHeight</span>(node); <span class="comment">// 更新节点高度</span></span><br><span class="line">    <span class="comment">/* 2. 执行旋转操作，使该子树重新恢复平衡 */</span></span><br><span class="line">    node = <span class="built_in">rotate</span>(node);</span><br><span class="line">    <span class="comment">// 返回子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> node;<span class="comment">//返回父节点递归地自平衡</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.   删除节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 删除节点 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    root = <span class="built_in">removeHelper</span>(root, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 递归删除节点（辅助方法） */</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">removeHelper</span><span class="params">(TreeNode *node, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">/* 1. 查找节点，并删除之 */</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; node-&gt;val)</span><br><span class="line">        node-&gt;left = <span class="built_in">removeHelper</span>(node-&gt;left, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; node-&gt;val)</span><br><span class="line">        node-&gt;right = <span class="built_in">removeHelper</span>(node-&gt;right, val);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">nullptr</span> || node-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            TreeNode *child = node-&gt;left != <span class="literal">nullptr</span> ? node-&gt;left : node-&gt;right;</span><br><span class="line">            <span class="comment">// 子节点数量 = 0 ，直接删除 node 并返回</span></span><br><span class="line">            <span class="keyword">if</span> (child == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> node;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 子节点数量 = 1 ，直接删除 node</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">delete</span> node;</span><br><span class="line">                node = child;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 子节点数量 = 2 ，则将中序遍历的下个节点删除，并用该节点替换当前节点</span></span><br><span class="line">            TreeNode *temp = node-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (temp-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                temp = temp-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> tempVal = temp-&gt;val;</span><br><span class="line">            node-&gt;right = <span class="built_in">removeHelper</span>(node-&gt;right, temp-&gt;val);</span><br><span class="line">            node-&gt;val = tempVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">updateHeight</span>(node); <span class="comment">// 更新节点高度</span></span><br><span class="line">    <span class="comment">/* 2. 执行旋转操作，使该子树重新恢复平衡 */</span></span><br><span class="line">    node = <span class="built_in">rotate</span>(node);</span><br><span class="line">    <span class="comment">// 返回子树的根节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.   查找节点</p>
<p>AVL 树的节点查找操作与二叉搜索树一致，不再赘述</p>
<h4 id="AVL-树典型应用"><a href="#AVL-树典型应用" class="headerlink" title="AVL 树典型应用"></a>AVL 树典型应用</h4><ul>
<li>组织和存储大型数据，适用于高频查找、低频增删的场景。</li>
<li>用于构建数据库中的索引系统。</li>
<li>红黑树在许多应用中比 AVL 树更受欢迎。这是因为红黑树的平衡条件相对宽松，在红黑树中插入与删除节点所需的旋转操作相对较少，其节点增删操作的平均效率更高。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找binary search;logn&amp;#x20;</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BEbinary%20search;logn/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BEbinary%20search;logn/</url>
    <content><![CDATA[<p>一种减治策略：适用于数据结构的元素本身存在序结构（依靠序结构比较中点减小子问题规模的）；减治在进入每一层都应该有个判断</p>
<h1 id="二分查找值"><a href="#二分查找值" class="headerlink" title="二分查找值"></a>二分查找值</h1><p>1）在数据集里搜索目标元素&#x3D;与中间值比较+前一半元素里搜索目标元素+在后一半元素里搜索目标元素<br>2）通过目标元素与中间值的比较减小子问题规模(意味着适用于存在序结构的数据结构：数组)<br>3）重复以上过程，直到目标元素&#x3D;中间值则找到，否则不存在此元素</p>
<p><img src="/image/image_5Smw1tU37i.png"></p>
<p><img src="/image/image_uED40DzVyU.png"></p>
<p><img src="/image/image_Cv13rw35rs.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 二分查找（双闭区间） */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化双闭区间 [0, n-1] ，即 i, j 分别指向数组首元素、尾元素</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 循环，当搜索区间为空时跳出（当 i &gt; j 时为空）</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> m = i + (j - i) / <span class="number">2</span>; <span class="comment">// 计算中点索引 m</span></span><br><span class="line">        <span class="keyword">if</span> (nums[m] &lt; target)    <span class="comment">// 此情况说明 target 在区间 [m+1, j] 中</span></span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &gt; target) <span class="comment">// 此情况说明 target 在区间 [i, m-1] 中</span></span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 找到目标元素，返回其索引</span></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到目标元素，返回 -1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;<span class="comment">//这个双闭区间实现听说在无符号int数组上有坑；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=========================================以下为递归实现=====================================</span><br><span class="line"><span class="comment">/* 二分查找：问题 f(i, j) */</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">dfs</span>(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target, <span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line">    <span class="comment">// 若区间为空，代表无目标元素，则返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; j) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算中点索引 m</span></span><br><span class="line">    <span class="type">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[m] &lt; target) &#123;</span><br><span class="line">        <span class="comment">// 递归子问题 f(m+1, j)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(nums, target, m + <span class="number">1</span>, j);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &gt; target) &#123;</span><br><span class="line">        <span class="comment">// 递归子问题 f(i, m-1)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(nums, target, i, m - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到目标元素，返回其索引</span></span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 二分查找 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 求解问题 f(0, n-1)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(nums, target, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>时间复杂度 O(log⁡n)</strong> ：在二分循环中，区间每轮缩小一半，最坏情况经过h轮判断$\frac{1}{2}^{h}n&#x3D;1$逼近到最后一个元素；循环次数为 到logn&#x20;<br><strong>空间复杂度 O(1)</strong> ：指针 i和 j使用常数大小空间。</p>
<p>优点：二分查找在时间和空间方面都有较好性能</p>
<ul>
<li><strong>大数据量下，对数阶时间复杂度有显著优势</strong>。例如，当数据大小 n&#x3D;2^20 时，线性查找需要 2^20&#x3D;1048576 轮循环，而二分查找仅需 log2^20&#x3D;20 轮循环。</li>
<li>二分查找无须额外空间。相较于需要借助额外空间的搜索算法（例如哈希查找），二分查找更加节省空间。</li>
</ul>
<p>局限性:并非适用于所有情况</p>
<ul>
<li>二分查找仅适用于有序数据。若输入数据无序，为使用二分查找而专门进行排序(通常为 O(nlog⁡n) )，得不偿失。<br>对于频繁插入元素的场景，为保持数组有序性，需要将元素插入到特定位置，时间复杂度为 O(n) ，也是非常昂贵的。</li>
<li>二分查找仅适用于数组。二分查找需要跳跃式（非连续地）访问元素，而在链表中执行跳跃式访问的效率较低，因此不适合应用在链表或基于链表实现的数据结构。</li>
<li>小数据量下，线性查找性能更佳。在线性查找中，每轮只需要 1 次判断操作；而在二分查找中，需要 1 次加法、1 次除法、1 ~ 3 次判断操作、1 次加法（减法），共 4 ~ 6 个单元操作；因此，当数据量 n 较小时，线性查找反而比二分查找更快。</li>
</ul>
<h1 id="二分查找插入点"><a href="#二分查找插入点" class="headerlink" title="二分查找插入点"></a>二分查找插入点</h1><p>二分查找不仅可用于搜索目标元素，还具有许多变种问题，比如搜索目标元素的插入位置，其实不如说这种减治策略可运用在多种场合</p>
<h2 id="无重复元素"><a href="#无重复元素" class="headerlink" title="无重复元素"></a>无重复元素</h2><p><img src="/image/image_zva3ro86VA.png"></p>
<p>数组原先无重复元素：应用二分查找<br>1）有相同元素→返回索引<br>2）无相同元素；不可避免的进入最后一次i&#x3D;j的循环;i&#x3D;j&#x3D;mid&lt;target,i左移；i&#x3D;j&#x3D;mid&gt;target,j右移；这意味着i总指向第一个大于target的元素（这个元素占据了i应该呆的位置）；返回i即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 二分查找插入点（无重复元素） */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearchInsertionSimple</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 初始化双闭区间 [0, n-1]</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> m = i + (j - i) / <span class="number">2</span>; <span class="comment">// 计算中点索引 m</span></span><br><span class="line">        <span class="keyword">if</span> (nums[m] &lt; target) &#123;</span><br><span class="line">            i = m + <span class="number">1</span>; <span class="comment">// target 在区间 [m+1, j] 中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &gt; target) &#123;</span><br><span class="line">            j = m - <span class="number">1</span>; <span class="comment">// target 在区间 [i, m-1] 中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m; <span class="comment">// 找到 target ，返回插入点 m</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到 target ，返回插入点 i</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="有重复元素"><a href="#有重复元素" class="headerlink" title="有重复元素"></a>有重复元素</h2><p><img src="/image/image_6At8wB_J6T.png"></p>
<p>若原先数组是允许存在多个重复元素的，那么可能有多个target，用上述方法只能返回其中一个的索引</p>
<ol>
<li>执行二分查找，得到任意一个 <code>target</code> 的索引，记为 k 。</li>
<li>从索引 k 开始，向左进行线性遍历，当找到最左边的 <code>target</code> 时返回。</li>
</ol>
<p>当数组中存在很多重复的 <code>target</code> 时，因为包含线性查找，此方法效率很低O(n)</p>
<p>新方法：这意味着解决的问题不同；在找到了target后要再找最左边的target或第一个小于target的元素<br>1）若target存在，返回最左target的索引<br>2）若target不存在，返回首个大于target的索引</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 二分查找插入点（存在重复元素） */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearchInsertion</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// 初始化双闭区间 [0, n-1]</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> m = i + (j - i) / <span class="number">2</span>; <span class="comment">// 计算中点索引 m</span></span><br><span class="line">        <span class="keyword">if</span> (nums[m] &lt; target) &#123;</span><br><span class="line">            i = m + <span class="number">1</span>; <span class="comment">// target 在区间 [m+1, j] 中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &gt; target) &#123;</span><br><span class="line">            j = m - <span class="number">1</span>; <span class="comment">// target 在区间 [i, m-1] 中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//到这里意味着找到第一个target,j左移排除掉（m-1,?)上的target，继续进入循环在[i,m-1]中寻找target直到找到最后一个target,j左移使j&lt;i跳出循环；此时j指向首个小于target的索引，而i=j+1正好是改插入的地方</span></span><br><span class="line">            j = m - <span class="number">1</span>; <span class="comment">// </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回插入点 i</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/image/image_TVRSctpud1.png"></p>
<p><img src="/image/image_ijjylMX6Z4.png"></p>
<p><img src="/image/image_rrhQsY3rZr.png"></p>
<h1 id="二分查找边界"><a href="#二分查找边界" class="headerlink" title="二分查找边界"></a>二分查找边界</h1><p>上述方法：找不到target返回插入点；找到target返回左边界（最左target）作为插入点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 二分查找最左一个 target */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearchLeftEdge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等价于查找 target 的插入点</span></span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">binarySearchInsertion</span>(nums, target);</span><br><span class="line">    <span class="comment">// 未找到 target ，返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (i == nums.<span class="built_in">size</span>() || nums[i] != target) &#123;<span class="comment">//</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到 target ，返回索引 i</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修改为i右移排除target直到找到有边界，这是一种方法</p>
<p>更巧妙的方法是用这个找最左插入点的函数找最左target+1；那么返回的索引减1就是target的右边界</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 二分查找最右一个 target */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearchRightEdge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 转化为查找最左一个 target + 1</span></span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">binarySearchInsertion</span>(nums, target + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// j 指向最右一个 target ，i 指向首个大于 target 的元素</span></span><br><span class="line">    <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 未找到 target ，返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">-1</span> || nums[j] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到 target ，返回索引 j</span></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当数组不包含 <code>target</code> 时，最终 i和 j会分别指向首个大于、小于 <code>target</code> 的元素。</p>
<p>所以，可以构造一个数组中不存在的元素，用于查找左右边界。</p>
<ul>
<li>查找最左一个 <code>target</code> ：可以转化为查找 <code>target - 0.5</code> ，并返回指针 i。</li>
<li>查找最右一个 <code>target</code> ：可以转化为查找 <code>target + 0.5</code> ，并返回指针 j。</li>
</ul>
<p><img src="https://www.hello-algo.com/chapter_searching/binary_search_edge.assets/binary_search_edge_by_element.png"></p>
<p>注意以下两点：</p>
<ul>
<li>给定数组不包含小数，这意味着我们无须关心如何处理相等的情况。</li>
<li>因为该方法引入了小数，所以需要将函数中的变量 <code>target</code> 改为浮点数类型。</li>
</ul>
<p><strong>二分查找</strong></p>
<ul>
<li>适用于大数据量的情况，效率表现稳定，最差时间复杂度为 O(log⁡n) 。</li>
<li>数据量不能过大，因为存储数组需要连续的内存空间。</li>
<li>不适用于高频增删数据的场景，因为维护有序数组的开销较大。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>分数背包问题</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E5%88%86%E6%95%B0%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/%E5%88%86%E6%95%B0%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><img src="/image/image_jVwE5Ci7ry.png"></p>
<p>分数背包和 0-1 背包整体上非常相似；不同点在于，允许只选择物品的一部分。<strong>可对物品任意地进行切分，并按照重量比例来计算物品价值</strong>。<br>贪心策略：先用单位重量最高的物品填入背包</p>
<ol>
<li>物品从单位价值高到低排序</li>
<li>遍历物品，<strong>每轮选择单位价值最高的物品</strong>填入背包。（每轮进行一次局部最优填入）</li>
<li>若剩余背包容量不足，则用当前物品一部分填满背包。</li>
</ol>
<p><img src="/image/image_BzF8eNPdBC.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 物品 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> w; <span class="comment">// 物品重量</span></span><br><span class="line">    <span class="type">int</span> v; <span class="comment">// 物品价值</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Item</span>(<span class="type">int</span> w, <span class="type">int</span> v) : <span class="built_in">w</span>(w), <span class="built_in">v</span>(v) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分数背包：贪心 */</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">fractionalKnapsack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;wgt, vector&lt;<span class="type">int</span>&gt; &amp;val, <span class="type">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建物品列表，包含两个属性：重量、价值</span></span><br><span class="line">    vector&lt;Item&gt; items;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; wgt.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        items.<span class="built_in">push_back</span>(<span class="built_in">Item</span>(wgt[i], val[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按照单位价值 item.v / item.w 从高到低进行排序;序结构定义函数</span></span><br><span class="line">    <span class="built_in">sort</span>(items.<span class="built_in">begin</span>(), items.<span class="built_in">end</span>(), [](Item &amp;a, Item &amp;b) &#123; <span class="built_in">return</span> (<span class="type">double</span>)a.v / a.w &gt; (<span class="type">double</span>)b.v / b.w; &#125;);</span><br><span class="line">    <span class="comment">// 循环贪心选择</span></span><br><span class="line">    <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : items) &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.w &lt;= cap) &#123;</span><br><span class="line">            <span class="comment">// 若剩余容量充足，则将当前物品整个装进背包</span></span><br><span class="line">            res += item.v;</span><br><span class="line">            cap -= item.w;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若剩余容量不足，则将当前物品的一部分装进背包</span></span><br><span class="line">            res += (<span class="type">double</span>)item.v / item.w * cap;</span><br><span class="line">            <span class="comment">// 已无剩余容量，因此跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最差情况下，需要遍历整个物品列表，<strong>因此时间复杂度为 O(n)</strong> ，排序用了**O(n)**；其中 n 为物品数量。</p>
<p>由于初始化了一个 <code>Item</code> 对象列表，<strong>因此空间复杂度为O(n)</strong></p>
<h3 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h3><p>反证法：假设每轮填入单位最大价值物品所得并不一定是全局最优解；<br>⇒假设得到全局最优解时，不一定每轮填入单位最大价值物品<br>⇒假设得到全局最优解时，不一定会填入单位价值最高的物品x&#x20;<br>假设物品 x 是单位价值最高的物品，使用某算法求得最大价值为 <code>res</code> ，但该解中不包含物品 x 。</p>
<p>现在从背包中拿出单位重量的任意物品，并替换为单位重量的物品 x 。由于物品 x 的单位价值最高，因此替换后的总价值一定大于 <code>res</code> 。<strong>这与 <strong><strong><code>res</code></strong></strong> 是最优解矛盾，说明最优解中必须包含物品 x</strong>&#x20;</p>
<p>对于该解中的其他物品，我们也可以构建出上述矛盾。总而言之，<strong>单位价值更大的物品总是更优选择</strong>，这说明贪心策略是有效的。</p>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序 bubble sort;O(n^2)</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%20bubble%20sort;O(n%5E2)/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%20bubble%20sort;O(n%5E2)/</url>
    <content><![CDATA[<p>退化分治；<br>排序&#x3D;使序为0的值回到索引0+使序为1的值回到索引1+…………使序为size-1的值回到索引size-1<br>经过size-1次邻换0必将回到索引0；经过size-2次对换1回到索引1；以此类推，但发现没？其原问题的解不是由子问题解合并而成，解决原问题&#x3D;解决第一个子问题；因为解决第一个问题的同时就解决了所有子问题</p>
<p>解决第一个子问题：不知道序0元素在哪，那么进行size-1次遍历对换&#x2F;&#x2F;O(n^2)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 冒泡排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 外循环：未排序区间为 [0, i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;<span class="comment">//一次遍历对换</span></span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;<span class="comment">//1次对换</span></span><br><span class="line">                <span class="comment">// 交换 nums[j] 与 nums[j + 1]</span></span><br><span class="line">                <span class="comment">// 这里使用了 std::swap() 函数</span></span><br><span class="line">                <span class="built_in">swap</span>(nums[j], nums[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效率优化:若某轮“冒泡”没执行任何交换操作，说明数组已经完成排序，可直接返回结果。因此，可以增加一个标志位 <code>flag</code> ，进入遍历交换前置0；交换操作发生时flag&#x3D;1；每轮遍历交换结束时检测是否为1；不是直接结束冒泡</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 冒泡排序（标志优化）*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSortWithFlag</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 外循环：未排序区间为 [0, i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>; <span class="comment">// 初始化标志位</span></span><br><span class="line">        <span class="comment">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换 nums[j] 与 nums[j + 1]</span></span><br><span class="line">                <span class="comment">// 这里使用了 std::swap() 函数</span></span><br><span class="line">                <span class="built_in">swap</span>(nums[j], nums[j + <span class="number">1</span>]);</span><br><span class="line">                flag = <span class="literal">true</span>; <span class="comment">// 记录交换元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 此轮冒泡未交换任何元素，直接跳出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>经过优化，冒泡排序的最差和平均时间复杂度仍为 O(O^2) ；但当输入数组完全有序时，可达到最佳时间复杂度 O(n)&#x20;</p>
<p><img src="/image/image_k4T5DoDZf-.png"></p>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>分治divide and conquer：</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BBdivide%20and%20conquer%EF%BC%9A/%E5%88%86%E6%B2%BBdivide%20and%20conquer%EF%BC%9A/</url>
    <content><![CDATA[<p>1)将原问题一级级不断分成若干相似子问题;直到终止条件的最小子问题<br>（各个子问题相互独立，不包含相同子问题；可简单求解）<br>2)求解子问题，并把结果返回上一级；如此一级级解决<br>3）最终原问题的解由子问题的解构建</p>
<p>分治策略高效是因为可以对操作数优化以及并行优化；<br>待补充</p>
<p>记忆化搜索：存储子问题结果；使重复子问题以O(1)的效率解决</p>
<p><img src="/image/image_vrYB4aW-4i.png"></p>
<p><img src="/image/image_2mLIYlYxG_.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 记忆化搜索 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, vector&lt;<span class="type">int</span>&gt; &amp;mem)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 已知 dp[1] 和 dp[2] ，返回之</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span> || i == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="comment">// 若存在记录 dp[i] ，则直接返回之</span></span><br><span class="line">    <span class="keyword">if</span> (mem[i] != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> mem[i];</span><br><span class="line">    <span class="comment">// dp[i] = dp[i-1] + dp[i-2]</span></span><br><span class="line">    <span class="type">int</span> count = <span class="built_in">dfs</span>(i - <span class="number">1</span>, mem) + <span class="built_in">dfs</span>(i - <span class="number">2</span>, mem);</span><br><span class="line">    <span class="comment">// 记录 dp[i]</span></span><br><span class="line">    mem[i] = count;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 爬楼梯：记忆化搜索 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">climbingStairsDFSMem</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// mem[i] 记录爬到第 i 阶的方案总数，-1 代表无记录</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mem</span><span class="params">(n + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(n, mem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划 dynamic programming</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20dynamic%20programming/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%20dynamic%20programming/</url>
    <content><![CDATA[<p>一种算法编程范式：<br>原问题的解与子问题解存在1）递推关系（状态转移方程）；2）且有最小子问题（初状态）；那么可以从最小子问题的解逐级递推构建原问题的解<br>步骤：<br>1）明确当前状态与前面几个状态有关；建立滚动数组存储状态；存入初状态<br>2）根据状态转移方程迭代</p>
<p><img src="/image/image_FlCR876V_9.png"></p>
<p><img src="/image/image_T7KR41w-7_.png"></p>
<p>这种有递推式的问题可以分治（可以分解为子问题），甚至回溯策略解决（因为解的结构是组合）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 爬楼梯：动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">climbingStairsDP</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="comment">// 初始化 dp 表，用于存储子问题的解</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 初始状态：预设最小子问题的解</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 状态转移：从较小子问题逐步求解较大子问题</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> temp = dp[<span class="number">1</span>]; </span><br><span class="line">        dp[<span class="number">1</span>] = dp[<span class="number">0</span>] + dp[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/image/image_UScqWPV0XI.png"></p>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>双向队列deque</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97deque/%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97deque/</url>
    <content><![CDATA[<p>在队列中，我们仅能在头部删除或在尾部添加元素。「双向队列 deque」提供更高灵活性，允许在头部和尾部执行添加或删除操作</p>
<p><img src="https://www.hello-algo.com/chapter_stack_and_queue/deque.assets/deque_operations.png"></p>
<h3 id="双向队列常用操作"><a href="#双向队列常用操作" class="headerlink" title="双向队列常用操作"></a>双向队列常用操作</h3><p>具体方法名称需根据编程语言确定</p>
<p><img src="/image/image_cVplrdeueq.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化双向队列 */</span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; deque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入队 */</span></span><br><span class="line">deque.<span class="built_in">push_back</span>(<span class="number">2</span>);   <span class="comment">// 添加至队尾</span></span><br><span class="line">deque.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">deque.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">deque.<span class="built_in">push_front</span>(<span class="number">3</span>);  <span class="comment">// 添加至队首</span></span><br><span class="line">deque.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问元素 */</span></span><br><span class="line"><span class="type">int</span> front = deque.<span class="built_in">front</span>(); <span class="comment">// 队首元素</span></span><br><span class="line"><span class="type">int</span> back = deque.<span class="built_in">back</span>();   <span class="comment">// 队尾元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素出队 */</span></span><br><span class="line">deque.<span class="built_in">pop_front</span>();  <span class="comment">// 队首元素出队</span></span><br><span class="line">deque.<span class="built_in">pop_back</span>();   <span class="comment">// 队尾元素出队</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取双向队列的长度 */</span></span><br><span class="line"><span class="type">int</span> size = deque.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断双向队列是否为空 */</span></span><br><span class="line"><span class="type">bool</span> empty = deque.<span class="built_in">empty</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="双向队列实现-x20"><a href="#双向队列实现-x20" class="headerlink" title="双向队列实现&#x20;"></a>双向队列实现&#x20;</h3><h4 id="1-基于双向链表的实现"><a href="#1-基于双向链表的实现" class="headerlink" title="1.   基于双向链表的实现"></a>1.   基于双向链表的实现</h4><p>上一节我们使用单向链表实现队列，因为它可以方便地删除头节点（出队）和在尾节点后添加新节点（入队）。<br>而双向队列头尾都可以执行入队和出队操作。自然采用“双向链表”作为双向队列的底层数据结构。<br>将双向链表的头节点和尾节点视为双向队列的队首和队尾，同时实现在两端添加和删除节点的功能。</p>
<p><img src="/image/image__5Lkd40FJl.png"></p>
<p><img src="/image/image_rKII06ESQE.png"></p>
<p><img src="/image/image_G2uzKhBl_E.png"></p>
<p><img src="/image/image_NOJUNzFPle.png"></p>
<p><img src="/image/image_4GtEDCRrV4.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 双向链表节点 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DoublyListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;              <span class="comment">// 节点值</span></span><br><span class="line">    DoublyListNode *next; <span class="comment">// 后继节点指针</span></span><br><span class="line">    DoublyListNode *prev; <span class="comment">// 前驱节点指针</span></span><br><span class="line">    <span class="built_in">DoublyListNode</span>(<span class="type">int</span> val) : <span class="built_in">val</span>(val), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基于双向链表实现的双向队列 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedListDeque</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    DoublyListNode *front, *rear; <span class="comment">// 头节点 front ，尾节点 rear</span></span><br><span class="line">    <span class="type">int</span> queSize = <span class="number">0</span>;              <span class="comment">// 双向队列的长度</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="built_in">LinkedListDeque</span>() : <span class="built_in">front</span>(<span class="literal">nullptr</span>), <span class="built_in">rear</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 析构方法 */</span></span><br><span class="line">    ~<span class="built_in">LinkedListDeque</span>() &#123;</span><br><span class="line">        <span class="comment">// 遍历链表删除节点，释放内存</span></span><br><span class="line">        DoublyListNode *pre, *cur = front;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> pre;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取双向队列的长度 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断双向队列是否为空 */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">size</span>() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 入队操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> num, <span class="type">bool</span> isFront)</span> </span>&#123;</span><br><span class="line">        DoublyListNode *node = <span class="keyword">new</span> <span class="built_in">DoublyListNode</span>(num);</span><br><span class="line">        <span class="comment">// 若链表为空，则令 front, rear 都指向 node</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>())</span><br><span class="line">            front = rear = node;</span><br><span class="line">        <span class="comment">// 队首入队操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isFront) &#123;</span><br><span class="line">            <span class="comment">// 将 node 添加至链表头部</span></span><br><span class="line">            front-&gt;prev = node;</span><br><span class="line">            node-&gt;next = front;</span><br><span class="line">            front = node; <span class="comment">// 更新头节点</span></span><br><span class="line">        <span class="comment">// 队尾入队操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将 node 添加至链表尾部</span></span><br><span class="line">            rear-&gt;next = node;</span><br><span class="line">            node-&gt;prev = rear;</span><br><span class="line">            rear = node; <span class="comment">// 更新尾节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        queSize++; <span class="comment">// 更新队列长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队首入队 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushFirst</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">push</span>(num, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队尾入队 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushLast</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">push</span>(num, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 出队操作 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">(<span class="type">bool</span> isFront)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若队列为空，直接返回 -1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="comment">// 队首出队操作</span></span><br><span class="line">        <span class="keyword">if</span> (isFront) &#123;</span><br><span class="line">            val = front-&gt;val; <span class="comment">// 暂存头节点值</span></span><br><span class="line">            <span class="comment">// 删除头节点</span></span><br><span class="line">            DoublyListNode *fNext = front-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fNext != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                fNext-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">                front-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">delete</span> front;</span><br><span class="line">            &#125;</span><br><span class="line">            front = fNext; <span class="comment">// 更新头节点</span></span><br><span class="line">        <span class="comment">// 队尾出队操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            val = rear-&gt;val; <span class="comment">// 暂存尾节点值</span></span><br><span class="line">            <span class="comment">// 删除尾节点</span></span><br><span class="line">            DoublyListNode *rPrev = rear-&gt;prev;</span><br><span class="line">            <span class="keyword">if</span> (rPrev != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                rPrev-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">                rear-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">delete</span> rear;</span><br><span class="line">            &#125;</span><br><span class="line">            rear = rPrev; <span class="comment">// 更新尾节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        queSize--; <span class="comment">// 更新队列长度</span></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队首出队 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">popFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pop</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队尾出队 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">popLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pop</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问队首元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isEmpty</span>() ? <span class="number">-1</span> : front-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问队尾元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isEmpty</span>() ? <span class="number">-1</span> : rear-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回数组用于打印 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">toVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DoublyListNode *node = front;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            res[i] = node-&gt;val;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-基于数组的实现"><a href="#2-基于数组的实现" class="headerlink" title="2.   基于数组的实现"></a>2.   基于数组的实现</h4><p><img src="/image/image_tTEPr1a1l1.png"></p>
<p><img src="/image/image_40TLhEKKnw.png"></p>
<p><img src="/image/image_ANwTe112PD.png"></p>
<p><img src="/image/image_6XBZKRHcNY.png"></p>
<p><img src="/image/image_B6kqQrDIJ3.png"></p>
<p>&#x20;在队列实现基础上，仅需增加“队首入队”和“队尾出队”的方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基于环形数组实现的双向队列 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayDeque</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums; <span class="comment">// 用于存储双向队列元素的数组</span></span><br><span class="line">    <span class="type">int</span> front;        <span class="comment">// 队首指针，指向队首元素</span></span><br><span class="line">    <span class="type">int</span> queSize;      <span class="comment">// 双向队列长度</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="built_in">ArrayDeque</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        nums.<span class="built_in">resize</span>(capacity);</span><br><span class="line">        front = queSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取双向队列的容量 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取双向队列的长度 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断双向队列是否为空 */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queSize == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 计算环形数组索引 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">index</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;<span class="comment">//计算模数</span></span><br><span class="line">        <span class="comment">// 通过取余操作实现数组首尾相连</span></span><br><span class="line">        <span class="comment">// 当 i 越过数组尾部后，回到头部</span></span><br><span class="line">        <span class="comment">// 当 i 越过数组头部后，回到尾部</span></span><br><span class="line">        <span class="keyword">return</span> (i + <span class="built_in">capacity</span>()) % <span class="built_in">capacity</span>();<span class="comment">//变成正数换算成标准模数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队首入队 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushFirst</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queSize == <span class="built_in">capacity</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;双向队列已满&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 队首指针向左移动一位</span></span><br><span class="line">        <span class="comment">// 通过取余操作，实现 front 越过数组头部后回到尾部</span></span><br><span class="line">        front = <span class="built_in">index</span>(front - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 将 num 添加至队首</span></span><br><span class="line">        nums[front] = num;</span><br><span class="line">        queSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队尾入队 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushLast</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queSize == <span class="built_in">capacity</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;双向队列已满&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算尾指针，指向队尾索引 + 1</span></span><br><span class="line">        <span class="type">int</span> rear = <span class="built_in">index</span>(front + queSize);</span><br><span class="line">        <span class="comment">// 将 num 添加至队尾</span></span><br><span class="line">        nums[rear] = num;</span><br><span class="line">        queSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队首出队 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">popFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">peekFirst</span>();</span><br><span class="line">        <span class="comment">// 队首指针向后移动一位</span></span><br><span class="line">        front = <span class="built_in">index</span>(front + <span class="number">1</span>);</span><br><span class="line">        queSize--;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 队尾出队 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">popLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">peekLast</span>();</span><br><span class="line">        queSize--;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问队首元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;双向队列为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> nums[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问队尾元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;双向队列为空&quot;</span>);</span><br><span class="line">        <span class="comment">// 计算尾元素索引</span></span><br><span class="line">        <span class="type">int</span> last = <span class="built_in">index</span>(front + queSize - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums[last];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回数组用于打印 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">toVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 仅转换有效长度范围内的列表元素</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(queSize)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = front; i &lt; queSize; i++, j++) &#123;</span><br><span class="line">            res[i] = nums[<span class="built_in">index</span>(j)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="双向队列应用"><a href="#双向队列应用" class="headerlink" title="双向队列应用"></a>双向队列应用</h3><p>双向队列兼具栈与队列的逻辑，<strong>因此它可以实现这两者的所有应用场景，同时提供更高的自由度</strong><br>软件的“撤销”功能通常使用栈来实现：系统将每次更改操作 <code>push</code> 到栈中，然后通过 <code>pop</code> 实现撤销。然而，考虑到系统资源的限制，软件通常会限制撤销的步数（例如仅允许保存 50 步）。当栈的长度超过 50 时，软件需要在栈底（即队首）执行删除操作。<strong>但栈无法实现该功能，此时就需要使用双向队列来替代栈</strong>。请注意，“撤销”的核心逻辑仍然遵循栈的先入后出原则，只是双向队列能够更加灵活地实现一些额外逻辑。</p>
<p><img src="/image/image_E2rb2sjRVF.png"></p>
<ul>
<li>栈是一种遵循先入后出原则的数据结构，可通过数组或链表来实现。</li>
<li>从时间效率角度看，栈的数组实现具有较高的平均效率，但在扩容过程中，单次入栈操作的时间复杂度会降低至 �(�) 。相比之下，基于链表实现的栈具有更为稳定的效率表现。</li>
<li>在空间效率方面，栈的数组实现可能导致一定程度的空间浪费。但需要注意的是，链表节点所占用的内存空间比数组元素更大。</li>
<li>队列是一种遵循先入先出原则的数据结构，同样可以通过数组或链表来实现。在时间效率和空间效率的对比上，队列的结论与前述栈的结论相似。</li>
<li>双向队列是一种具有更高自由度的队列，它允许在两端进行元素的添加和删除操作。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯backtracking algorithm：</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AFbacktracking%20algorithm%EF%BC%9A/%E5%9B%9E%E6%BA%AFbacktracking%20algorithm%EF%BC%9A/</url>
    <content><![CDATA[<p>枚举解空间：<br>问题的解空间${(x_{1},…x_{h});x_{i}\in分量集}$构成一棵多叉树，树每层存储的都是分量；树的每个叶节点都是一个解，以深度优先搜索（DFS）方式对解空间树进行搜索。若需要求出所有解则遍历解空间树；若只求问题的一个解，则搜索一个解就结束搜索。</p>
<p>一种特殊的枚举：解空间通常是有序&#x2F;无序对；适用于问题解的结构是组合的问题</p>
<p>dfs:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 前序遍历二叉树：value */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode *root,<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == value) &#123;</span><br><span class="line">        <span class="comment">// 记录解</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">preOrder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">preOrder</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实现记录路径功能：<br>1）遍历每个节点把指针push进栈，当找到满足的条件，把当前栈的值push进vector&lt;vector&lt;int *&gt;&gt;res<br>2）返回上一节点时，应该把当前分量指针从路径pop出去</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 前序遍历2*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode *root，<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前进，弄个栈存储当前遍历的分量节点，每遍历一个分量存1次，而到叶节点就会返回上一个分量；所以要pop当前分量，</span></span><br><span class="line">    path.<span class="built_in">push_back</span>(root);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == value) &#123;</span><br><span class="line">        <span class="comment">// 记录解</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">preOrder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">preOrder</span>(root-&gt;right);</span><br><span class="line">    <span class="comment">// 回退</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据约束条件排除某些解（减枝）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 前序遍历：3 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode *root，<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 剪枝</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span> || root-&gt;val == <span class="number">3</span>) &#123;<span class="comment">//假设约束条件是不能出现分量3</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试</span></span><br><span class="line">    path.<span class="built_in">push_back</span>(root);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == value) &#123;</span><br><span class="line">        <span class="comment">// 记录解</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">preOrder</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">preOrder</span>(root-&gt;right);</span><br><span class="line">    <span class="comment">// 回退</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>回溯框架：说实话，真不如上面直观</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 回溯算法框架 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(State *state, vector&lt;Choice *&gt; &amp;choices, vector&lt;State *&gt; &amp;res)</span> </span>&#123;<span class="comment">//遍历路径，值，搜索到的结果</span></span><br><span class="line">    <span class="comment">// 判断是否为解</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isSolution</span>(state)) &#123;</span><br><span class="line">        <span class="comment">// 记录解</span></span><br><span class="line">        <span class="built_in">recordSolution</span>(state, res);</span><br><span class="line">        <span class="comment">// 停止继续搜索</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有选择</span></span><br><span class="line">    <span class="keyword">for</span> (Choice choice : choices) &#123;</span><br><span class="line">        <span class="comment">// 剪枝：判断选择是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isValid</span>(state, choice)) &#123;</span><br><span class="line">            <span class="comment">// 尝试：做出选择，更新状态</span></span><br><span class="line">            <span class="built_in">makeChoice</span>(state, choice);</span><br><span class="line">            <span class="built_in">backtrack</span>(state, choices, res);</span><br><span class="line">            <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">            <span class="built_in">undoChoice</span>(state, choice);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ex:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 判断当前状态是否为解 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSolution</span><span class="params">(vector&lt;TreeNode *&gt; &amp;state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !state.<span class="built_in">empty</span>() &amp;&amp; state.<span class="built_in">back</span>()-&gt;val == <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 记录解 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recordSolution</span><span class="params">(vector&lt;TreeNode *&gt; &amp;state, vector&lt;vector&lt;TreeNode *&gt;&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    res.<span class="built_in">push_back</span>(state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断在当前状态下，该选择是否合法 */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(vector&lt;TreeNode *&gt; &amp;state, TreeNode *choice)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> choice != <span class="literal">nullptr</span> &amp;&amp; choice-&gt;val != <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更新状态 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeChoice</span><span class="params">(vector&lt;TreeNode *&gt; &amp;state, TreeNode *choice)</span> </span>&#123;</span><br><span class="line">    state.<span class="built_in">push_back</span>(choice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 恢复状态 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">undoChoice</span><span class="params">(vector&lt;TreeNode *&gt; &amp;state, TreeNode *choice)</span> </span>&#123;</span><br><span class="line">    state.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 回溯算法：例题三 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;TreeNode *&gt; &amp;state, vector&lt;TreeNode *&gt; &amp;choices, vector&lt;vector&lt;TreeNode *&gt;&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查是否为解</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isSolution</span>(state)) &#123;</span><br><span class="line">        <span class="comment">// 记录解</span></span><br><span class="line">        <span class="built_in">recordSolution</span>(state, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有选择</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode *choice : choices) &#123;</span><br><span class="line">        <span class="comment">// 剪枝：检查选择是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isValid</span>(state, choice)) &#123;</span><br><span class="line">            <span class="comment">// 尝试：做出选择，更新状态</span></span><br><span class="line">            <span class="built_in">makeChoice</span>(state, choice);</span><br><span class="line">            <span class="comment">// 进行下一轮选择</span></span><br><span class="line">            vector&lt;TreeNode *&gt; nextChoices&#123;choice-&gt;left, choice-&gt;right&#125;;</span><br><span class="line">            <span class="built_in">backtrack</span>(state, nextChoices, res);</span><br><span class="line">            <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">            <span class="built_in">undoChoice</span>(state, choice);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优势与局限性</p>
<p>回溯算法本质上是一种深度优先搜索算法，它尝试所有可能的解决方案直到找到满足条件的解。这种方法的优势在于它能够找到所有可能的解决方案，而且在合理的剪枝操作下，具有很高的效率。</p>
<p>然而，在处理大规模或者复杂问题时，<strong>回溯算法的运行效率可能难以接受</strong>。</p>
<ul>
<li><strong>时间</strong>：回溯算法通常需要遍历状态空间的所有可能，时间复杂度<strong>可以达到指数阶或阶乘阶</strong>。</li>
<li><strong>空间</strong>：在递归调用中需要保存当前的状态（例如路径、用于剪枝的辅助变量等），当深度很大时，空间需求可能会变得很大。</li>
</ul>
<p>即便如此，<strong>回溯算法仍然是某些搜索问题和约束满足问题的最佳解决方案</strong>。对于这些问题，由于无法预测哪些选择可生成有效的解，因此我们必须对所有可能的选择进行遍历。在这种情况下，<strong>关键是如何进行效率优化</strong>，常见的效率优化方法有两种。</p>
<ul>
<li><strong>剪枝</strong>：避免搜索那些肯定不会产生解的路径，从而节省时间和空间。</li>
<li><strong>启发式搜索</strong>：在搜索过程中引入一些策略或者估计值，从而优先搜索最有可能产生有效解的路径。</li>
</ul>
<h2 id="回溯典型例题"><a href="#回溯典型例题" class="headerlink" title="回溯典型例题"></a>回溯典型例题</h2><p>回溯算法可用于解决许多搜索问题、约束满足问题和组合优化问题。</p>
<p><strong>搜索问题</strong>：这类问题的目标是找到满足特定条件的解决方案。</p>
<ul>
<li>全排列问题：给定一个集合，求出其所有可能的排列组合。</li>
<li>子集和问题：给定一个集合和一个目标和，找到集合中所有和为目标和的子集。</li>
<li>汉诺塔问题：给定三个柱子和一系列大小不同的圆盘，要求将所有圆盘从一个柱子移动到另一个柱子，每次只能移动一个圆盘，且不能将大圆盘放在小圆盘上。</li>
</ul>
<p><strong>约束满足问题</strong>：这类问题的目标是找到满足所有约束条件的解。</p>
<ul>
<li>n 皇后：在 n×n 的棋盘上放置 n 个皇后，使得它们互不攻击。</li>
<li>数独：在 9×9 的网格中填入数字 1 ~ 9 ，使得每行、每列和每个 3×3 子网格中的数字不重复。</li>
<li>图着色问题：给定一个无向图，用最少的颜色给图的每个顶点着色，使得相邻顶点颜色不同。</li>
</ul>
<p><strong>组合优化问题</strong>：这类问题的目标是在一个组合空间中找到满足某些条件的最优解。</p>
<ul>
<li>0-1 背包问题：给定一组物品和一个背包，每个物品有一定的价值和重量，要求在背包容量限制内，选择物品使得总价值最大。</li>
<li>旅行商问题：在一个图中，从一个点出发，访问所有其他点恰好一次后返回起点，求最短路径。</li>
<li>最大团问题：给定一个无向图，找到最大的完全子图，即子图中的任意两个顶点之间都有边相连。</li>
</ul>
<p>请注意，对于许多组合优化问题，回溯都不是最优解决方案。</p>
<ul>
<li>0-1 背包问题通常使用动态规划解决，以达到更高的时间效率。</li>
<li>旅行商是一个著名的 NP-Hard 问题，常用解法有遗传算法和蚁群算法等。</li>
<li>最大团问题是图论中的一个经典问题，可用贪心等启发式算法来解决。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表hash table</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8hash%20table/%E5%93%88%E5%B8%8C%E8%A1%A8hash%20table/</url>
    <content><![CDATA[<p>以「key-value」形式存储数据的数据结构；可以理解为一种高级的数组，这种数组的下标可以是很大的整数，浮点数，字符串甚至结构体（字典就是一个哈希表）</p>
<p><img src="https://www.hello-algo.com/chapter_hashing/hash_map.assets/hash_table_lookup.png"></p>
<p>散列表设计理念：</p>
<p>1)摈弃线性查找O(n)，<strong>由事先可知的关键字（key</strong>）**;通过<strong>时间复杂度</strong>O(1)的hash function映射到值所在存储位置**</p>
<p><img src="/image/image_-cz6d5IDVs.png"></p>
<ul>
<li><strong>添加元素</strong>：仅需将元素添加至数组（链表）尾部即可，O(1)&#x20;</li>
<li><strong>查询元素</strong>：数组和链表是线性查找 O(n) (要遍历所有元素)</li>
<li><strong>删除元素</strong>：需先查询到元素，再从数组（链表）中删除， O(n)&#x20;</li>
</ul>
<p>哈希函数使得增删改查都是O(1)</p>
<p>2)理论上包含无穷个key的输入空间→有限集（容量有限的数组&#x2F;链表）；会产生多对1的哈希冲突<br>3）<strong>元素可能以无序方式存进去</strong>；安全性增强（打乱了数据原有的序结构，获取数组时不能简单得知）；元素间可能存在空隙<br>4）线性结构：每个键值对间是无序结构的；但其底层实现为线性表（存储单元存在序结构）；物理结构可能连续&#x2F;离散<br>5）扩容：</p>
<h3 id="哈希表常用操作"><a href="#哈希表常用操作" class="headerlink" title="哈希表常用操作"></a>哈希表常用操作</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化哈希表 */</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, string&gt; map;</span><br><span class="line"><span class="comment">/* 添加操作 */</span></span><br><span class="line"><span class="comment">// 在哈希表中添加键值对 (key, value)</span></span><br><span class="line">map[<span class="number">12836</span>] = <span class="string">&quot;小哈&quot;</span>;</span><br><span class="line">map[<span class="number">15937</span>] = <span class="string">&quot;小啰&quot;</span>;</span><br><span class="line">map[<span class="number">16750</span>] = <span class="string">&quot;小算&quot;</span>;</span><br><span class="line">map[<span class="number">13276</span>] = <span class="string">&quot;小法&quot;</span>;</span><br><span class="line">map[<span class="number">10583</span>] = <span class="string">&quot;小鸭&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//* 查询操作 */</span></span><br><span class="line"><span class="comment">// 向哈希表输入键 key ，得到值 value</span></span><br><span class="line">string name = map[<span class="number">15937</span>];</span><br><span class="line"><span class="comment">/* 删除操作 */</span></span><br><span class="line"><span class="comment">// 在哈希表中删除键值对 (key, value)</span></span><br><span class="line">map.<span class="built_in">erase</span>(<span class="number">10583</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 三种常用遍历哈希表方式 */</span></span><br><span class="line"><span class="comment">// 遍历键值对 key-&gt;value</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> kv: map) &#123;</span><br><span class="line">    cout &lt;&lt; kv.first &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; kv.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单独遍历键 key</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> key: map) &#123;</span><br><span class="line">    cout &lt;&lt; key.first &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单独遍历值 value</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> val: map) &#123;</span><br><span class="line">    cout &lt;&lt; val.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="哈希表简单实现"><a href="#哈希表简单实现" class="headerlink" title="哈希表简单实现"></a>哈希表简单实现</h3><p><img src="/image/image_DXPU6H5UFR.png"></p>
<p>考虑最简单情况，<strong>仅用一个数组实现哈希表</strong><br>1）建模为；无序结构的键值对bucket集<br>2）建立哈希函数 hash function；把key映射到数组index，并在此位置存储value</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">index = <span class="built_in">hash</span>(key) % capacity</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>把获得的哈希值取模得到index；获得value的存储位置;随后用 <code>index</code> 访问对应的bucket，从而获取 <code>value</code>&#x20;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 键值对 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    string val;</span><br><span class="line">    <span class="built_in">Pair</span>(<span class="type">int</span> key, string val) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;key = key;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基于数组简易实现的哈希表 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayHashMap</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Pair *&gt; buckets;<span class="comment">//键值对数组</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ArrayHashMap</span>() &#123;</span><br><span class="line">        <span class="comment">// 初始化数组，包含 100 个桶</span></span><br><span class="line">        buckets = <span class="built_in">vector</span>&lt;Pair *&gt;(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ArrayHashMap</span>() &#123;</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;bucket : buckets) &#123;<span class="comment">//引用buckets的元素而非拷贝；const</span></span><br><span class="line">            <span class="keyword">delete</span> bucket;<span class="comment">//释放100个键值bucket内存</span></span><br><span class="line">        &#125;</span><br><span class="line">        buckets.<span class="built_in">clear</span>();<span class="comment">//？？？ </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 哈希函数 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hashFunc</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = key % <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查询操作 */</span></span><br><span class="line">    <span class="function">string <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        Pair *pair = buckets[index];</span><br><span class="line">        <span class="keyword">if</span> (pair == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> pair-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 添加操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, string val)</span> </span>&#123;</span><br><span class="line">        Pair *pair = <span class="keyword">new</span> <span class="built_in">Pair</span>(key, val);</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);<span class="comment">//计算出存储位置</span></span><br><span class="line">        buckets[index] = pair;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 删除操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        <span class="comment">// 释放内存并置为 nullptr</span></span><br><span class="line">        <span class="keyword">delete</span> buckets[index];</span><br><span class="line">        buckets[index] = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 获取所有键值对 */</span></span><br><span class="line">    <span class="function">vector&lt;Pair *&gt; <span class="title">pairSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vector&lt;Pair *&gt; pairSet;</span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                pairSet.<span class="built_in">push_back</span>(pair);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pairSet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 获取所有键 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; keySet;</span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                keySet.<span class="built_in">push_back</span>(pair-&gt;key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> keySet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 获取所有值 */</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">valueSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; valueSet;</span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                valueSet.<span class="built_in">push_back</span>(pair-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valueSet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印哈希表 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Pair *kv : <span class="built_in">pairSet</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; kv-&gt;key &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; kv-&gt;val &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="hash%20function/hash%20function.md" title="hash function">hash function</a></p>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图graph</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E5%9B%BEgraph/%E5%9B%BEgraph/</url>
    <content><![CDATA[<h2 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h2><p>多对多的网状结构，由「顶点 vertex」和「边 edge」组成</p>
<p><img src="/image/image_ENSOloEZQJ.png"></p>
<p><img src="/image/image_y4kjjdz4ia.png"></p>
<h2 id="序结构"><a href="#序结构" class="headerlink" title="序结构"></a>序结构</h2><p>根据边是否有方向，可分为「无向图 undirected graph」和「有向图 directed graph」ex:follow关系</p>
<p><img src="https://www.hello-algo.com/chapter_graph/graph.assets/directed_graph.png"></p>
<p>根据所有顶点是否连通，可分为「连通图 connected graph」和「非连通图 disconnected graph」</p>
<ul>
<li>对于连通图，从某个顶点出发，可以到达其余任意顶点。</li>
<li>对于非连通图，从某个顶点出发，至少有一个顶点无法到达。</li>
</ul>
<p><img src="https://www.hello-algo.com/chapter_graph/graph.assets/connected_graph.png"></p>
<p>可为边添加“权重”变量，从而分为「有权图 weighted graph」ex：亲密度网络</p>
<p><img src="https://www.hello-algo.com/chapter_graph/graph.assets/weighted_graph.png"></p>
<ul>
<li>两顶点「邻接 adjacency」：两顶点间存在边相连</li>
<li>A 到 B 的「路径 path」： A 到B 经过的边构成的序列</li>
<li>「度 degree」：顶点拥有的边数。对于有向图，「入度 In-Degree」表示有多少条边指向该顶点，「出度 Out-Degree」表示有多少条边从该顶点指出</li>
</ul>
<h2 id="数据操作及实现（代数结构）"><a href="#数据操作及实现（代数结构）" class="headerlink" title="数据操作及实现（代数结构）"></a>数据操作及实现（代数结构）</h2><h3 id="基于邻接矩阵adjacency-matrix实现"><a href="#基于邻接矩阵adjacency-matrix实现" class="headerlink" title="基于邻接矩阵adjacency matrix实现"></a>基于邻接矩阵<strong>adjacency matrix</strong>实现</h3><p><img src="https://www.hello-algo.com/chapter_graph/graph.assets/adjacency_matrix.png"></p>
<ul>
<li>顶点不能与自身相连，因此邻接矩阵主对角线元素没有意义</li>
<li>对于无向图，两个方向的边等价，此时邻接矩阵关于主对角线对称</li>
<li>将邻接矩阵的元素从 1 和 0 替换为权重，则可表示有权图。</li>
</ul>
<p>使用邻接矩阵表示图时，我们可以直接访问矩阵元素以获取边，因此增删查操作的效率很高，时间复杂度均为 O(1) 。然而，矩阵的空间复杂度为 O(n2) ，内存占用较多。</p>
<h4 id="初始化：-xA"><a href="#初始化：-xA" class="headerlink" title="初始化：&#xA;"></a>初始化：&#xA;</h4><p>n×n <strong>matrix</strong>的行（列）坐标代表顶点，矩阵元素代表边， 1 &#x2F;0 表示两顶点间是否存在边</p>
<p>1）初始化长度为 n 的顶点列表 <code>vertices</code>存储值O(n)<br>2）初始化 n×n 大小的邻接矩阵 ( 二维列表)<code>adjMat</code> 存储边状态（序结构） O(n^2)&#x20;</p>
<p><img src="/image/image_gfSLf7WRVp.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基于邻接矩阵实现的无向图类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphAdjMat</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vertices;       <span class="comment">// 顶点列表，元素代表“顶点值”，索引代表“顶点索引”</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adjMat; <span class="comment">// 邻接矩阵，行列索引对应“顶点索引”</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="built_in">GraphAdjMat</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;vertices, <span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;edges) &#123;</span><br><span class="line">        <span class="comment">// 添加顶点O(n)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : vertices) &#123;</span><br><span class="line">            <span class="built_in">addVertex</span>(val);<span class="comment">//O(n)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加边O(k)</span></span><br><span class="line">        <span class="comment">// 请注意，edges 是边集，其元素Matrix【i】【j】=1的坐标索引（i,j）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;edge : edges) &#123;</span><br><span class="line">            <span class="built_in">addEdge</span>(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h4 id="添加顶点O-n"><a href="#添加顶点O-n" class="headerlink" title="添加顶点O(n)"></a><strong>添加顶点</strong>O(n)</h4><p>1)顶点列表push val<br>2)matrix 加多一行0;O(n)<br>3）二维列表迭代n行在每个列表后push0;O(n)</p>
<p><img src="/image/image_3jC2MNaxVe.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取顶点数量 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertices.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加顶点 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addVertex</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 向顶点列表中添加新顶点的值</span></span><br><span class="line">        vertices.<span class="built_in">push_back</span>(val);</span><br><span class="line">        <span class="comment">// 邻接矩阵（二维列表）升1阶，在n索引处新加1行列表，对n个元素进行0初始化</span></span><br><span class="line">        adjMat.<span class="built_in">emplace_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 在邻接矩阵中添加一列</span></span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt; &amp;row : adjMat) &#123;</span><br><span class="line">            row.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="删除顶点：O-n-2"><a href="#删除顶点：O-n-2" class="headerlink" title="删除顶点：O(n^2)"></a><strong>删除顶点</strong>：O(n^2)</h4><p>在邻接矩阵中删除一行一列。当删除首行首列时达到最差情况，需要将 (n−1)^2 个元素“向左上移动”，从而使用 O(n^2) 时间</p>
<p><img src="/image/image_fzGlCUoJea.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 删除顶点 */</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">removeVertex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (index &gt;= <span class="built_in">size</span>()) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;顶点不存在&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 在顶点列表中移除索引 index 的顶点</span></span><br><span class="line">       vertices.<span class="built_in">erase</span>(vertices.<span class="built_in">begin</span>() + index);</span><br><span class="line">       <span class="comment">// 在邻接矩阵中删除索引 index 的行</span></span><br><span class="line">       adjMat.<span class="built_in">erase</span>(adjMat.<span class="built_in">begin</span>() + index);</span><br><span class="line">       <span class="comment">// 在邻接矩阵中删除索引 index 的列</span></span><br><span class="line">       <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt; &amp;row : adjMat) &#123;</span><br><span class="line">           row.<span class="built_in">erase</span>(row.<span class="built_in">begin</span>() + index);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="添加或删除边：O-1"><a href="#添加或删除边：O-1" class="headerlink" title="添加或删除边：O(1)"></a><strong>添加或删除边</strong>：O(1)</h4><p>直接在邻接矩阵中修改指定的边即可，使用 O(1) 时间。而由于是无向图，因此需要同时更新两个方向的边。</p>
<p><img src="/image/image_HlpL5ayNBR.png"></p>
<p><img src="/image/image_Lleu0_E6pD.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基于邻接矩阵实现的无向图类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphAdjMat</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vertices;       <span class="comment">// 顶点列表，元素代表“顶点值”，索引代表“顶点索引”</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; adjMat; <span class="comment">// 邻接矩阵，行列索引对应“顶点索引”</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="built_in">GraphAdjMat</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;vertices, <span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;edges) &#123;</span><br><span class="line">        <span class="comment">// 添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : vertices) &#123;</span><br><span class="line">            <span class="built_in">addVertex</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加边</span></span><br><span class="line">        <span class="comment">// 请注意，edges 元素代表顶点索引，即对应 vertices 元素索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;edge : edges) &#123;</span><br><span class="line">            <span class="built_in">addEdge</span>(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取顶点数量 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertices.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加顶点 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addVertex</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 向顶点列表中添加新顶点的值</span></span><br><span class="line">        vertices.<span class="built_in">push_back</span>(val);</span><br><span class="line">        <span class="comment">// 邻接矩阵（二维列表）升1阶，在n索引处新加1行列表，对n个元素进行0初始化</span></span><br><span class="line">        adjMat.<span class="built_in">emplace_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 在邻接矩阵中添加一列</span></span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt; &amp;row : adjMat) &#123;</span><br><span class="line">            row.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除顶点 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeVertex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;顶点不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在顶点列表中移除索引 index 的顶点</span></span><br><span class="line">        vertices.<span class="built_in">erase</span>(vertices.<span class="built_in">begin</span>() + index);</span><br><span class="line">        <span class="comment">// 在邻接矩阵中删除索引 index 的行</span></span><br><span class="line">        adjMat.<span class="built_in">erase</span>(adjMat.<span class="built_in">begin</span>() + index);</span><br><span class="line">        <span class="comment">// 在邻接矩阵中删除索引 index 的列</span></span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt; &amp;row : adjMat) &#123;</span><br><span class="line">            row.<span class="built_in">erase</span>(row.<span class="built_in">begin</span>() + index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加边 */</span></span><br><span class="line">    <span class="comment">// 参数 i, j 对应 vertices 元素索引</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 索引越界与相等处理</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= <span class="built_in">size</span>() || j &gt;= <span class="built_in">size</span>() || i == j) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;顶点不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在无向图中，邻接矩阵沿主对角线对称，即满足 (i, j) == (j, i)</span></span><br><span class="line">        adjMat[i][j] = <span class="number">1</span>;</span><br><span class="line">        adjMat[j][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除边 */</span></span><br><span class="line">    <span class="comment">// 参数 i, j 对应 vertices 元素索引</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeEdge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 索引越界与相等处理</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= <span class="built_in">size</span>() || j &gt;= <span class="built_in">size</span>() || i == j) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;顶点不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        adjMat[i][j] = <span class="number">0</span>;</span><br><span class="line">        adjMat[j][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印邻接矩阵 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;顶点列表 = &quot;</span>;</span><br><span class="line">        <span class="built_in">printVector</span>(vertices);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;邻接矩阵 =&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">printVectorMatrix</span>(adjMat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="基于邻接表adjacency-list实现"><a href="#基于邻接表adjacency-list实现" class="headerlink" title="基于邻接表adjacency list实现"></a>基于邻接表adjacency list实现</h3><p>n 个链表表示图。第 i 条链表存储了i顶点的所有邻接顶点（即与该顶点相连的顶点）</p>
<p><img src="https://www.hello-algo.com/chapter_graph/graph.assets/adjacency_list.png"></p>
<p>邻接表仅存储实际存在的边，而边的总数通常远小于 n^2 ，因此它更加节省空间。然而，在邻接表中需要通过遍历链表来查找边，因此其时间效率不如邻接矩阵。</p>
<p><strong>邻接表结构与哈希表中的“链式地址”非常相似，可采用类似方法优化效率</strong>。比如当链表较长时，可以将链表转化为 AVL 树或红黑树，从而将时间效率从 O(n) 优化至 O(log⁡n) ；还可以把链表转换为哈希表，从而将时间复杂度降低至 O(1) 。</p>
<p>设无向图的顶点总数为 n、边总数为 m</p>
<h4 id="添加顶点：-O-1-x20"><a href="#添加顶点：-O-1-x20" class="headerlink" title="添加顶点： O(1)&#x20;"></a><strong>添加顶点</strong>： O(1)&#x20;</h4><p>在邻接表中添加一个链表，并将新增顶点作为链表头节点;<br>或把顶点*映射到 空 邻节点*列表</p>
<p><img src="/image/image_ywFLxAo0Lo.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 添加顶点 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addVertex</span><span class="params">(Vertex *vet)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (adjList.<span class="built_in">count</span>(vet))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 在邻接表中添加一个新链表</span></span><br><span class="line">    adjList[vet] = <span class="built_in">vector</span>&lt;Vertex *&gt;();<span class="comment">//建立key-&gt;value</span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h4 id="添加边：O-1"><a href="#添加边：O-1" class="headerlink" title="添加边：O(1)"></a><strong>添加边</strong>：O(1)</h4><p>在顶点对应链表的末尾添加边即可，使用 O(1) 时间。因为是无向图，所以需要同时添加两个方向的边。<br>或直接在对应的hashtable[key]添加hash value</p>
<p><img src="/image/image_6EMBPtEXRA.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(Vertex *vet1, Vertex *vet2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!adjList.<span class="built_in">count</span>(vet1) || !adjList.<span class="built_in">count</span>(vet2) || vet1 == vet2)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;不存在顶点&quot;</span>);</span><br><span class="line">    <span class="comment">// 添加边 vet1 - vet2</span></span><br><span class="line">    adjList[vet1].<span class="built_in">push_back</span>(vet2);</span><br><span class="line">    adjList[vet2].<span class="built_in">push_back</span>(vet1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="初始化：O-n-m-x20"><a href="#初始化：O-n-m-x20" class="headerlink" title="初始化：O(n+m)&#x20;"></a><strong>初始化</strong>：O(n+m)&#x20;</h4><p><img src="/image/image_ZcPNmmdN7A.png"></p>
<p>1）定义hash table：key为顶点 <em>，value为邻节点</em><br>2）遍历边集{（A <em>，b</em>）}；把连通点的key(A<em>和b</em>) push into hashtable；并指定value为空的Vertex<em>列表<br>3）把两个邻节点</em>*push into corresponding hashtable[key] list</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基于邻接表实现的无向图类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphAdjList</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 邻接表，key: 顶点，value：该顶点的所有邻接顶点</span></span><br><span class="line">    unordered_map&lt;Vertex *, vector&lt;Vertex *&gt;&gt; adjList;</span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="built_in">GraphAdjList</span>(<span class="type">const</span> vector&lt;vector&lt;Vertex *&gt;&gt; &amp;edges) &#123;<span class="comment">//edges是边集&#123;（1*，3*），（1*，5*），（1*，2*）...&#125;</span></span><br><span class="line">        <span class="comment">// 添加所有顶点和边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vector&lt;Vertex *&gt; &amp;edge : edges) &#123;<span class="comment">//O(m+n)</span></span><br><span class="line">            <span class="built_in">addVertex</span>(edge[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">addVertex</span>(edge[<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">addEdge</span>(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* 获取顶点数量 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adjList.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在邻接表中创建 n个顶点和 2m邻节点，使用 O(n+m) 时间。</p>
<h4 id="删除边：O-m"><a href="#删除边：O-m" class="headerlink" title="删除边：O(m)"></a><strong>删除边</strong>：O(m)</h4><p>在顶点对应链表中查找并删除指定边，使用 O(m) 时间。在无向图中，需要同时删除两个方向的边。</p>
<p><img src="/image/image_woE5XueGgy.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在 vector 中删除指定邻节点 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(vector&lt;Vertex *&gt; &amp;vec, Vertex *vet)</span> </span>&#123;<span class="comment">//vec顶点列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;<span class="comment">//最坏遍历m轮O(m)</span></span><br><span class="line">        <span class="keyword">if</span> (vec[i] == vet) &#123;</span><br><span class="line">            vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>() + i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* 删除边 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeEdge</span><span class="params">(Vertex *vet1, Vertex *vet2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!adjList.<span class="built_in">count</span>(vet1) || !adjList.<span class="built_in">count</span>(vet2) || vet1 == vet2)</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;不存在顶点&quot;</span>);</span><br><span class="line">    <span class="comment">// 删除边 vet1 - vet2</span></span><br><span class="line">    <span class="built_in">remove</span>(adjList[vet1], vet2);</span><br><span class="line">    <span class="built_in">remove</span>(adjList[vet2], vet1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除顶点：O-n-m"><a href="#删除顶点：O-n-m" class="headerlink" title="删除顶点：O(n+m) ??????"></a><strong>删除顶点</strong>：O(n+m) ??????</h4><p>1）hash table直接删除这个key的bucket<br>2）遍历所有value 列表 in hash bucket，删除包含指定顶点的所有边（即删除list里面的顶点 *），列表实现为O(n+m)</p>
<p><img src="/image/image_Tl1kk3go4x.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/* 在 vector 中删除指定邻节点 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(vector&lt;Vertex *&gt; &amp;vec, Vertex *vet)</span> </span>&#123;<span class="comment">//O(m)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vec[i] == vet) &#123;</span><br><span class="line">            vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>() + i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 删除顶点 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeVertex</span><span class="params">(Vertex *vet)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!adjList.<span class="built_in">count</span>(vet))</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;不存在顶点&quot;</span>);</span><br><span class="line">    <span class="comment">// 在邻接表中删除顶点 vet 对应的链表</span></span><br><span class="line">    adjList.<span class="built_in">erase</span>(vet);<span class="comment">//hash table直接删除这个key的bucket</span></span><br><span class="line">    <span class="comment">// 遍历其他顶点的链表，删除所有包含 vet 的边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;adj : adjList) &#123;<span class="comment">//O(m+n)?????</span></span><br><span class="line">        <span class="built_in">remove</span>(adj.second, vet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">    <span class="comment">/* 打印邻接表 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;邻接表 =&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;adj : adjList) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> &amp;key = adj.first;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> &amp;vec = adj.second;</span><br><span class="line">        cout &lt;&lt; key-&gt;val &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="built_in">printVector</span>(<span class="built_in">vetsToVals</span>(vec));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基于邻接表实现的无向图类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphAdjList</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 邻接表，key: 顶点，value：该顶点的所有邻接顶点</span></span><br><span class="line">    unordered_map&lt;Vertex *, vector&lt;Vertex *&gt;&gt; adjList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在 vector 中删除指定节点 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(vector&lt;Vertex *&gt; &amp;vec, Vertex *vet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vec[i] == vet) &#123;</span><br><span class="line">                vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>() + i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="built_in">GraphAdjList</span>(<span class="type">const</span> vector&lt;vector&lt;Vertex *&gt;&gt; &amp;edges) &#123;</span><br><span class="line">        <span class="comment">// 添加所有顶点和边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vector&lt;Vertex *&gt; &amp;edge : edges) &#123;</span><br><span class="line">            <span class="built_in">addVertex</span>(edge[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">addVertex</span>(edge[<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">addEdge</span>(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取顶点数量 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adjList.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加边 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(Vertex *vet1, Vertex *vet2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!adjList.<span class="built_in">count</span>(vet1) || !adjList.<span class="built_in">count</span>(vet2) || vet1 == vet2)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;不存在顶点&quot;</span>);</span><br><span class="line">        <span class="comment">// 添加边 vet1 - vet2</span></span><br><span class="line">        adjList[vet1].<span class="built_in">push_back</span>(vet2);</span><br><span class="line">        adjList[vet2].<span class="built_in">push_back</span>(vet1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除边 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeEdge</span><span class="params">(Vertex *vet1, Vertex *vet2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!adjList.<span class="built_in">count</span>(vet1) || !adjList.<span class="built_in">count</span>(vet2) || vet1 == vet2)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;不存在顶点&quot;</span>);</span><br><span class="line">        <span class="comment">// 删除边 vet1 - vet2</span></span><br><span class="line">        <span class="built_in">remove</span>(adjList[vet1], vet2);</span><br><span class="line">        <span class="built_in">remove</span>(adjList[vet2], vet1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加顶点 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addVertex</span><span class="params">(Vertex *vet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (adjList.<span class="built_in">count</span>(vet))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 在邻接表中添加一个新链表</span></span><br><span class="line">        adjList[vet] = <span class="built_in">vector</span>&lt;Vertex *&gt;();<span class="comment">//建立key-&gt;value</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除顶点 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeVertex</span><span class="params">(Vertex *vet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!adjList.<span class="built_in">count</span>(vet))</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;不存在顶点&quot;</span>);</span><br><span class="line">        <span class="comment">// 在邻接表中删除顶点 vet 对应的链表</span></span><br><span class="line">        adjList.<span class="built_in">erase</span>(vet);</span><br><span class="line">        <span class="comment">// 遍历其他顶点的链表，删除所有包含 vet 的边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;adj : adjList) &#123;</span><br><span class="line">            <span class="built_in">remove</span>(adj.second, vet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印邻接表 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;邻接表 =&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;adj : adjList) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> &amp;key = adj.first;</span><br><span class="line">            <span class="type">const</span> <span class="keyword">auto</span> &amp;vec = adj.second;</span><br><span class="line">            cout &lt;&lt; key-&gt;val &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">            <span class="built_in">printVector</span>(<span class="built_in">vetsToVals</span>(vec));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="效率对比"><a href="#效率对比" class="headerlink" title="效率对比"></a>效率对比</h3><p>设图有 n个顶点和 m条边</p>
<ol>
<li><strong>邻接表使用 <strong><strong><code>Vertex</code></strong></strong> 节点类表示顶点</strong>;使每个顶点都是唯一对象，此时删除顶点时就无须改动其余顶点;而通过顶点值来区分不同顶点，那么值重复的顶点将无法被区分。</li>
<li>邻接矩阵使用顶点列表索引来区分不同顶点。假设要删除索引为 i的顶点，则需要遍历整个邻接表，将其中 &gt;i的索引全部减 1 ，这样操作效率较低。</li>
</ol>
<p><img src="/image/image_wgyJbKugqq.png"></p>
<p>邻接表（哈希表）的时间与空间效率最优。但实际上，在邻接矩阵中操作边的效率更高，只需要一次数组访问或赋值操作即可。综合来看，邻接矩阵体现了“以空间换时间”的原则，而邻接表体现了“以时间换空间”的原则。</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>常用两种策略：<br>1）<strong>直接穷举</strong>：一笔画问题；关键在于能不能人为<strong>找出一种元素间的序结构</strong>；然后<strong>按层序遍历</strong><br>2）分治：遍历起点0的图&#x3D;访问0+遍历0邻节点（不含0）的图</p>
<h4 id="广度优先遍历-breadth-first-search；O-V-E-x20"><a href="#广度优先遍历-breadth-first-search；O-V-E-x20" class="headerlink" title="广度优先遍历 breadth-first search；O(|V|+|E|)&#x20;"></a>广度优先遍历 breadth-first search；O(|V|+|E|)&#x20;</h4><p>依据是数据本身存在层序结构：<br><strong>遍历起点到各节点的路径长度（经过边数量），由近到远分层（比如起点的邻节点都是第一层，第一层的领节点路径长度都是2，为第二层，以此类推）；逐层访问，同层的线性访问；</strong> 便能一笔画访问</p>
<p><img src="https://www.hello-algo.com/chapter_graph/graph_traversal.assets/graph_bfs.png"></p>
<p>1）声明<strong>存放遍历数据的列表</strong>；用于<strong>区分层序的队列</strong>；<strong>记录已访问节点的哈希表</strong> <code>visited</code>&#x20;<br>2）遍历起点<code>startVet</code>入队作为第0层<br>3）队首节点出队存至遍历列表和哈希表；线性遍历该节点所有邻节点，依次入队作为第1层节点（起点的邻节点肯定是第1层）；循环这个操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 广度优先遍历 BFS */</span></span><br><span class="line"><span class="comment">// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点</span></span><br><span class="line"><span class="function">vector&lt;Vertex *&gt; <span class="title">graphBFS</span><span class="params">(GraphAdjList &amp;graph, Vertex *startVet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 顶点遍历序列</span></span><br><span class="line">    vector&lt;Vertex *&gt; res;</span><br><span class="line">    <span class="comment">// 哈希表，用于记录已被访问过的顶点</span></span><br><span class="line">    unordered_set&lt;Vertex *&gt; visited = &#123;startVet&#125;;</span><br><span class="line">    <span class="comment">// 队列用于实现 BFS</span></span><br><span class="line">    queue&lt;Vertex *&gt; que;</span><br><span class="line">    que.<span class="built_in">push</span>(startVet);</span><br><span class="line">    <span class="comment">// 以顶点 vet 为起点，循环直至访问完所有顶点</span></span><br><span class="line">    <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Vertex *vet = que.<span class="built_in">front</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();          <span class="comment">// 队首顶点出队</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(vet); <span class="comment">// 记录访问顶点</span></span><br><span class="line">        <span class="comment">// 遍历该顶点的所有邻接顶点，未访问的入队并标记</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> adjVet : graph.adjList[vet]) &#123;<span class="comment">//遍历2E个邻节点</span></span><br><span class="line">            <span class="keyword">if</span> (visited.<span class="built_in">count</span>(adjVet))</span><br><span class="line">                <span class="keyword">continue</span>;            <span class="comment">// 跳过已被访问过的顶点</span></span><br><span class="line">            que.<span class="built_in">push</span>(adjVet);        <span class="comment">// 只入队未访问的顶点</span></span><br><span class="line">            visited.<span class="built_in">emplace</span>(adjVet); <span class="comment">// 标记该顶点已被访问</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回顶点遍历序列</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/image/image_tV8CTfbWQy.png"></p>
<p><img src="/image/image_DlWVHzDiN6.png"></p>
<p><img src="/image/image_sc9DCO6oe4.png"></p>
<p><img src="/image/image_R3QcNYwQjQ.png"></p>
<p><img src="/image/image_35yrdp7Ilm.png"></p>
<p><img src="/image/image_EsVe_KNtcl.png"></p>
<p><img src="/image/image_mmp1qvJ8ja.png"></p>
<p><img src="/image/image_bj7LupBw5L.png"></p>
<p><img src="/image/image_z3ZcSYP49U.png"></p>
<p><img src="/image/image_jG75--4gIj.png"></p>
<p><img src="/image/image_RgRY633iFQ.png"></p>
<p><strong>时间复杂度：</strong> 所有顶点都会入队并出队一次，使用 O(|V|) 时间；在遍历邻接顶点的过程中，由于是无向图，因此所有边都会被访问 2 次，使用 O(2|E|) 时间；总体使用 O(|V|+|E|) 时间。</p>
<p><strong>空间复杂度：</strong> 列表 <code>res</code> ，哈希表 <code>visited</code> ，队列 <code>que</code> 中的顶点数量最多为 |V| ，使用 O(|V|) 空间。</p>
<h4 id="深度优先遍历depth-first-search"><a href="#深度优先遍历depth-first-search" class="headerlink" title="深度优先遍历depth-first search"></a>深度优先遍历depth-first search</h4><p><img src="/image/image_R4u31ygpNu.png"></p>
<p>1）声明hash table存储已访问节点，使访问邻节点时可以跳过已访问节点；声明遍历列表存储遍历顶点元素<br>2）遍历起点为x的图&#x3D;访问x+遍历x所有邻节点为起点的图（去除x）<br>3）递归实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 深度优先遍历 DFS 辅助函数 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(GraphAdjList &amp;graph, unordered_set&lt;Vertex *&gt; &amp;visited, vector&lt;Vertex *&gt; &amp;res, Vertex *vet)</span> </span>&#123;</span><br><span class="line">    res.<span class="built_in">push_back</span>(vet);   <span class="comment">// 记录访问顶点</span></span><br><span class="line">    visited.<span class="built_in">emplace</span>(vet); <span class="comment">// 标记该顶点已被访问</span></span><br><span class="line">    <span class="comment">// 遍历该顶点的所有邻接顶点</span></span><br><span class="line">    <span class="keyword">for</span> (Vertex *adjVet : graph.adjList[vet]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited.<span class="built_in">count</span>(adjVet))</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 跳过已被访问过的顶点</span></span><br><span class="line">        <span class="comment">// 递归访问邻接顶点</span></span><br><span class="line">        <span class="built_in">dfs</span>(graph, visited, res, adjVet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 深度优先遍历 DFS */</span></span><br><span class="line"><span class="comment">// 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点</span></span><br><span class="line"><span class="function">vector&lt;Vertex *&gt; <span class="title">graphDFS</span><span class="params">(GraphAdjList &amp;graph, Vertex *startVet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 顶点遍历序列</span></span><br><span class="line">    vector&lt;Vertex *&gt; res;</span><br><span class="line">    <span class="comment">// 哈希表，用于记录已被访问过的顶点</span></span><br><span class="line">    unordered_set&lt;Vertex *&gt; visited;</span><br><span class="line">    <span class="built_in">dfs</span>(graph, visited, res, startVet);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><strong>时间复杂度：</strong> 所有顶点都会被访问 1 次，使用 O(|V|) 时间；遍历时，每有1条边便会访问 2 次邻节点，使用 O(2|E|) 时间；总体使用 O(|V|+|E|) 时间。</p>
<p><strong>空间复杂度：</strong> 列表 <code>res</code> ，哈希表 <code>visited</code> 顶点数量最多为 |V| ，递归深度最大为 |V| ，因此使用 O(|V|) 空间。</p>
<h2 id="图常见应用"><a href="#图常见应用" class="headerlink" title="图常见应用"></a>图常见应用</h2><p>许多现实系统都可以用图来建模，相应的问题也可以约化为图计算问题</p>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>基数排序 radix sort;O(n)</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%20radix%20sort;O(n)/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%20radix%20sort;O(n)/</url>
    <content><![CDATA[<p>退化分治：不能分别解决子问题，要按顺序解决子问题<br>排序&#x3D;忽视最高位，按其他位排序+按最高位排序&#x3D;忽视最高两位，按其他位排序+按次高位排序+按最高位排序&#x3D;。。。。。。。。<br>&#x20;      =按最低位排序+。。。。。+按最高位排序<br>每次排序可用计数排序实现（遍历数组数据某个位数，按这个位数出现次数进行计数）</p>
<p>以学号数据为例，假设数字的最低位是第 1 位，最高位是第 8 位</p>
<ol>
<li>初始化位数 k&#x3D;1 。</li>
<li>对学号的第 k 位执行“计数排序”。完成后，数据会根据第 k 位从小到大排序。</li>
<li>将 k 增加 1 ，然后返回步骤 <code>2.</code> 继续迭代，直到所有位都排序完成后结束。</li>
</ol>
<p><img src="https://www.hello-algo.com/chapter_sorting/radix_sort.assets/radix_sort_overview.png"></p>
<p><img src="/image/image_3Hgmx5xIbq.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取元素 num 的第 k 位，其中 exp = 10^(k-1) */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">digit</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> exp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 传入 exp 而非 k 可以避免在此重复执行昂贵的次方计算</span></span><br><span class="line">    <span class="keyword">return</span> (num / exp) % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计数排序（根据 nums 第 k 位排序） */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">countingSortDigit</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> exp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 十进制的位范围为 0~9 ，因此需要长度为 10 的桶</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 统计 0~9 各数字的出现次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> d = <span class="built_in">digit</span>(nums[i], exp); <span class="comment">// 获取 nums[i] 第 k 位，记为 d</span></span><br><span class="line">        counter[d]++;                <span class="comment">// 统计数字 d 的出现次数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求前缀和，将“出现个数”转换为“数组索引”</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        counter[i] += counter[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 倒序遍历，根据桶内统计结果，将各元素填入 res</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> d = <span class="built_in">digit</span>(nums[i], exp);</span><br><span class="line">        <span class="type">int</span> j = counter[d] - <span class="number">1</span>; <span class="comment">// 获取 d 在数组中的索引 j</span></span><br><span class="line">        res[j] = nums[i];       <span class="comment">// 将当前元素填入索引 j</span></span><br><span class="line">        counter[d]--;           <span class="comment">// 将 d 的数量减 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用结果覆盖原数组 nums</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        nums[i] = res[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基数排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取数组的最大元素，用于判断最大位数</span></span><br><span class="line">    <span class="type">int</span> m = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// 按照从低位到高位的顺序遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> exp = <span class="number">1</span>; exp &lt;= m; exp *= <span class="number">10</span>)</span><br><span class="line">        <span class="comment">// 对数组元素的第 k 位执行计数排序</span></span><br><span class="line">        <span class="comment">// k = 1 -&gt; exp = 1</span></span><br><span class="line">        <span class="comment">// k = 2 -&gt; exp = 10</span></span><br><span class="line">        <span class="comment">// 即 exp = 10^(k-1)</span></span><br><span class="line">        <span class="built_in">countingSortDigit</span>(nums, exp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相较于计数排序，基数排序适用于数值范围较大的情况，<strong>但前提是数据必须可以表示为固定位数的格式，且位数不能过大</strong>。例如，浮点数不适合使用基数排序，因为其位数 k 过大，可能导致时间复杂度 O(nk)≫O(n^2) 。</p>
<ul>
<li>**时间复杂度 **O(nk)：设数据量为 n、数据为 d 进制、最大位数为 k ，则对某一位执行计数排序使用 O(n+d) 时间，排序所有 k 位使用 O((n+d)k)时间。通常情况下，k和 d 都相对较小，时间复杂度趋向 O(n)</li>
<li>**空间复杂度 **O(n+d)<strong>、非原地排序</strong>：与计数排序相同，基数排序需要借助长度为 n和 d 的数组 <code>res</code> 和 <code>counter</code>&#x20;</li>
<li><strong>稳定排序</strong>：与计数排序相同。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>堆heap</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E5%A0%86heap/%E5%A0%86heap/</url>
    <content><![CDATA[<p>特殊的完全二叉树<br>1）完全二叉树：最底层节点靠左填充，其他层的节点都被填满<br>2.0)存在parent≥subtree或parent≤subtree的关系<br>2.1）「大顶堆 max heap」：任意节点的值 ≥ 其子节点的值<br>2.2）「小顶堆 min heap」：任意节点的值 ≤ 其子节点的值<br>3）根节点称“堆顶”；底层最靠右节点称“堆底”；分别为各自类型的极值</p>
<p><img src="/image/image_Zfcn_a8lVZ.png"></p>
<h2 id="叶节点数计算"><a href="#叶节点数计算" class="headerlink" title="叶节点数计算"></a>叶节点数计算</h2><p>设完全二叉树有N个节点，度0节点N0 （叶节点）， 度1节点N1 ， 度2节点 N2&#x20;</p>
<p>N &#x3D; N0 + N1 + N2</p>
<p>边 &#x3D; N-1&#x3D;0*<em>N0 + 1</em>*N1 + 2*N2;一节点头上一边除了root</p>
<p>⇒N0&#x3D;N2+1&#x3D;N-N0-N1+1<br>⇒N0&#x3D;(N-N1+1)&#x2F;2;自此导出了叶节点数与n的关系</p>
<p>完全二叉树中度为1的节点只会是0个或者1个</p>
<p><img src="/image/image_aEJyrmZKhZ.png"></p>
<p>当n1&#x3D;0时；(N-N1+1)能被2整除；<br>当n1&#x3D;1时；(N-N1+1)不能被2整除；；叶节点数量自然是向上取整的</p>
<h2 id="堆常用操作"><a href="#堆常用操作" class="headerlink" title="堆常用操作"></a>堆常用操作</h2><p>许多编程语言提供的是「优先队列 priority queue」：有优先级排序的队列；<strong>堆通常用作实现优先队列，大顶堆相当于元素按从大到小顺序出队的优先队列</strong>。从使用角度来看，可将“优先队列”和“堆”看作等价的数据结构。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化堆 */</span></span><br><span class="line"><span class="comment">// 初始化小顶堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; minHeap;<span class="comment">//中间int值列表存着初始化数据</span></span><br><span class="line"><span class="comment">// 初始化大顶堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; maxHeap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素入堆 */</span></span><br><span class="line">maxHeap.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">maxHeap.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">maxHeap.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">maxHeap.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">maxHeap.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取堆顶元素 */</span></span><br><span class="line"><span class="type">int</span> peek = maxHeap.<span class="built_in">top</span>(); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 堆顶元素出堆 */</span></span><br><span class="line"><span class="comment">// 出堆元素会形成一个从大到小的序列</span></span><br><span class="line">maxHeap.<span class="built_in">pop</span>(); <span class="comment">// 5</span></span><br><span class="line">maxHeap.<span class="built_in">pop</span>(); <span class="comment">// 4</span></span><br><span class="line">maxHeap.<span class="built_in">pop</span>(); <span class="comment">// 3</span></span><br><span class="line">maxHeap.<span class="built_in">pop</span>(); <span class="comment">// 2</span></span><br><span class="line">maxHeap.<span class="built_in">pop</span>(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取堆大小 */</span></span><br><span class="line"><span class="type">int</span> size = maxHeap.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断堆是否为空 */</span></span><br><span class="line"><span class="type">bool</span> isEmpty = maxHeap.<span class="built_in">empty</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输入列表并建堆 */</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; input&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">minHeap</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="堆实现"><a href="#堆实现" class="headerlink" title="堆实现"></a>堆实现</h2><p>以大顶堆为例；要转换为小顶堆，只需将所有大小逻辑判断取逆（例如，将 ≥ 替换为 ≤ ）</p>
<h3 id="x20-堆存储与表示"><a href="#x20-堆存储与表示" class="headerlink" title="&#x20;堆存储与表示"></a>&#x20;堆存储与表示</h3><p>数组元素存节点值，索引代表节点在二叉树中的位置;给定索引 i ，左子节点索引 2i+1 ，右子节点索引 2i+2 ，父节点索引 (i−1)&#x2F;2（向下取整）。索引越界表示空节点</p>
<p><img src="https://www.hello-algo.com/chapter_heap/heap.assets/representation_of_heap.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获取左子节点索引 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">left</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 获取右子节点索引 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">right</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 获取父节点索引 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">parent</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 向下取整</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="元素入堆O-h"><a href="#元素入堆O-h" class="headerlink" title="元素入堆O(h)"></a>元素入堆O(h)</h3><p>1）将<code>val</code>放到堆底；直接放入是不遵守堆的序结构的；<br>2）堆化 heapify：比较插入节点与父节点是否符合堆序，不符合则交换位置。执行此操作，从底至顶修复堆中的各个节点，直至越过根节点或遇到无须交换的节点时结束</p>
<p><img src="/image/image_SxHcQgIndb.png"></p>
<p><img src="/image/image_4K-7pAPQQv.png"></p>
<p><img src="/image/image_FWcQ9b7mcM.png"></p>
<p><img src="/image/image_Ylr-e--hC5.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 元素入堆 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加节点</span></span><br><span class="line">    maxHeap.<span class="built_in">push_back</span>(val);</span><br><span class="line">    <span class="comment">// 从底至顶堆化</span></span><br><span class="line">    <span class="built_in">siftUp</span>(<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 从节点 i 开始，从底至顶堆化 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">siftUp</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取节点 i 的父节点</span></span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">parent</span>(i);</span><br><span class="line">        <span class="comment">// 当“越过根节点”或“节点无须修复”时，结束堆化</span></span><br><span class="line">        <span class="keyword">if</span> (p &lt; <span class="number">0</span> || maxHeap[i] &lt;= maxHeap[p])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 交换两节点</span></span><br><span class="line">        <span class="built_in">swap</span>(maxHeap[i], maxHeap[p]);</span><br><span class="line">        <span class="comment">// 循环向上堆化</span></span><br><span class="line">        i = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="堆顶元素出堆O-h"><a href="#堆顶元素出堆O-h" class="headerlink" title="堆顶元素出堆O(h)"></a>堆顶元素出堆O(h)</h3><p>堆顶元素（二叉树根节点），即列表首元素。若直接删除首元素，那所有节点索引都会变化，要重新堆化排序。实际采用以下步骤：</p>
<ol>
<li>交换堆顶与堆底元素（交换根节点与最右叶节点）</li>
<li>交换完成后，将堆底从列表中删除（注意，由于已经交换，实际上删除的是原来的堆顶元素）。</li>
<li>从根节点开始，从<strong>顶至底堆化</strong>。</li>
</ol>
<p><img src="/image/image_0NNgoRNpa6.png"></p>
<p><img src="/image/image_qskVR3Dmkv.png"></p>
<p><img src="/image/image_xDCfzlSiXi.png"></p>
<p><img src="/image/image_qLzcndJi_n.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 元素出堆 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判空处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;堆为空&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换根节点与最右叶节点（即交换首元素与尾元素）</span></span><br><span class="line">    <span class="built_in">swap</span>(maxHeap[<span class="number">0</span>], maxHeap[<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    maxHeap.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="comment">// 从顶至底堆化</span></span><br><span class="line">    <span class="built_in">siftDown</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从节点 i 开始，从顶至底堆化 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">siftDown</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断节点 i, l, r 中值最大的节点，记为 ma</span></span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">left</span>(i), r = <span class="built_in">right</span>(i), ma = i;</span><br><span class="line">        <span class="comment">// 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt; <span class="built_in">size</span>() &amp;&amp; maxHeap[l] &gt; maxHeap[ma])</span><br><span class="line">            ma = l;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="built_in">size</span>() &amp;&amp; maxHeap[r] &gt; maxHeap[ma])</span><br><span class="line">            ma = r;</span><br><span class="line">        <span class="comment">// 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出</span></span><br><span class="line">        <span class="keyword">if</span> (ma == i)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(maxHeap[i], maxHeap[ma]);</span><br><span class="line">        <span class="comment">// 循环向下堆化</span></span><br><span class="line">        i = ma;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="访问堆顶元素O-1"><a href="#访问堆顶元素O-1" class="headerlink" title="访问堆顶元素O(1)"></a>访问堆顶元素O(1)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 访问堆顶元素 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> maxHeap[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><p>在某些情况下，我们希望使用一个列表来构建一个堆</p>
<h4 id="x20-借入堆操作实现O-nlog⁡n-x20"><a href="#x20-借入堆操作实现O-nlog⁡n-x20" class="headerlink" title="&#x20;借入堆操作实现O(nlog⁡n)&#x20;"></a>&#x20;借入堆操作实现O(nlog⁡n)&#x20;</h4><p>1）创建一个空堆，遍历列表依次对每个元素执行“入堆”(即将元素添加至堆尾，再对该元素“从底至顶”堆化)<br>2)每当一个元素入堆，堆长度加一;每个元素的入堆操作使用 O(log⁡n) 时间，输入n个元素；因此该建堆方法时间复杂度为O(nlog⁡n)&#x20;</p>
<h4 id="x20-通过遍历堆化实现（更高效的建堆）"><a href="#x20-通过遍历堆化实现（更高效的建堆）" class="headerlink" title="&#x20;通过遍历堆化实现（更高效的建堆）"></a>&#x20;通过遍历堆化实现（更高效的建堆）</h4><ol>
<li>将初始化列表原封不动添加到堆列表，此时堆的性质尚未得到满足。</li>
<li>逆层序遍历（对于数组就是倒序遍历），依次对每个非叶节点执行堆化；每个堆化的子树都是合法子堆</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 构造方法，根据输入列表建堆 */</span></span><br><span class="line"><span class="built_in">MaxHeap</span>(vector&lt;<span class="type">int</span>&gt; nums) &#123;</span><br><span class="line">    <span class="comment">// 将列表元素原封不动添加进堆</span></span><br><span class="line">    maxHeap = nums;</span><br><span class="line">    <span class="comment">// 堆化除叶节点以外的其他所有节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">parent</span>(<span class="built_in">size</span>() - <span class="number">1</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">siftDown</span>(i);<span class="comment">//从2^h-1层开始堆化；parent(size() - 1)为堆底元素的父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>复杂度分析：要堆化节点数量为n-(n-n1+1)&#x2F;2&#x3D;(n+n1-1)&#x2F;2;节点堆化最多要迭代logn次；那么这个操作要O(nlogn);<br>更准确的估算是：$\sum_{1}^{h}{}$h层节点数*h层的节点高度</p>
<p><img src="/image/image_hDTdCm02Gt.png"></p>
<h2 id="堆常见应用"><a href="#堆常见应用" class="headerlink" title="堆常见应用"></a>堆常见应用</h2><ul>
<li><strong>优先队列</strong>：堆通常作为实现优先队列的首选数据结构，其入队和出队操作的时间复杂度均为 O(log⁡n) ，而建队操作为 O(n) ，这些操作都非常高效。</li>
<li><strong>堆排序</strong>：给定一组数据，我们可以用它们建立一个堆，然后不断地执行元素出堆操作，从而得到有序数据。然而，我们通常会使用一种更优雅的方式实现堆排序，详见后续的堆排序章节。</li>
<li><strong>获取最大的 k 个元素</strong>：这是一个经典的算法问题，同时也是一种典型应用，例如选择热度前 10 的新闻作为微博热搜，选取销量前 10 的商品等。</li>
</ul>
<p><img src="/image/image_rTIHt1vvRv.png"></p>
<h1 id="Top-K-Question"><a href="#Top-K-Question" class="headerlink" title="Top-K Question"></a>Top-K Question</h1><p>给定一个长度为 n 无序数组 <code>nums</code> ，请返回数组中前k 大的元素。</p>
<p>对于该问题，我们先介绍两种思路比较直接的解法，再介绍效率更高的堆解法。</p>
<h2 id="方法一：遍历选择"><a href="#方法一：遍历选择" class="headerlink" title="方法一：遍历选择???"></a>方法一：遍历选择???</h2><p>k轮遍历，分别在每轮中提取第 1、2、…、k 大的元素，时间复杂度为 O(nk) 。</p>
<p>此方法只适用于k≪n 的情况，因为当 k 与 n 比较接近时，其时间复杂度趋向于 O(n^2) ，非常耗时。</p>
<p><img src="https://www.hello-algo.com/chapter_heap/top_k.assets/top_k_traversal.png"></p>
<p>当 k&#x3D;n 时，我们可以得到完整的有序序列，此时等价于“选择排序”算法。</p>
<h2 id="方法二：排序"><a href="#方法二：排序" class="headerlink" title="方法二：排序??"></a>方法二：排序??</h2><p>对数组 <code>nums</code> 进行排序，再返回最右边的 k 个元素，时间复杂度为 O(nlog⁡n) 。</p>
<p>显然，该方法“超额”完成任务了，因为我们只需要找出最大的 k 个元素即可，而不需要排序其他元素。</p>
<p><img src="https://www.hello-algo.com/chapter_heap/top_k.assets/top_k_sorting.png"></p>
<h2 id="方法三：堆"><a href="#方法三：堆" class="headerlink" title="方法三：堆"></a>方法三：堆</h2><p>1)初始化一个小顶堆,将数组前 k 个元素依次入堆<br>2)遍历数组k+1到size-1的元素；与堆顶比较，大的入堆,原堆顶元素pop；遍历完成后，堆中保存的就是最大的 k个元素</p>
<p><img src="/image/image_ye0ArEpLcQ.png"></p>
<p><img src="/image/image_NVRPnmqBI1.png"></p>
<p><img src="/image/image_K3y7jS6sRA.png"></p>
<p><img src="/image/image_sChWlhai9w.png"></p>
<p>最差情况执行了 n 轮入堆和n-k轮出堆，堆的最大长度为 k ，因此时间复杂度为 O(nlog⁡k) 。该方法的效率很高，当 k 较小时，时间复杂度趋向 O(n) ；当 k 较大时，时间复杂度不会超过 O(nlog⁡n) 。</p>
<p>该方法适用于动态数据流的使用场景。在不断加入数据时，我们可以持续维护堆内的元素，从而实现最大 k 个元素的动态更新。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基于堆查找数组中最大的 k 个元素 */</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">topKHeap</span>(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; heap;</span><br><span class="line">    <span class="comment">// 将数组的前 k 个元素入堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        heap.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从第 k+1 个元素开始，保持堆的长度为 k</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 若当前元素大于堆顶元素，则将堆顶元素出堆、当前元素入堆</span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; heap.<span class="built_in">top</span>()) &#123;</span><br><span class="line">            heap.<span class="built_in">pop</span>();</span><br><span class="line">            heap.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序 heap sort；O(nlogn)</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E5%A0%86%E6%8E%92%E5%BA%8F%20heap%20sort%EF%BC%9BO(nlogn)/%E5%A0%86%E6%8E%92%E5%BA%8F%20heap%20sort%EF%BC%9BO(nlogn)/</url>
    <content><![CDATA[<p>堆本身是排好了层序的；利用“建堆操作”和“元素出堆操作”实现堆排序。</p>
<ol>
<li>输入数组并建立小顶堆，此时最小元素位于堆顶。</li>
<li>不断执行出堆操作，依次记录出堆元素，即可得到从小到大排序的序列。</li>
</ol>
<p>以上方法虽可行，但需要借助一个额外数组来保存弹出的元素，比较浪费空间O(n)。在实际中，我们通常使用一种更加优雅的实现方式:<br>其思路是1）建立大顶堆,堆顶堆底互换，这样就把最大元素放到了数组最末；然后剩下的元素堆化恢复成大顶堆；堆顶的是次大值<br>2）重复进行n-1次上述操作</p>
<p><img src="/image/image_kLX_He-18d.png"></p>
<p><img src="/image/image_4uQ-qiJZFq.png"></p>
<p><img src="/image/image_9T2PVSkYLa.png"></p>
<p><img src="/image/image_cpz3lKg9Pb.png"></p>
<p><img src="/image/image_QAwrYt7e6M.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 堆的长度为 n ，从节点 i 开始，从顶至底堆化 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">siftDown</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断节点 i, l, r 中值最大的节点，记为 ma</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> r = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> ma = i;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; n &amp;&amp; nums[l] &gt; nums[ma])</span><br><span class="line">            ma = l;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; n &amp;&amp; nums[r] &gt; nums[ma])</span><br><span class="line">            ma = r;</span><br><span class="line">        <span class="comment">// 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出</span></span><br><span class="line">        <span class="keyword">if</span> (ma == i) &#123;<span class="comment">//因为是对换改变的这一点，所以除了本层，各级子树都满足大顶堆规则</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换两节点</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[ma]);</span><br><span class="line">        <span class="comment">// 循环向下堆化</span></span><br><span class="line">        i = ma;<span class="comment">//swap后继续堆化被交换了父节点的子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 堆排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建堆操作：堆化除叶节点以外的其他所有节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;<span class="comment">//从n-1层开始向上一层层堆化</span></span><br><span class="line">        <span class="built_in">siftDown</span>(nums, nums.<span class="built_in">size</span>(), i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从堆中提取最大元素，循环 n-1 轮</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// 交换根节点与最右叶节点（即交换首元素与尾元素）</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">        <span class="comment">// 以根节点为起点，从顶至底进行堆化恢复</span></span><br><span class="line">        <span class="built_in">siftDown</span>(nums, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度 O(nlog⁡n)、非自适应排序</strong>：建堆操作使用 O(n) 时间。从堆中提取最大元素的时间复杂度为 O(log⁡n) ，共循环 n−1 轮。</li>
<li><strong>空间复杂度 O(1)、原地排序</strong>：几个指针变量使用 O(1) 空间。元素交换和堆化操作都是在原数组上进行的。</li>
<li><strong>非稳定排序</strong>：在交换堆顶元素和堆底元素时，相等元素的相对位置可能发生变化。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>完全背包问题及其变种</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E5%8F%98%E7%A7%8D/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E5%8F%98%E7%A7%8D/</url>
    <content><![CDATA[<h1 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h1><p><img src="/image/image_pWD0JX-c6P.png"></p>
<p>完全背包和 0-1 背包问题非常相似，<strong>区别仅在于不限制物品的选择次数</strong><br>如果还是分治思想：会写出这样的状态方程：</p>
<p>$f(i,c)&#x3D;max(f(i-1,c),f(i-1,c-k<em>wgt(i-1))+k</em>val(i-1))$</p>
<p>如果是按dp表递推：是这个思路：因为上述的f(i,c)是第i轮决策后的最大价值；dp表的（i,c）元素是有一种序结构的，递推正是按着这个序结构（上→下，不放；左→右，再放一个i物品）；所以说<strong>dp问题重要的是dp表的递推序的状态转移方程</strong></p>
<p><img src="/image/image_yaZdHiJR34.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 完全背包：动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">unboundedKnapsackDP</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;wgt, vector&lt;<span class="type">int</span>&gt; &amp;val, <span class="type">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = wgt.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(cap + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">1</span>; c &lt;= cap; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) &#123;</span><br><span class="line">                <span class="comment">// 若超过背包容量，则不选物品 i</span></span><br><span class="line">                dp[i][c] = dp[i - <span class="number">1</span>][c];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不选和选物品 i 这两种方案的较大值</span></span><br><span class="line">                dp[i][c] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][c], dp[i][c - wgt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][cap];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>由于当前状态是从左边和上边的状态转移而来，<strong>因此空间优化后应该对 dp 表中的每一行采取正序遍历</strong>。</p>
<p><img src="/image/image_uKnqAIZIjB.png"></p>
<p><img src="/image/image_gExvhXuFtS.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 完全背包：空间优化后的动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">unboundedKnapsackDPComp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;wgt, vector&lt;<span class="type">int</span>&gt; &amp;val, <span class="type">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = wgt.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(cap + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">1</span>; c &lt;= cap; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) &#123;</span><br><span class="line">                <span class="comment">// 若超过背包容量，则不选物品 i</span></span><br><span class="line">                dp[c] = dp[c];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不选和选物品 i 这两种方案的较大值</span></span><br><span class="line">                dp[c] = <span class="built_in">max</span>(dp[c], dp[c - wgt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[cap];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="零钱兑换问题"><a href="#零钱兑换问题" class="headerlink" title="零钱兑换问题"></a>零钱兑换问题</h1><p><img src="/image/image_6TZV9nfLeo.png"></p>
<p><img src="/image/image_4FSZvyEXNp.png"></p>
<p>dp策略：<br>元素为（i,a）的dp表：f(i,a)前种i币值选取后总值为a的最小币数量<br>优化目标：最小硬币数量<br>状态转移方程：$ f(i,a)&#x3D;min(f(i,a-coins[i-1])+1,f(i-1，a))  $<br>边界：f(i,0)&#x3D;0<br>f(0,a)是无效状态考虑用+∞表示</p>
<p><img src="/image/image_cE1XWA5qPN.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 零钱兑换：动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChangeDP</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;coins, <span class="type">int</span> amt)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> MAX = amt + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(amt + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 状态转移：首行首列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>; a &lt;= amt; a++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][a] = MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 状态转移：其余行列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>; a &lt;= amt; a++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins[i - <span class="number">1</span>] &gt; a) &#123;</span><br><span class="line">                <span class="comment">// 若超过背包容量，则不选硬币 i</span></span><br><span class="line">                dp[i][a] = dp[i - <span class="number">1</span>][a];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不选和选硬币 i 这两种方案的较小值</span></span><br><span class="line">                dp[i][a] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][a], dp[i][a - coins[i - <span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][amt] != MAX ? dp[n][amt] : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="空间优化-1"><a href="#空间优化-1" class="headerlink" title="空间优化"></a>空间优化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 零钱兑换：空间优化后的动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChangeDPComp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;coins, <span class="type">int</span> amt)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> MAX = amt + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amt + <span class="number">1</span>, MAX)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>; a &lt;= amt; a++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins[i - <span class="number">1</span>] &gt; a) &#123;</span><br><span class="line">                <span class="comment">// 若超过背包容量，则不选硬币 i</span></span><br><span class="line">                dp[a] = dp[a];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不选和选硬币 i 这两种方案的较小值</span></span><br><span class="line">                dp[a] = <span class="built_in">min</span>(dp[a], dp[a - coins[i - <span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amt] != MAX ? dp[amt] : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序 merge sort；O(nlogn)</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%20merge%20sort%EF%BC%9BO(nlogn)/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%20merge%20sort%EF%BC%9BO(nlogn)/</url>
    <content><![CDATA[<p>分治策略：<br>排序&#x3D;递归地排序左半部分+递归地排序右半部分+然后合并排序左右部分</p>
<p><img src="/image/image_7VBF3xLdhf.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 合并左子数组和右子数组 */</span></span><br><span class="line"><span class="comment">// 左子数组区间 [left, mid]</span></span><br><span class="line"><span class="comment">// 右子数组区间 [mid + 1, right]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化辅助数组；把左右子数组拷贝到里面操作</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(nums.begin() + left, nums.begin() + right + <span class="number">1</span>)</span></span>;<span class="comment">//列表初始化是左闭右开区间，而我们的定义是闭区间</span></span><br><span class="line">    <span class="comment">// 左子数组的起始索引和结束索引</span></span><br><span class="line">    <span class="type">int</span> leftStart = left - left, leftEnd = mid - left;</span><br><span class="line">    <span class="comment">// 右子数组的起始索引和结束索引</span></span><br><span class="line">    <span class="type">int</span> rightStart = mid + <span class="number">1</span> - left, rightEnd = right - left;</span><br><span class="line">    <span class="comment">// i, j 分别指向左子数组、右子数组的首元素</span></span><br><span class="line">    <span class="type">int</span> i = leftStart, j = rightStart;</span><br><span class="line">    <span class="comment">// 通过覆盖原数组 nums 来合并左子数组和右子数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = left; k &lt;= right; k++) &#123;</span><br><span class="line">        <span class="comment">// 若“左子数组已全部合并完”，则选取右子数组元素，并且 j++</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; leftEnd)</span><br><span class="line">            nums[k] = tmp[j++];</span><br><span class="line">        <span class="comment">// 否则，若“右子数组已全部合并完”或“左子数组当前最小元素 &lt;= 右子数组当前最小元素”，则选取左子数组元素，并且 i++</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; rightEnd || tmp[i] &lt;= tmp[j])</span><br><span class="line">            nums[k] = tmp[i++];</span><br><span class="line">        <span class="comment">// 否则，若“左右子数组都未全部合并完”且“左子数组元素 &gt; 右子数组元素”，则选取右子数组元素，并且 j++</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nums[k] = tmp[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 归并排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;<span class="comment">//闭区间</span></span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 当子数组长度为 1 时终止递归</span></span><br><span class="line">    <span class="comment">// 划分阶段</span></span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;    <span class="comment">// 计算中点</span></span><br><span class="line">    <span class="built_in">mergeSort</span>(nums, left, mid);      <span class="comment">// 递归左子数组</span></span><br><span class="line">    <span class="built_in">mergeSort</span>(nums, mid + <span class="number">1</span>, right); <span class="comment">// 递归右子数组</span></span><br><span class="line">    <span class="comment">// 合并阶段</span></span><br><span class="line">    <span class="built_in">merge</span>(nums, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度 O(nlog⁡n)、非自适应排序</strong>：划分产生高度为 log⁡n 的递归树，每层合并的总操作数量为 n ，因此总体时间复杂度为 O(nlog⁡n) 。</li>
<li><strong>空间复杂度 O(n)、非原地排序</strong>：递归深度为 log⁡n ，使用 O(log⁡n) 大小的栈帧空间。合并操作需要借助辅助数组实现，使用 O(n) 大小的额外空间。</li>
<li><strong>稳定排序</strong>：在合并过程中，相等元素的次序保持不变。</li>
</ul>
<h2 id="链表排序-¶"><a href="#链表排序-¶" class="headerlink" title="链表排序 *¶"></a>链表排序 *<a href="https://www.hello-algo.com/chapter_sorting/merge_sort/#1163" title="¶">¶</a></h2><p>对于链表，归并排序相较于其他排序算法具有显著优势，<strong>可以将链表排序任务的空间复杂度优化至 �(1)</strong> 。</p>
<ul>
<li><strong>划分阶段</strong>：可以通过使用“迭代”替代“递归”来实现链表划分工作，从而省去递归使用的栈帧空间。</li>
<li><strong>合并阶段</strong>：在链表中，节点增删操作仅需改变引用（指针）即可实现，因此合并阶段（将两个短有序链表合并为一个长有序链表）无须创建额外链表。</li>
</ul>
<p>具体实现细节比较复杂，有兴趣的同学可以查阅相关资料进行学习。</p>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序 quick sort</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%20quick%20sort/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%20quick%20sort/</url>
    <content><![CDATA[<p>分治策略：<br>排序&#x3D;选择一个基准数，数组中比他小的放在左边进行排序+比他大的放在右边进行排序&#x3D;左子数组中选择一个基准数，数组中比他小的放在左边进行排序+比他大的放在右边进行排序。。。。。。。</p>
<p><img src="/image/image_MSe2stfq3w.png"></p>
<h2 id="选择基准数"><a href="#选择基准数" class="headerlink" title="选择基准数"></a>选择基准数</h2><p>事实上随机取一个数作基准数可能会取到最大值&#x2F;最小值；则哨兵排序可能会劣化；在最差情况下，每轮哨兵划分操作都将长度为 n 的数组划分为长度为 0 和 n−1 的两个子数组，此时递归层数达到 n 层，每层中的循环数为 n ，总体使用 O(n^2) 时间。达到最差递归深度 n ，使用 O(n) 栈帧空间;</p>
<p>所以一般在数组中选三个候选元素（通常为数组的首、尾、中点元素）<strong>的中位数作为基准数</strong>。这样基准数“既不太小也不太大”的概率将大幅提升。当然，我们还可以选取更多候选元素，以进一步提高算法的稳健性。采用这种方法后，时间复杂度劣化至 O(n^2) 的概率大大降低</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 选取三个元素的中位数 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">medianThree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此处使用异或运算来简化代码</span></span><br><span class="line">    <span class="comment">// 异或规则为 0 ^ 0 = 1 ^ 1 = 0, 0 ^ 1 = 1 ^ 0 = 1</span></span><br><span class="line">    <span class="keyword">if</span> ((nums[left] &lt; nums[mid]) ^ (nums[left] &lt; nums[right]))</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((nums[mid] &lt; nums[left]) ^ (nums[mid] &lt; nums[right]))</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> right;<span class="comment">//我认为还须优化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>基准数在最左端，初始化两个指针 <code>i</code> 和 <code>j</code> 分别指向数组的两端</li>
<li>设置一个循环，在每轮中使用 <code>i</code>（<code>j</code>）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。</li>
<li>循环执行步骤 <code>2.</code> ，直到 <code>i</code> 和 <code>j</code> 相遇时停止，最后将基准数交换至两个子数组的分界线。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 元素交换 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 哨兵划分（三数取中值） */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;<span class="comment">//O(n)</span></span><br><span class="line">    <span class="comment">// 选取三个候选元素的中位数</span></span><br><span class="line">    <span class="type">int</span> med = <span class="built_in">medianThree</span>(nums, left, (left + right) / <span class="number">2</span>, right);</span><br><span class="line">    <span class="comment">// 将中位数交换至数组最左端</span></span><br><span class="line">    <span class="built_in">swap</span>(nums, left, med);</span><br><span class="line">    <span class="comment">// 以 nums[left] 作为基准数</span></span><br><span class="line">    <span class="type">int</span> i = left, j = right;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= nums[left])</span><br><span class="line">            j--; <span class="comment">// 从右向左找排查对于基准数逆序的元素</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= nums[left])</span><br><span class="line">            i++;          <span class="comment">// 从左向右排查对于基准数逆序的元素</span></span><br><span class="line">        <span class="built_in">swap</span>(nums, i, j); <span class="comment">// 交换这两个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums, i, left); <span class="comment">// 当i=j;左边元素&lt;base&lt;右边元素；base插入i刚刚好；将基准数交换至两子数组的分界线（这里似乎藏bug）</span></span><br><span class="line">    <span class="keyword">return</span> i;            <span class="comment">// 返回基准数的索引</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 快速排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子数组长度为 1 时终止递归</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 哨兵划分,返回基准数索引</span></span><br><span class="line">    <span class="type">int</span> pivot = <span class="built_in">partition</span>(nums, left, right);</span><br><span class="line">    <span class="comment">// 递归左子数组、右子数组</span></span><br><span class="line">    <span class="built_in">quickSort</span>(nums, left, pivot - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(nums, pivot + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="多分支递归优化？？？？？？？"><a href="#多分支递归优化？？？？？？？" class="headerlink" title="多分支递归优化？？？？？？？"></a>多分支递归优化？？？？？？？</h2><p>多分支递归优化的思路是：通过条件判断在每一次只选择一条递归路径，同层非此路径的节点调用都由循环实现</p>
<p><img src="/image/image_mV-_ymsTxq.png"></p>
<p><strong>在某些输入下，快速排序可能占用空间较多</strong>。以完全倒序的输入数组为例，由于每轮哨兵划分后右子数组长度为 0 ，递归树的高度会达到 n−1 ，此时需要占用 O(n) 大小的栈帧空间。</p>
<p>在每轮哨兵排序完成后，比较两个子数组的长度，<strong>仅对较短的子数组进行递归</strong>。由于较短子数组的长度不会超过 n&#x2F;2 ，因此这种方法能确保递归深度不超过 log⁡n ，从而将最差空间复杂度优化至 O(log⁡n) 。??????</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 快速排序（优化） */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子数组长度为 1 时终止</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">// 哨兵划分操作</span></span><br><span class="line">        <span class="type">int</span> pivot = <span class="built_in">partition</span>(nums, left, right);</span><br><span class="line">        <span class="comment">// 对两个子数组中较短的那个执行快排</span></span><br><span class="line">        <span class="keyword">if</span> (pivot - left &lt; right - pivot) &#123;</span><br><span class="line">            <span class="built_in">quickSort</span>(nums, left, pivot - <span class="number">1</span>); <span class="comment">// 递归排序左子数组</span></span><br><span class="line">            left = pivot + <span class="number">1</span>;                 <span class="comment">// 剩余未排序区间为 [pivot + 1, right]</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">quickSort</span>(nums, pivot + <span class="number">1</span>, right); <span class="comment">// 递归排序右子数组</span></span><br><span class="line">            right = pivot - <span class="number">1</span>;                 <span class="comment">// 剩余未排序区间为 [left, pivot - 1]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 快速排序 （未优化）*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子数组长度为 1 时终止递归</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 哨兵划分,返回基准数索引</span></span><br><span class="line">    <span class="type">int</span> pivot = <span class="built_in">partition</span>(nums, left, right);</span><br><span class="line">    <span class="comment">// 递归左子数组、右子数组</span></span><br><span class="line">    <span class="built_in">quickSort</span>(nums, left, pivot - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(nums, pivot + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/image/image_GLw4nLIAFT.png"></p>
<p><img src="/image/image_J_pdt2FUn3.png"></p>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>插入排序 insertion sort</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%20insertion%20sort/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%20insertion%20sort/</url>
    <content><![CDATA[<p>退化分治（子问题存在依赖，先解决前面才能解决后面）<br>排序&#x3D;对前size-1个元素进行排序+把最后一个元素插入数组<br>&#x20;      =对前size-2个元素进行排序+有序插入第size-1个元素+有序插入第size个元素<br>。。。。。<br>&#x20;      =对前2个元素进行排序+。。。+有序插入第size-1个元素+有序插入第size个元素<br>&#x20;      =对前1个元素进行排序+。。。+有序插入第size-1个元素+有序插入第size个元素<br>&#x20;      =有序插入第2个元素。。。+有序插入第size-1个元素+有序插入第size个元素</p>
<ol>
<li>选取数组第 2 个元素作为 <code>base</code> ，将其插入到正确位置后，<strong>数组的前 2 个元素已排序</strong></li>
<li>选取第 3 个元素作为 <code>base</code> ，将其插入到正确位置后，<strong>数组的前 3 个元素已排序</strong></li>
<li>以此类推，在最后一轮中，选取最后一个元素作为 <code>base</code> ，将其插入到正确位置后，<strong>所有元素均已排序</strong></li>
</ol>
<p><img src="https://www.hello-algo.com/chapter_sorting/insertion_sort.assets/insertion_sort_overview.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 插入排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 外循环：已排序元素数量为 1, 2, ..., n；插入元素迭代</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> base = nums[i], j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 内循环：枚举前面已排序区间所有元素，不符合序结构的右移</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; base) &#123;</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j]; <span class="comment">// 将 nums[j] 向右移动一位</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j + <span class="number">1</span>] = base; <span class="comment">// 将 base 赋值到正确位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度 O(n^2)、自适应排序</strong>：最差情况下，每次插入操作分别需要循环 n−1、n−2、…、2、1 次，求和得到 (n−1)n&#x2F;2 ，因此时间复杂度为 O(n^2) 。在遇到有序数据时，插入操作会提前终止。当输入数组完全有序时，插入排序达到最佳时间复杂度 O(n) 。</li>
<li><strong>空间复杂度 O(1)、原地排序</strong>：指针 i 和 j 使用常数大小的额外空间。</li>
<li><strong>稳定排序</strong>：在插入操作过程中，我们会将元素插入到相等元素的右侧，不会改变它们的顺序</li>
</ul>
<p>尽管插入排序的时间复杂度相比快速排序更高，<strong>但在数据量较小的情况下，插入排序通常更快</strong>。</p>
<p>这个结论与线性查找和二分查找的适用情况的结论类似。快速排序这类 O(nlog⁡n) 的算法属于基于分治的排序算法，往往包含更多单元计算操作。而在数据量较小时，n^2 和 nlog⁡n 的数值比较接近，复杂度不占主导作用；每轮中的单元操作数量起到决定性因素。</p>
<p>实际上，许多编程语言（例如 Java）的内置排序函数都采用了插入排序，大致思路为：对于长数组，采用基于分治的排序算法，例如快速排序；对于短数组，直接使用插入排序。</p>
<p>虽然冒泡排序、选择排序和插入排序的时间复杂度都为 O(n^2) ，但在实际情况中，<strong>插入排序的使用频率显著高于冒泡排序和选择排序</strong>，主要有以下原因。</p>
<ul>
<li>冒泡排序基于元素交换实现，需要借助一个临时变量，共涉及 3 个单元操作；插入排序基于元素赋值实现，仅需 1 个单元操作。因此，<strong>冒泡排序的计算开销通常比插入排序更高</strong>。</li>
<li>选择排序在任何情况下的时间复杂度都为 O(n^2) 。<strong>如果给定一组部分有序的数据，插入排序通常比选择排序效率更高</strong>。</li>
<li>选择排序不稳定，无法应用于多级排序。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排列数问题</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E6%8E%92%E5%88%97%E6%95%B0%E9%97%AE%E9%A2%98/%E6%8E%92%E5%88%97%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="零钱兑换问题-II"><a href="#零钱兑换问题-II" class="headerlink" title="零钱兑换问题 II"></a>零钱兑换问题 II</h2><p><img src="/image/image_A4ytwhrcqd.png"></p>
<p>$f(i,a)&#x3D;f(i-1,a)+f(i,a-coins[i-1]);a-coins[i-1]≥coins[i-1]$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 零钱兑换 II：动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChangeIIDP</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;coins, <span class="type">int</span> amt)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(amt + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 初始化首列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>; a &lt;= amt; a++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins[i - <span class="number">1</span>] &gt; a) &#123;</span><br><span class="line">                <span class="comment">// 若超过背包容量，则不选硬币 i</span></span><br><span class="line">                dp[i][a] = dp[i - <span class="number">1</span>][a];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不选和选硬币 i 这两种方案之和</span></span><br><span class="line">                dp[i][a] = dp[i - <span class="number">1</span>][a] + dp[i][a - coins[i - <span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][amt];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 零钱兑换 II：空间优化后的动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChangeIIDPComp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;coins, <span class="type">int</span> amt)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = coins.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amt + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">1</span>; a &lt;= amt; a++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins[i - <span class="number">1</span>] &gt; a) &#123;</span><br><span class="line">                <span class="comment">// 若超过背包容量，则不选硬币 i</span></span><br><span class="line">                dp[a] = dp[a];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不选和选硬币 i 这两种方案之和</span></span><br><span class="line">                dp[a] = dp[a] + dp[a - coins[i - <span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amt];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数组&amp;链表&amp;列表</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84&amp;%E9%93%BE%E8%A1%A8&amp;%E5%88%97%E8%A1%A8/%E6%95%B0%E7%BB%84&amp;%E9%93%BE%E8%A1%A8&amp;%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h2><p><img src="/image/image_ERvdfb9AE7.png"></p>
<h3 id="1-初始化数组O-1"><a href="#1-初始化数组O-1" class="headerlink" title="1.   初始化数组O(1)"></a>1.   初始化数组O(1)</h3><p>数组的两种初始化方式：无初始值、给定初始值。未指定初始值情况下，大多数编程语言会将数组元素初始化为 0&#x20;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化数组 */</span></span><br><span class="line"><span class="comment">// 存储在栈上</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>];<span class="comment">//全局变量则默认初始值为0，局部为随机值</span></span><br><span class="line"><span class="type">int</span> nums[<span class="number">5</span>] &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="comment">// 存储在堆上（需要手动释放空间）</span></span><br><span class="line"><span class="type">int</span>* arr1 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span>* nums1 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>] &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span> &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-访问元素O-1"><a href="#2-访问元素O-1" class="headerlink" title="2.   访问元素O(1)"></a>2.   访问元素O(1)</h3><p>元素被存在连续的内存中；元素地址&#x3D;数组基地址+索引*元素所占字节；</p>
<p><img src="/image/image_dOP0vwYlCz.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> nums[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="type">int</span> randomNum = nums[Index];</span><br></pre></td></tr></table></figure>

<h3 id="3-插入元素O-n"><a href="#3-插入元素O-n" class="headerlink" title="3.   插入元素O(n)"></a>3.   插入元素O(n)</h3><p>在数组中插入一个元素，需将该元素后的所有元素都向后移动一位;对于刚刚好的定长数组，插入一个元素必定会导致数组尾部元素的“丢失”</p>
<p><img src="/image/image_4btvQKR4Fv.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在size个元素的数组的索引 index 处插入元素 num */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> size, <span class="type">int</span> num, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把索引 index 以及之后的所有元素向后移动一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">1</span>; i &gt; index; i--) &#123;</span><br><span class="line">        nums[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 num 赋给 index 处元素</span></span><br><span class="line">    nums[index] = num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-删除元素O-n"><a href="#4-删除元素O-n" class="headerlink" title="4.   删除元素O(n)"></a>4.   删除元素O(n)</h3><p>删除索引i处元素，要把索引i之后的元素都向前移一位。</p>
<p><img src="/image/image_uTOScIPeCL.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 删除索引 index 处元素 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> size, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把索引 index 之后的所有元素向前移动一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        nums[i] = nums[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//O(n)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>数组的插入与删除操作有以下缺点。</p>
<ul>
<li><strong>时间复杂度高</strong>：数组的插入和删除的平均时间复杂度均为 O(n) ，其中 n为数组长度。</li>
<li><strong>丢失元素</strong>：由于数组的长度不可变，因此在插入元素后，超出数组长度范围的元素会丢失。</li>
<li><strong>内存浪费</strong>：我们可以初始化一个比较长的数组，只用前面一部分，这样在插入数据时，丢失的末尾元素都是“无意义”的，但这样做也会造成部分内存空间的浪费。</li>
</ul>
<h3 id="5-遍历数组O-n"><a href="#5-遍历数组O-n" class="headerlink" title="5.   遍历数组O(n)"></a>5.   遍历数组O(n)</h3><p>在大多数编程语言中，我们既可以1）通过索引遍历数组，也可以2）循环遍历<br>遍历：逐个获取数据结构中的元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 遍历数组 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 通过索引遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-查找元素O-n"><a href="#6-查找元素O-n" class="headerlink" title="6.   查找元素O(n)"></a>6.   查找元素O(n)</h3><p>遍历数组，每轮判断元素值是否匹配，若匹配则输出对应索引。<br>因为数组是线性数据结构，所以上述查找操作被称为“线性查找”。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在数组中查找指定元素 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> size, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == target)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="7-扩容数组O-n"><a href="#7-扩容数组O-n" class="headerlink" title="7.   扩容数组O(n)"></a>7.   扩容数组O(n)</h3><p>1)建立新的更大的数组2)原数组元素<strong>依次拷贝到新数组</strong>。这是一个O(n) 操作，在数组很大的情况下是非常耗时</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 扩展数组长度 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">extend</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> size, <span class="type">int</span> enlarge)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化一个扩展长度后的数组</span></span><br><span class="line">    <span class="type">int</span>* res = <span class="keyword">new</span> <span class="type">int</span>[size + enlarge];</span><br><span class="line">    <span class="comment">// 将原数组中的所有元素复制到新数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        res[i] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">delete</span>[] nums;</span><br><span class="line">    <span class="comment">// 返回扩展后的新数组</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="链表-linked-list"><a href="#链表-linked-list" class="headerlink" title="链表 linked list"></a><strong>链表</strong> linked list</h2><p>线性数据结构，每个元素都是一个节点对象，各节点通过“引用”访问下个节点。引用记录了下个节点的内存地址；在相同数据量下，<strong>链表比数组占用更多的内存空间</strong>。</p>
<p>各节点可被分散存储在内存各处，内存地址无须连续</p>
<p><img src="/image/image_dt72ITtQJu.png"></p>
<p>「节点 node」对象包含两项数据：节点的“值”和指向下一节点的“引用”</p>
<ul>
<li>链表的首个节点被称为“头节点”，最后一个节点被称为“尾节点”。</li>
<li>尾节点指向的是“空”，它在 Java、C++ 和 Python 中分别被记为 null、nullptr 和 None 。</li>
<li>在 C、C++、Go 和 Rust 等支持指针的语言中，上述的“引用”应被替换为“指针”。</li>
</ul>
<p>常见的链表类型包括三种:</p>
<ul>
<li><strong>单向链表</strong>：单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点称为尾节点，尾节点指向空 None 。</li>
<li><strong>环形链表</strong>：如果我们令单向链表的尾节点指向头节点（即首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。</li>
<li><strong>双向链表</strong>：与单向链表相比，双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）。相较于单向链表，双向链表更具灵活性，可以朝<strong>两个方向遍历链表</strong>，但相应地也需要占用更多的内存空间。</li>
</ul>
<p><img src="/image/image_-ip8G7Q5wD.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 单链表节点结构体 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;         <span class="comment">// 节点值</span></span><br><span class="line">    ListNode *next;  <span class="comment">// 指向下一节点的指针</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;  <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 双向链表节点结构体 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;         <span class="comment">// 节点值</span></span><br><span class="line">    ListNode *next;  <span class="comment">// 指向后继节点的指针</span></span><br><span class="line">    ListNode *prev;  <span class="comment">// 指向前驱节点的指针</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>), <span class="built_in">prev</span>(<span class="literal">nullptr</span>) &#123;&#125;  <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-初始化链表"><a href="#1-初始化链表" class="headerlink" title="1.   初始化链表"></a>1.   初始化链表</h3><p>1）初始化各节点对象<br>2）构建引用指向关系。从头节点出发，通过引用指向 <code>next</code> 依次访问所有节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化链表 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */</span></span><br><span class="line"><span class="comment">// 初始化各个节点</span></span><br><span class="line">ListNode* n0 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">ListNode* n1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">ListNode* n2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">ListNode* n3 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>);</span><br><span class="line">ListNode* n4 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 构建引用指向</span></span><br><span class="line">n0-&gt;next = n1;</span><br><span class="line">n1-&gt;next = n2;</span><br><span class="line">n2-&gt;next = n3;</span><br><span class="line">n3-&gt;next = n4;</span><br><span class="line"><span class="comment">//通常将头节点当作链表代称，比如以上代码中的链表可被记做链表 n0</span></span><br></pre></td></tr></table></figure>

<h3 id="2-插入节点O-1"><a href="#2-插入节点O-1" class="headerlink" title="2.   插入节点O(1)"></a>2.   插入节点O(1)</h3><p>在相邻的两个节点 <code>n0</code> 和 <code>n1</code> 之间插入一个新节点 <code>P</code> ，<strong>则只需要改变两个节点引用（指针）即可</strong></p>
<p><img src="/image/image_m1VP6XJJXN.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在链表的节点 n0 之后插入节点 P */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(ListNode *n0, ListNode *P)</span> </span>&#123;</span><br><span class="line">    P-&gt;next = n0-&gt;next;<span class="comment">//将n1地址给p-&gt;next</span></span><br><span class="line">    n0-&gt;next = P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-删除节点O-1"><a href="#3-删除节点O-1" class="headerlink" title="3.   删除节点O(1)"></a>3.   删除节点O(1)</h3><p><strong>改变一个节点的引用（指针）即可</strong>。</p>
<p>在删除操作完成后节点 <code>P</code> 仍然指向 <code>n1</code> ，但实际上遍历此链表已经无法访问到 <code>P</code> ，这意味着 <code>P</code> 已经不再属于该链表了。</p>
<p><img src="https://www.hello-algo.com/chapter_array_and_linkedlist/linked_list.assets/linkedlist_remove_node.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 删除链表的节点 n0 之后的首个节点 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(ListNode *n0)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n0-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// n0 -&gt; P -&gt; n1</span></span><br><span class="line">    ListNode *P = n0-&gt;next;</span><br><span class="line">    n0-&gt;next = P-&gt;next;</span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">delete</span> P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-访问节点O-n"><a href="#4-访问节点O-n" class="headerlink" title="4.   访问节点O(n)"></a>4.   访问节点O(n)</h3><p>从头节点出发，逐个向后遍历，直至找到目标节点。也就是说，访问链表的第i个节点需要循环i-1轮才能返回索引i的元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 访问链表中索引为 index 的节点 */</span></span><br><span class="line"><span class="function">ListNode *<span class="title">access</span><span class="params">(ListNode *head, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-查找节点"><a href="#5-查找节点" class="headerlink" title="5.   查找节点"></a>5.   查找节点</h3><p>遍历链表，查找链表内值为 <code>target</code> 的节点，输出节点在链表中的索引。此过程也属于线性查找。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在链表中查找值为 target 的首个节点 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(ListNode *head, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val == target)</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;<span class="comment">//之所以是while,是因为不知道输入的遍历规模n</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="列表list（动态-变长数组）dynamic-array"><a href="#列表list（动态-变长数组）dynamic-array" class="headerlink" title="列表list（动态&#x2F;变长数组）dynamic array"></a>列表list（动态&#x2F;变长数组）dynamic array</h2><p>实际中，可能事先无法确定需要存储多少数据，使定长数组size选定困难。若长度过小，需要在持续添加数据时频繁扩容数组；若长度过大，则会造成内存空间的浪费。</p>
<p>动态数组可在程序运行过程中动态扩容。并在列表中自由地添加元素，而无须担心超过容量限制。</p>
<h3 id="1-初始化列表"><a href="#1-初始化列表" class="headerlink" title="1.   初始化列表"></a>1.   初始化列表</h3><p>我们通常使用“无初始值”和“有初始值”这两种初始化方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化列表 */</span></span><br><span class="line"><span class="comment">// 需注意，C++ 中 vector 即是本文描述的 list</span></span><br><span class="line"><span class="comment">// 无初始值</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; list1;</span><br><span class="line"><span class="comment">// 有初始值</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; list = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span> &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-访问元素O-1-1"><a href="#2-访问元素O-1-1" class="headerlink" title="2.   访问元素O(1)"></a>2.   访问元素O(1)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 访问元素 */</span></span><br><span class="line"><span class="type">int</span> num = list[<span class="number">1</span>];  <span class="comment">// 访问索引 1 处的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更新元素 */</span></span><br><span class="line">list[<span class="number">1</span>] = <span class="number">0</span>;  <span class="comment">// 将索引 1 处的元素更新为 0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-插入与删除元素"><a href="#3-插入与删除元素" class="headerlink" title="3.   插入与删除元素"></a>3.   插入与删除元素</h3><p>相较于数组，列表可自由添加删除元素。在列表尾部添加元素的时间复杂度为O(1)，但插入和删除元素的效率仍与数组相同，时间复杂度为O(index)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 清空列表 */</span></span><br><span class="line">list.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 尾部添加元素 */</span></span><br><span class="line">list.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">list.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">list.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">list.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">list.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中间插入元素 */</span></span><br><span class="line">list.<span class="built_in">insert</span>(list.<span class="built_in">begin</span>() + <span class="number">3</span>, <span class="number">6</span>);  <span class="comment">// 在索引 3 处插入数字 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除元素 */</span></span><br><span class="line">list.<span class="built_in">erase</span>(list.<span class="built_in">begin</span>() + <span class="number">3</span>);      <span class="comment">// 删除索引 3 处的元素</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-遍历列表O-size"><a href="#4-遍历列表O-size" class="headerlink" title="4.   遍历列表O(size)"></a>4.   遍历列表O(size)</h3><p>与数组一样，列表可以根据索引遍历（适合随机访问），也可以直接遍历（适合顺序访问操作）各元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 通过索引遍历列表 */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; list.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="comment">//对list[i]操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 直接遍历列表元素 */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n : list) &#123;</span><br><span class="line">    <span class="comment">//直接对n操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-拼接列表"><a href="#5-拼接列表" class="headerlink" title="5.   拼接列表"></a>5.   拼接列表</h3><p>给定一个新列表 <code>list1</code> ，我们可以将该列表拼接到原列表的尾部。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 拼接两个列表 */</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; list1 = &#123; <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="comment">// 将列表 list1 拼接到 list 之后</span></span><br><span class="line">list.<span class="built_in">insert</span>(list.<span class="built_in">end</span>(), list1.<span class="built_in">begin</span>(), list1.<span class="built_in">end</span>());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-排序列表"><a href="#6-排序列表" class="headerlink" title="6.   排序列表"></a>6.   排序列表</h3><p>完成列表排序后，我们便可以使用在数组类算法题中经常考察的“二分查找”和“双指针”算法。?????</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 排序列表 */</span></span><br><span class="line"><span class="built_in">sort</span>(list.<span class="built_in">begin</span>(), list.<span class="built_in">end</span>());  <span class="comment">// 排序后，列表元素从小到大排列</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="列表实现"><a href="#列表实现" class="headerlink" title="列表实现"></a>列表实现</h3><p>许多编程语言都提供内置的列表，例如 Java、C++、Python 等。它们的实现比较复杂，各个参数的设定也非常有考究，例如初始容量、扩容倍数等。感兴趣可以查阅源码进行学习。</p>
<p>为了加深对列表工作原理的理解，我们尝试实现一个简易版列表，包括以下三个重点设计。</p>
<ul>
<li><strong>初始容量</strong>：选取一个合理的数组初始容量。在本示例中，我们选择 10 作为初始容量。</li>
<li><strong>数量记录</strong>：声明一个变量 size，用于记录列表当前元素数量，并随着元素插入和删除实时更新。根据此变量，我们可以定位列表尾部，以及判断是否需要扩容。</li>
<li><strong>扩容机制</strong>：若插入元素时列表容量已满，则需要进行扩容。首先根据扩容倍数创建一个更大的数组，再将当前数组的所有元素依次移动至新数组。在本示例中，我们规定每次将数组扩容至之前的 2 倍。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 列表类简易实现 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *nums;             <span class="comment">// 数组（存储列表元素）</span></span><br><span class="line">    <span class="type">int</span> numsCapacity = <span class="number">10</span>; <span class="comment">// 列表容量</span></span><br><span class="line">    <span class="type">int</span> numsSize = <span class="number">0</span>;      <span class="comment">// 列表长度（即当前元素数量）</span></span><br><span class="line">    <span class="type">int</span> extendRatio = <span class="number">2</span>;   <span class="comment">// 每次列表扩容的倍数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="built_in">MyList</span>() &#123;</span><br><span class="line">        nums = <span class="keyword">new</span> <span class="type">int</span>[numsCapacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 析构方法 */</span></span><br><span class="line">    ~<span class="built_in">MyList</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取列表长度（即当前元素数量）*/</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numsSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取列表容量 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numsCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 索引如果越界则抛出异常，下同</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;索引越界&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> nums[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新元素 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;索引越界&quot;</span>);</span><br><span class="line">        nums[index] = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 尾部添加元素 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 元素数量超出容量时，触发扩容机制</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span>() == <span class="built_in">capacity</span>())</span><br><span class="line">            <span class="built_in">extendCapacity</span>();</span><br><span class="line">        nums[<span class="built_in">size</span>()] = num;</span><br><span class="line">        <span class="comment">// 更新元素数量</span></span><br><span class="line">        ++numsSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 中间插入元素 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;索引越界&quot;</span>);</span><br><span class="line">        <span class="comment">// 元素数量超出容量时，触发扩容机制</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span>() == <span class="built_in">capacity</span>())</span><br><span class="line">            <span class="built_in">extendCapacity</span>();</span><br><span class="line">        <span class="comment">// 将索引 index 以及之后的元素都向后移动一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= index; j--) &#123;</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[index] = num;</span><br><span class="line">        <span class="comment">// 更新元素数量</span></span><br><span class="line">        numsSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;索引越界&quot;</span>);</span><br><span class="line">        <span class="type">int</span> num = nums[index];</span><br><span class="line">        <span class="comment">// 索引 i 之后的元素都向前移动一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = index; j &lt; <span class="built_in">size</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新元素数量</span></span><br><span class="line">        numsSize--;</span><br><span class="line">        <span class="comment">// 返回被删除元素</span></span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 列表扩容 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">extendCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建一个长度为原数组 extendRatio 倍的新数组</span></span><br><span class="line">        <span class="type">int</span> newCapacity = <span class="built_in">capacity</span>() * extendRatio;</span><br><span class="line">        <span class="type">int</span> *tmp = nums;</span><br><span class="line">        nums = <span class="keyword">new</span> <span class="type">int</span>[newCapacity];</span><br><span class="line">        <span class="comment">// 将原数组中的所有元素复制到新数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            nums[i] = tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        <span class="keyword">delete</span>[] tmp;</span><br><span class="line">        numsCapacity = newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将列表转换为 Vector 用于打印 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">toVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 仅转换有效长度范围内的列表元素</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            vec[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="数组-链表-列表应用场景"><a href="#数组-链表-列表应用场景" class="headerlink" title="数组&amp;链表&amp;列表应用场景"></a>数组&amp;链表&amp;列表应用场景</h2><ul>
<li>数组支持随机访问、占用内存较少；但插入和删除元素效率低，且初始化后长度不可变。</li>
<li>链表通过更改引用（指针）实现高效的节点插入与删除，且可以灵活调整长度；但节点访问效率低、占用内存较多</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>数组</th>
<th>linkednode</th>
<th>list</th>
</tr>
</thead>
<tbody><tr>
<td>存储方式</td>
<td>连续空间存储</td>
<td>离散空间存储</td>
<td>离散空间存储</td>
</tr>
<tr>
<td>缓存局部性</td>
<td><strong>访问数组元素时，不仅加载访问的元素，还会缓存其周围的数据</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>容量灵活性</td>
<td>定长；扩容O(n)</td>
<td><strong>可灵活扩展结点</strong></td>
<td><strong>变长</strong></td>
</tr>
<tr>
<td>内存效率</td>
<td><strong>占内存少,可能有空间浪费</strong></td>
<td>占内存多</td>
<td><strong>占内存少,可能有空间浪费</strong></td>
</tr>
<tr>
<td>访问元素</td>
<td><strong>支持随机访问O(1)</strong></td>
<td>逐个向后遍历index-1个元素O(n)</td>
<td><strong>支持随机访问O(1)</strong></td>
</tr>
<tr>
<td>增删元素</td>
<td>O(n)</td>
<td><strong>O(1)</strong></td>
<td>O(n)</td>
</tr>
</tbody></table>
<p>结论：<br>1）数组空间效率高，无须额外的结构开销;但可能会有空间浪费<br>2）数组<strong>支持</strong>O(1)的<strong>随机访问</strong>；链表的数据访问包含遍历操作O(n)<br>3）链表增删数据效率高O(1)；数组增删要移动大量元素O(n)<br>4)  数组扩容要进行数据拷贝，开销很大O(n);</p>
<h3 id="数组典型应用"><a href="#数组典型应用" class="headerlink" title="数组典型应用"></a>数组典型应用</h3><ul>
<li><strong>随机访问</strong>：如果我们想要随机抽取一些样本，那么可以用数组存储，并生成一个随机序列，根据索引实现样本的随机抽取。</li>
<li><strong>排序和搜索</strong>：数组是排序和搜索算法最常用的数据结构。快速排序、归并排序、二分查找等都主要在数组上进行。</li>
<li><strong>查找表</strong>：当我们需要快速查找一个元素或者需要查找一个元素的对应关系时，可以使用数组作为查找表。假如我们想要实现字符到 ASCII 码的映射，则可以将字符的 ASCII 码值作为索引，对应的元素存放在数组中的对应位置。</li>
<li><strong>机器学习</strong>：神经网络中大量使用了向量、矩阵、张量之间的线性代数运算，这些数据都是以数组的形式构建的。数组是神经网络编程中最常使用的数据结构。</li>
<li><strong>数据结构实现</strong>：数组可以用于实现栈、队列、哈希表、堆、图等数据结构。例如，图的邻接矩阵表示实际上是一个二维数组。</li>
</ul>
<h3 id="链表典型应用"><a href="#链表典型应用" class="headerlink" title="链表典型应用"></a>链表典型应用</h3><p>单向链表通常用于实现栈、队列、哈希表和图等数据结构。</p>
<ul>
<li><strong>栈与队列</strong>：当插入和删除操作都在链表的一端进行时，它表现出先进后出的的特性，对应栈；当插入操作在链表的一端进行，删除操作在链表的另一端进行，它表现出先进先出的特性，对应队列。</li>
<li><strong>哈希表</strong>：链地址法是解决哈希冲突的主流方案之一，在该方案中，所有冲突的元素都会被放到一个链表中。</li>
<li><strong>图</strong>：邻接表是表示图的一种常用方式，在其中，图的每个顶点都与一个链表相关联，链表中的每个元素都代表与该顶点相连的其他顶点。</li>
</ul>
<p>双向链表常被用于需要快速查找前一个和下一个元素的场景。</p>
<ul>
<li><strong>高级数据结构</strong>：比如在红黑树、B 树中，我们需要访问节点的父节点，这可以通过在节点中保存一个指向父节点的引用来实现，类似于双向链表。</li>
<li><strong>浏览器历史</strong>：在网页浏览器中，当用户点击前进或后退按钮时，浏览器需要知道用户访问过的前一个和后一个网页。双向链表的特性使得这种操作变得简单。</li>
<li><strong>LRU 算法</strong>：在缓存淘汰算法（LRU）中，我们需要快速找到最近最少使用的数据，以及支持快速地添加和删除节点。这时候使用双向链表就非常合适。</li>
</ul>
<p>循环链表常被用于需要周期性操作的场景，比如操作系统的资源调度。</p>
<ul>
<li><strong>时间片轮转调度算法</strong>：在操作系统中，时间片轮转调度算法是一种常见的 CPU 调度算法，它需要对一组进程进行循环。每个进程被赋予一个时间片，当时间片用完时，CPU 将切换到下一个进程。这种循环的操作就可以通过循环链表来实现。</li>
<li><strong>数据缓冲区</strong>：在某些数据缓冲区的实现中，也可能会使用到循环链表。比如在音频、视频播放器中，数据流可能会被分成多个缓冲块并放入一个循环链表，以便实现无缝播放。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>暴力搜索/记忆搜索最优化问题</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2-%E8%AE%B0%E5%BF%86%E6%90%9C%E7%B4%A2%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2-%E8%AE%B0%E5%BF%86%E6%90%9C%E7%B4%A2%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><img src="/image/image_MCjvdOPQZK.png"></p>
<p><img src="/image/image_iyV-seswh7.png"></p>
<p>分治策略：求$[0,0]→[i,j]$的最小路径和<br>1）状态转移方程：$f(i,j)&#x3D;min{f(i-1,j),f(i,j-1)}+grid(i,j)$<br>2)边界条件：</p>
<ol>
<li>i&#x3D;0&amp;&amp;j&#x3D;0；最小子问题为$f(0，0)$</li>
<li>i,j≥0;越界约束；剪枝约束函数$f(i&lt;0,j&lt;0)&#x3D;+∞$</li>
</ol>
<h1 id="暴力搜索"><a href="#暴力搜索" class="headerlink" title="暴力搜索"></a>暴力搜索</h1><p><img src="/image/image_IoulF5xzbW.png"></p>
<p>可见暴力搜索要<strong>递归生成完整状态树求出最小子结构的解逐级返回合并成原问题的解</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 最小路径和：暴力搜索 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minPathSumDFS</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若为左上角单元格，则终止搜索</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若行列索引越界，则返回 +∞ 代价</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> INT_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算从左上角到 (i-1, j) 和 (i, j-1) 的最小路径代价</span></span><br><span class="line">    <span class="type">int</span> left = <span class="built_in">minPathSumDFS</span>(grid, i - <span class="number">1</span>, j);</span><br><span class="line">    <span class="type">int</span> up = <span class="built_in">minPathSumDFS</span>(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 返回从左上角到 (i, j) 的最小路径代价</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(left, up) != INT_MAX ? <span class="built_in">min</span>(left, up) + grid[i][j] : INT_MAX;</span><br><span class="line">&#125;<span class="comment">//O(2^(m+n))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h1><p><img src="/image/image_ssdW7cV9h9.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 最小路径和：记忆化搜索 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minPathSumDFSMem</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;mem, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若为左上角单元格，则终止搜索</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若行列索引越界，则返回 +∞ 代价</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> INT_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若已有记录，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (mem[i][j] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mem[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左边和上边单元格的最小路径代价</span></span><br><span class="line">    <span class="type">int</span> left = <span class="built_in">minPathSumDFSMem</span>(grid, mem, i - <span class="number">1</span>, j);</span><br><span class="line">    <span class="type">int</span> up = <span class="built_in">minPathSumDFSMem</span>(grid, mem, i, j - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 记录并返回左上角到 (i, j) 的最小路径代价</span></span><br><span class="line">    mem[i][j] = <span class="built_in">min</span>(left, up) != INT_MAX ? <span class="built_in">min</span>(left, up) + grid[i][j] : INT_MAX;</span><br><span class="line">    <span class="keyword">return</span> mem[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引入记忆化后，所有子问题的解只需计算一次，因此时间复杂度取决于状态总数，即网格尺寸 O(nm)</p>
<p><img src="/image/image_7TTi1_8P7x.png"></p>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>暴力搜索/生成h元组合（分量有序结构）</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2-%E7%94%9F%E6%88%90h%E5%85%83%E7%BB%84%E5%90%88%EF%BC%88%E5%88%86%E9%87%8F%E6%9C%89%E5%BA%8F%E7%BB%93%E6%9E%84%EF%BC%89/%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2-%E7%94%9F%E6%88%90h%E5%85%83%E7%BB%84%E5%90%88%EF%BC%88%E5%88%86%E9%87%8F%E6%9C%89%E5%BA%8F%E7%BB%93%E6%9E%84%EF%BC%89/</url>
    <content><![CDATA[<p>多叉树每层存储的都是分量，枚举h元组合<br>1）排列问题：枚举h维向量所有可能（分量有序结构，有序对）<br>2）组合问题：枚举h个分量的无序对所有可能（分量无序结构，无序对）<br>3）<strong>避免无效搜索：</strong> 若含约束条件，（1）用约束函数剪去不满足约束的子树；（2）用限界函数剪去得不到最优解的子树。</p>
<p>回溯策略：遍历所有h元组合所有可能<br>1）求出问题的解空间<br>2）声明3个容器：<br>1.<strong>路径</strong>：问题的解在搜索过程中动态产生<br>2.分量选择列表 **：当前可选择<strong>的分量<br>3.符合约束条件的解<br>3）从解空间树根结点出发，以深度优先搜索方式搜索解空间（h轮迭代选取第一个分量，h-1轮迭代选取第二个分量。。。。每轮选取结束后递归开启下轮迭代），直至到</strong>达决策树底层，⽆法再做选择的条件 **；<br>搜索过程中，若判断出某子树不包含问题的解，则跳过对该子树解子空间的生成</p>
<p><img src="/image/image_G2ijhCuyIH.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 回溯算法框架 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(State *state, vector&lt;Choice *&gt; &amp;choices, vector&lt;State *&gt; &amp;res)</span> </span>&#123;<span class="comment">//遍历路径，值，搜索到的结果</span></span><br><span class="line">    <span class="comment">// 判断是否为解</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isSolution</span>(state)) &#123;</span><br><span class="line">        <span class="comment">// 记录解</span></span><br><span class="line">        <span class="built_in">recordSolution</span>(state, res);</span><br><span class="line">        <span class="comment">// 停止继续搜索</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历当前可选分量</span></span><br><span class="line">    <span class="keyword">for</span> (Choice choice : choices) &#123;</span><br><span class="line">        <span class="comment">// 剪枝：判断选择是否合法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isValid</span>(state, choice)) &#123;</span><br><span class="line">            <span class="comment">// 尝试：做出选择，更新状态</span></span><br><span class="line">            <span class="built_in">makeChoice</span>(state, choice);</span><br><span class="line">            <span class="built_in">backtrack</span>(state, choices, res);</span><br><span class="line">            <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">            <span class="built_in">undoChoice</span>(state, choice);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="排列（分量集不含相同元素）"><a href="#排列（分量集不含相同元素）" class="headerlink" title="排列（分量集不含相同元素）"></a>排列（分量集不含相同元素）</h2><p><img src="/image/image_Pq5ln2FlqS.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 回溯算法：全排列 I */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;state, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;choices, vector&lt;<span class="type">bool</span>&gt; &amp;selected, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span> </span>&#123;<span class="comment">//遍历分量，多叉树数组，搜索到的结果</span></span><br><span class="line">    <span class="comment">// 当状态长度等于元素数量时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (state.<span class="built_in">size</span>() == choices.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(state);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有可选分量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; choices.<span class="built_in">size</span>(); i++) &#123;<span class="comment">//相当于一个区间缩小机制</span></span><br><span class="line">        <span class="type">int</span> choice = choices[i];</span><br><span class="line">        <span class="comment">// 剪枝：不允许重复选择元素 且 不允许重复选择相等元素</span></span><br><span class="line">        <span class="keyword">if</span> (!selected[i]) &#123;</span><br><span class="line">            <span class="comment">// 尝试：做出选择，更新状态</span></span><br><span class="line">            selected[i] = <span class="literal">true</span>;</span><br><span class="line">            state.<span class="built_in">push_back</span>(choice);</span><br><span class="line">            <span class="comment">// 进行下一轮选择</span></span><br><span class="line">            <span class="built_in">backtrack</span>(state, choices, selected, res);</span><br><span class="line">            <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">            selected[i] = <span class="literal">false</span>;</span><br><span class="line">            state.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全排列 I */</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permutationsI</span>(vector&lt;<span class="type">int</span>&gt; nums) &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; state;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">selected</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">backtrack</span>(state, nums, selected, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="排列（分量集含相同元素）"><a href="#排列（分量集含相同元素）" class="headerlink" title="排列（分量集含相同元素）"></a>排列（分量集含相同元素）</h2><p><img src="/image/image_Poh3RtLCFC.png"></p>
<p>去除重复排列：最直接地，考虑借助一个哈希表，直接对排列结果进行去重（不优雅，要多维护一个哈希表）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">arrSame</span><span class="params">(arrSame)</span></span>&#123;</span><br><span class="line">        var hash = &#123;&#125;;</span><br><span class="line">        var result = [];</span><br><span class="line">        <span class="keyword">for</span>(var i = <span class="number">0</span>, len = arrSame.length;i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!hash[arrSame[i]])&#123;</span><br><span class="line">                result.<span class="built_in">push</span>(arrSame[i]);</span><br><span class="line">                hash[arrSame[i]] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>生成重复排列的搜索分支是没必要的，应当被提前识别并剪枝</strong>，这样可以进一步提升算法效率。</p>
<p><img src="/image/image_OfNHksg3a4.png"></p>
<p>在每轮分量选择中开启一个哈希表 <code>duplicated</code> ，标记该轮中已经尝试过的元素，并将重复元素剪枝，使得每个分量位置上的值只能出现一次</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 回溯算法：全排列 II */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;state, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;choices, vector&lt;<span class="type">bool</span>&gt; &amp;selected, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当状态长度等于元素数量时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (state.<span class="built_in">size</span>() == choices.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(state);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有选择</span></span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; duplicated;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; choices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> choice = choices[i];</span><br><span class="line">        <span class="comment">// 剪枝：不允许重复选择元素 且 不允许重复选择相等元素</span></span><br><span class="line">        <span class="keyword">if</span> (!selected[i] &amp;&amp; duplicated.<span class="built_in">find</span>(choice) == duplicated.<span class="built_in">end</span>()) &#123;<span class="comment">//若choice键值存在，返回一个指向该key的迭代器；若不存在，返回map最后元素后一位</span></span><br><span class="line">            <span class="comment">// 尝试：做出选择，更新状态</span></span><br><span class="line">            duplicated.<span class="built_in">emplace</span>(choice); <span class="comment">// 记录选择过的元素值</span></span><br><span class="line">            selected[i] = <span class="literal">true</span>;</span><br><span class="line">            state.<span class="built_in">push_back</span>(choice);</span><br><span class="line">            <span class="comment">// 进行下一轮选择</span></span><br><span class="line">            <span class="built_in">backtrack</span>(state, choices, selected, res);</span><br><span class="line">            <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">            selected[i] = <span class="literal">false</span>;</span><br><span class="line">            state.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全排列 II */</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permutationsII</span>(vector&lt;<span class="type">int</span>&gt; nums) &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; state;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">selected</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">backtrack</span>(state, nums, selected, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假设元素两两互不相同，则 n 个元素共有 n! 种排列；在记录结果时，需要复制长度为 n 的列表，使用 O(n) 时间。<strong>因此时间复杂度为 O(n!n)</strong>&#x20;</p>
<p>最大递归深度为 n ，使用O(n) 栈帧空间。<code>selected</code> 使用 O(n) 空间。同一时刻最多共有 n 个 <code>duplicated</code> ，使用 O(n^2) 空间。**因此空间复杂度为 **O(n^2) ???</p>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最大容量问题</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E6%9C%80%E5%A4%A7%E5%AE%B9%E9%87%8F%E9%97%AE%E9%A2%98/%E6%9C%80%E5%A4%A7%E5%AE%B9%E9%87%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><img src="/image/image_0YCu2p8saQ.png"></p>
<p><img src="/image/image_b8hfdwa5AY.png"></p>
<p>(i,j)组合，分量集有n个元素</p>
<p>贪心策略：把问题的求解变成一种多轮决策问题：边界指针（i，j）进行多轮最优移动；</p>
<p>$选取一个状态[i,j];使i&lt;j且h(i)&lt;h(j)；左边短板$</p>
<p><img src="/image/image_v-r5Dx0bfc.png"></p>
<p>此时进行最多n-1轮决策：每轮使指针进行一次向内单位距离移动；在不知道各板高度的情况下；短板内移相比于长板内移是更佳决策；因为更有可能在宽度-1的情况下使高度min(h(i),h(j))提高</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 最大容量：贪心 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxCapacity</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;ht)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 i, j 分列数组两端</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = ht.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 初始最大容量为 0</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环贪心选择，直至两板相遇</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">// 更新最大容量</span></span><br><span class="line">        <span class="type">int</span> cap = <span class="built_in">min</span>(ht[i], ht[j]) * (j - i);</span><br><span class="line">        res = <span class="built_in">max</span>(res, cap);</span><br><span class="line">        <span class="comment">// 向内移动短板</span></span><br><span class="line">        <span class="keyword">if</span> (ht[i] &lt; ht[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h3><p>之所以贪心比穷举更快，是因为每轮的贪心选择都会“跳过”一些状态。</p>
<p>比如在状态 cap[i,j] 下，i 为短板、j 为长板。若贪心地将短板 j 向内移动一格，会导致分量i的某些状态被“跳过”。<strong>这意味着之后无法验证这些状态的容量大小</strong>。</p>
<p><img src="/image/image_7KL8tA5BXy.png"></p>
<p><img src="https://www.hello-algo.com/chapter_greedy/max_capacity_problem.assets/max_capacity_skipped_states.png"></p>
<p>观察发现，<strong>这些被跳过的状态实际上就是将长板 � 向内移动的所有状态</strong>。而在第二步中，我们已经证明内移长板一定会导致容量变小。也就是说，被跳过的状态都不可能是最优解，<strong>跳过它们不会导致错过最优解</strong>。？？？？？？</p>
<p>以上的分析说明，<strong>移动短板的操作是“安全”的</strong>，贪心策略是有效的。</p>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最大切分乘积问题</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E6%9C%80%E5%A4%A7%E5%88%87%E5%88%86%E4%B9%98%E7%A7%AF%E9%97%AE%E9%A2%98/%E6%9C%80%E5%A4%A7%E5%88%87%E5%88%86%E4%B9%98%E7%A7%AF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><img src="/image/image_HBpsG40_BK.png"></p>
<p><img src="/image/image_sGckQSGxkr.png"></p>
<p>任何正整数都是1，2，3的乘积；意味着应该将n切成若干的123的乘积⇒23的乘积；其中3的乘积更优（累乘更大）；2的乘积总能转化为3的乘积加余数123更优（3个2&#x3D;2个3）</p>
<p>贪心策略：<br>1）1次决策：n的最优分法为n&#x3D;3a+b<br>2)返回(3^a)*b;b不为0<br>优化：当余数为 1 时，将一对 1 * 3 转化为 2 * 2<br>当 n &lt;&#x3D; 3 时；返回1or2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 最大切分乘积：贪心 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProductCutting</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当 n &lt;= 3 时，必须切分出一个 1</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> * (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 贪心地切分出 3 ，a 为 3 的个数，b 为余数</span></span><br><span class="line">    <span class="type">int</span> a = n / <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> b = n % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 当余数为 1 时，将一对 1 * 3 转化为 2 * 2</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">3</span>, a - <span class="number">1</span>) * <span class="number">2</span> * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 当余数为 2 时，不做处理</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">3</span>, a) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当余数为 0 时，不做处理</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)<span class="built_in">pow</span>(<span class="number">3</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/image/image_xxSZzl72Df.png"></p>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>构建二叉树</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p><strong>层次数据结构的数据表设计</strong></p>
<p><a href="https://zhuanlan.zhihu.com/p/350369570" title="层次数据结构的数据表设计 层次数据结构的数据表设计存储树形结构数据是一个常见的问题，同时也有多种解决方案。 这里介绍三种树形结构的表设计方案： 邻接表模型基于路径和层级的表设计基于左右值编码的表设计（MPT）这里以一个在线食品店… https://zhuanlan.zhihu.com/p/350369570">层次数据结构的数据表设计 层次数据结构的数据表设计存储树形结构数据是一个常见的问题，同时也有多种解决方案。 这里介绍三种树形结构的表设计方案： 邻接表模型基于路径和层级的表设计基于左右值编码的表设计（MPT）这里以一个在线食品店… https://zhuanlan.zhihu.com/p/350369570</a></p>
<p><img src="/image/image_KTWShqQO-i.png"></p>
<p>二叉树的底层实现是数组；能以3种顺序把一棵二叉树放进数组；分别是<br>1）preorder前序：中左右<br>2）inorder中序：左中右<br>3）后序：左右中<br>自然的，遍历数组就是所谓的二叉树3序遍历dfs；</p>
<p><img src="/image/image_VWIez9GyYo.png"></p>
<p>分治策略构建：前序排列的数组构建树&#x3D;<br>1）构建根节点<br>2）构建左子树+构建右子树</p>
<p><img src="/image/image_w-yHtlk8BX.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 构建二叉树：分治 */</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;preorder, unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;inorderMap, <span class="type">int</span> i, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;<span class="comment">//i是起点索引</span></span><br><span class="line">    <span class="comment">// 子树区间为空null时终止,（r+1-1）/2是子树的节点数=&gt;r/2&lt;=0；但这不是一个好算法；考虑用子树的中序插入二叉树数组索引区间（当运行到null节点，数的长度r-l&lt;0）</span></span><br><span class="line">    <span class="keyword">if</span> (r - l &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 初始化根节点</span></span><br><span class="line">    TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[i]);</span><br><span class="line">    <span class="comment">// 查询 m ，从而划分左右子树</span></span><br><span class="line">    <span class="type">int</span> m = inorderMap[preorder[i]];\\找到每一层的中间节点索引in中序插入的二叉树数组</span><br><span class="line">    <span class="comment">// 子问题：构建左子树</span></span><br><span class="line">    root-&gt;left = <span class="built_in">dfs</span>(preorder, inorderMap, i + <span class="number">1</span>, l, m - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 子问题：构建右子树</span></span><br><span class="line">    root-&gt;right = <span class="built_in">dfs</span>(preorder, inorderMap, i + <span class="number">1</span> + m - l, m + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">// 返回根节点</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构建二叉树 */</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;preorder, vector&lt;<span class="type">int</span>&gt; &amp;inorder)</span> </span>&#123;<span class="comment">//preorder意味着数组是前序存储的二叉树</span></span><br><span class="line">    <span class="comment">// 初始化哈希表，存储 inorder 元素到索引的映射</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; inorderMap;<span class="comment">//值-&gt;索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        inorderMap[inorder[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *root = <span class="built_in">dfs</span>(preorder, inorderMap, <span class="number">0</span>, <span class="number">0</span>, inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>右子树根节点索引中的 (m−l) 的含义是“左子树的节点数量”;右子树索引&#x3D;左子树索引+左子树节点数；中序遍历root恰好在遍历完所有左子树节点后；所以<strong>中序遍历插入的二叉树数组中，左子树节点数&#x3D;root索引-左子树跟节点索引（最左）</strong></p>
<p><img src="/image/image_0NX_1LG8zY.png"></p>
<p>为什么不直接用中序插入的数组建立二叉树，试想想，这要高度信息</p>
<p>设树的节点数量为 n ，执行一个递归函数 <code>dfs()</code> 初始化每一个节点,使用 O(1) 时间。<strong>因此总体时间复杂度为 O(n)</strong> 。</p>
<p>哈希表存储 <code>inorder</code> 元素到索引的映射，空间复杂度为<strong>O(n)<strong>。最差情况下，即二叉树退化为链表时，递归深度达到 n ，使用 <strong>O(n)</strong> 的栈帧空间。</strong>因此总体空间复杂度为 O(n)</strong></p>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E6%A0%88/%E6%A0%88/</url>
    <content><![CDATA[<p><img src="/image/image_sc6Sc53q6m.png"></p>
<h3 id="栈操作"><a href="#栈操作" class="headerlink" title="栈操作"></a>栈操作</h3><p><img src="/image/image_TV0Yn7Vhbn.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化栈 */</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stack;</span><br><span class="line"><span class="comment">/* 元素入栈 */</span></span><br><span class="line">stack.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">stack.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">stack.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">stack.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">stack.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"><span class="comment">/* 访问栈顶元素 */</span></span><br><span class="line"><span class="type">int</span> top = stack.<span class="built_in">top</span>();</span><br><span class="line"><span class="comment">/* 元素出栈 */</span></span><br><span class="line">stack.<span class="built_in">pop</span>(); <span class="comment">// 无返回值</span></span><br><span class="line"><span class="comment">/* 获取栈的长度 */</span></span><br><span class="line"><span class="type">int</span> size = stack.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">/* 判断是否为空 */</span></span><br><span class="line"><span class="type">bool</span> empty = stack.<span class="built_in">empty</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h3><p>通常编程语言内置栈类。而某些语言可能没有；此时，<strong>栈可视为受限制的数组或链表</strong>，因栈遵循先入后出的原则，只能在栈顶添加或删除元素。而数组和链表都可在任意位置添加和删除元素；可在程序逻辑上忽略与栈无关的操作。使其对外表现的逻辑符合栈特性</p>
<h4 id="1-基于链表实现"><a href="#1-基于链表实现" class="headerlink" title="1.   基于链表实现"></a>1.   基于链表实现</h4><p>将链表的头节点视为栈顶，尾节点视为栈底</p>
<p>入栈操作：将元素插入链表头部，这种节点插入方法称为“头插法”</p>
<p>出栈操作：将头节点从链表中删除即可</p>
<p><img src="/image/image_KwKImugCJe.png"></p>
<p><img src="/image/image_ZEfB3AaNbn.png"></p>
<p><img src="/image/image_0X7IGcok4S.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基于链表实现的栈 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedListStack</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    ListNode *stackTop; <span class="comment">// 将头节点作为栈顶</span></span><br><span class="line">    <span class="type">int</span> stkSize;        <span class="comment">// 栈的长度</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkedListStack</span>() &#123;</span><br><span class="line">        stackTop = <span class="literal">nullptr</span>;</span><br><span class="line">        stkSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">LinkedListStack</span>() &#123;</span><br><span class="line">        <span class="comment">// 遍历链表删除节点，释放内存</span></span><br><span class="line">        <span class="built_in">freeMemoryLinkedList</span>(stackTop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取栈的长度 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stkSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断栈是否为空 */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">size</span>() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 入栈 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        ListNode *node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(num);</span><br><span class="line">        node-&gt;next = stackTop;</span><br><span class="line">        stackTop = node;</span><br><span class="line">        stkSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 出栈 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">top</span>();</span><br><span class="line">        ListNode *tmp = stackTop;</span><br><span class="line">        stackTop = stackTop-&gt;next;</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        stkSize--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问栈顶元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> stackTop-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将 List 转化为 Array 并返回 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">toVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode *node = stackTop;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res[i] = node-&gt;val;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-基于数组实现"><a href="#2-基于数组实现" class="headerlink" title="2.   基于数组实现"></a>2.   基于数组实现</h4><p>将数组尾部作为栈顶。入栈与出栈操作分别对应在数组尾部添加元素与删除元素，时间复杂度都为O(1）</p>
<p><img src="/image/image_9flvpIulwS.png"></p>
<p><img src="/image/image_UHAnxE6WHq.png"></p>
<p><img src="/image/image_UTZApR23Jv.png"></p>
<p>由于入栈的元素可能会源源不断地增加，因此我们可以使用动态数组，这样就无须自行处理数组扩容问题。以下为示例代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基于数组实现的栈 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; stack;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 获取栈的长度 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断栈是否为空 */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 入栈 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        stack.<span class="built_in">push_back</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 出栈 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> oldTop = <span class="built_in">top</span>();</span><br><span class="line">        stack.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问栈顶元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> stack.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回 Vector */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">toVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="两种实现对比"><a href="#两种实现对比" class="headerlink" title="两种实现对比"></a>两种实现对比</h4><p><strong>支持操作</strong></p>
<p>两种实现都支持栈定义的各项操作。数组实现额外支持随机访问，但这已超出了栈的定义范畴，因此一般不会用到。</p>
<p><strong>时间效率</strong></p>
<p>基于数组的实现：入栈和出栈操作都是在预先分配好的1）连续内存中进行，具有很好的缓存本地性，因此效率较高。然而，2）如果入栈时超出数组容量，触发扩容机制，导致该次入栈操作的时间复杂度变为 O(n) {依次拷贝}</p>
<p>链表实现：链表的扩容非常灵活，不存在上述数组扩容时效率降低的问题。但是，入栈操作需要初始化节点对象并修改指针，因此效率相对较低。不过，如果入栈元素本身就是节点对象，那么可以省去初始化步骤，从而提高效率。</p>
<p>综上所述，当入栈与出栈操作的元素是基本数据类型时，例如 <code>int</code> 或 <code>double</code> ，我们可以得出以下结论。</p>
<ul>
<li>基于数组实现的栈在触发扩容时效率会降低，但由于扩容是低频操作，因此平均效率更高。</li>
<li>基于链表实现的栈可以提供更加稳定的效率表现。</li>
</ul>
<p><strong>空间效率</strong></p>
<p>在初始化列表时，系统会为列表分配“初始容量”，该容量可能超过实际需求。并且，扩容机制通常是按照特定倍率（例如 2 倍）进行扩容，扩容后的容量也可能超出实际需求。因此，<strong>基于数组实现的栈可能造成一定的空间浪费</strong>。</p>
<p>然而，由于链表节点需要额外存储指针，<strong>因此链表节点占用的空间相对较大</strong>。</p>
<p>综上，我们不能简单地确定哪种实现更加节省内存，需要针对具体情况进行分析。</p>
<h3 id="栈典型应用"><a href="#栈典型应用" class="headerlink" title="栈典型应用"></a>栈典型应用</h3><ul>
<li><strong>浏览器中的后退与前进、软件中的撤销与反撤销</strong>。每当我们打开新的网页，浏览器就会将上一个网页执行入栈，这样我们就可以通过后退操作回到上一页面。后退操作实际上是在执行出栈。如果要同时支持后退和前进，那么需要两个栈来配合实现。</li>
<li><strong>程序内存管理</strong>。每次调用函数时，系统都会在栈顶添加一个栈帧，用于记录函数的上下文信息。在递归函数中，向下递推阶段会不断执行入栈操作，而向上回溯阶段则会执行出栈操作。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>桶排序 bucket sort;O(n)</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E6%A1%B6%E6%8E%92%E5%BA%8F%20bucket%20sort;O(n)/%E6%A1%B6%E6%8E%92%E5%BA%8F%20bucket%20sort;O(n)/</url>
    <content><![CDATA[<p>前述的几种排序算法都属于“基于比较的排序算法”，它们通过比较元素间的大小来实现排序。此类排序算法的时间复杂度无法超越 O(nlog⁡n)&#x20;</p>
<p>分治策略：按顺序分组，每组分别进行排序，最后合并各组<br>排序&#x3D;排序第一组+排序第二组。。。。。。</p>
<ol>
<li>确定桶的个数：根据待排序数组中的最大值和最小值，确定需要创建几个桶。一般是将值范围均匀地划分为一组桶。</li>
<li>将元素分配到桶中：遍历待排序数组，将每个元素根据其值分配到对应的桶中。可以使用简单的映射函数来确定元素所属的桶。</li>
<li>对每个桶内部进行排序：对于每个非空的桶，可以使用插入排序等稳定的排序算法来对桶内的元素进行排序。</li>
<li>合并桶中的元素：按照桶的顺序，依次将每个桶中排序后的元素合并起来，形成最终的有序数组。</li>
</ol>
<p>以下是一个示例的桶排序实现代码（假设待排序数组的元素都是非负整数）：</p>
<p>考虑一个长度为 n 的数组，元素是范围 [0,1) 的浮点数</p>
<ol>
<li>初始化 k 个桶，将 n个元素分配到 k个桶中。</li>
<li>对每个桶分别执行排序（本文采用编程语言的内置排序函数）</li>
<li>按照桶的从小到大的顺序，合并结果。</li>
</ol>
<p><img src="https://www.hello-algo.com/chapter_sorting/bucket_sort.assets/bucket_sort_overview.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 桶排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bucketSort</span><span class="params">(vector&lt;<span class="type">float</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 k = n/2 个桶，预期向每个桶分配 2 个元素</span></span><br><span class="line">    <span class="type">int</span> k = nums.<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">float</span>&gt;&gt; <span class="built_in">buckets</span>(k);</span><br><span class="line">    <span class="comment">// 1. 将数组元素分配到各个桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">float</span> num : nums) &#123;</span><br><span class="line">        <span class="comment">// 输入数据范围 [0, 1)，使用 num * k 映射到索引范围 [0, k-1]</span></span><br><span class="line">        <span class="type">int</span> i = num * k;</span><br><span class="line">        <span class="comment">// 将 num 添加进桶 bucket_idx</span></span><br><span class="line">        buckets[i].<span class="built_in">push_back</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 对各个桶执行排序</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">float</span>&gt; &amp;bucket : buckets) &#123;</span><br><span class="line">        <span class="comment">// 使用内置排序函数，也可以替换成其他排序算法</span></span><br><span class="line">        <span class="built_in">sort</span>(bucket.<span class="built_in">begin</span>(), bucket.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 遍历桶合并结果</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">float</span>&gt; &amp;bucket : buckets) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">float</span> num : bucket) &#123;</span><br><span class="line">            nums[i++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第二个参考代码：</p>
<p>1）确定待排序序列的范围（遍历出最大最小值）<br>2）确定桶个数k（似乎是经验公式:范围&#x2F;序列个数+1）;创建桶（有点像数组实现的链式法哈希表）<br>3)遍历未排序数组，通过f把序列值（key）映射到[0,k-1]（桶下标）；（f定义为num*区间放缩因子）<br>4）遍历桶，分别排序<br>5）双循环，把排序好的元素按顺序放回去</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span> <span class="comment">// sort()</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 桶排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bucketSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> minmax =  <span class="built_in">minmax_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> min_value = *minmax.first;</span><br><span class="line">    <span class="type">int</span> max_value = *minmax.second;</span><br><span class="line">    <span class="comment">// 确定 桶的个数</span></span><br><span class="line">    <span class="type">int</span> k = (max_value - min_value ) / nums.<span class="built_in">size</span>() + <span class="number">1</span>;    <span class="comment">// 修改1</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">buckets</span>(k);</span><br><span class="line">    <span class="comment">// 1. 将数组元素分配到各个桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="type">int</span> i = (num - min_value)/ nums.<span class="built_in">size</span>();    <span class="comment">//  修改2</span></span><br><span class="line">        <span class="comment">// 将 num 添加进桶 bucket_idx</span></span><br><span class="line">        buckets[i].<span class="built_in">push_back</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 对各个桶执行排序</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;&amp; bucket : buckets) &#123;</span><br><span class="line">        <span class="comment">// 使用内置排序函数，也可以替换成其他排序算法</span></span><br><span class="line">        <span class="built_in">sort</span>(bucket.<span class="built_in">begin</span>(), bucket.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 遍历桶合并结果</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;&amp; bucket : buckets) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : bucket) &#123;</span><br><span class="line">            nums[i++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123; <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span> &#125;;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;排序前：\n&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = <span class="built_in">begin</span>(nums); it != <span class="built_in">end</span>(nums); it++)</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;\n排序后：\n&quot;</span>;</span><br><span class="line">  <span class="built_in">bucketSort</span>(nums);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">    cout &lt;&lt; nums[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度 O(n+k)</strong> ：假设元素在各个桶内平均分布，那么每个桶内的元素数量为 $\frac{n}{k}$ 。假设排序单个桶使用 $ O(\frac{n}{k}log⁡\frac{n}{k})  $时间，则排序所有桶使用 $ O(nlog⁡\frac{n}{k})  $时间。<strong>当桶数量 n 比较大时，时间复杂度则趋向于 O(n)</strong> 。合并结果时需要遍历所有桶和元素，花费 <strong>O(n+k)</strong>  时间。</li>
</ul>
<p>桶排序适用于处理体量很大的数据。例如，输入数据包含 100 万个元素，由于空间限制，系统内存无法一次性加载所有数据。此时，可以将数据分成 1000 个桶，然后分别对每个桶进行排序，最后将结果合并。</p>
<ul>
<li><strong>自适应排序</strong>：在最坏情况下，所有数据被分配到一个桶中，且排序该桶使用 O(n^2) 时间。</li>
<li><strong>空间复杂度O(n+k)</strong> <strong>、非原地排序</strong>：需要借助 k 个桶和总共 n 个元素的额外空间。</li>
<li>桶排序是否稳定取决于排序桶内元素的算法是否稳定。</li>
</ul>
<h2 id="如何实现平均分配"><a href="#如何实现平均分配" class="headerlink" title="如何实现平均分配"></a>如何实现平均分配</h2><p>桶排序的时间复杂度理论上可以达到 O(n) ，这样分析时间复杂度的关键点是假设了每个桶平均分配了n&#x2F;k个元素；实际数据往往不是均匀分布的。例如，我们想要将淘宝上的所有商品按价格范围平均分配到 10 个桶中，但商品价格分布不均，低于 100 元的非常多，高于 1000 元的非常少。若将价格区间平均划分为 10 份，各个桶中的商品数量差距会非常大。</p>
<p>为实现平均分配，我们可以先设定一个大致的分界线，将数据粗略地分到 3 个桶中。<strong>分配完毕后，再将商品较多的桶继续划分为 3 个桶，直至所有桶中的元素数量大致相等</strong>。</p>
<p>这种方法本质上是创建一个递归树，目标是让叶节点的值尽可能平均。当然，不一定要每轮将数据划分为 3 个桶，具体划分方式可根据数据特点灵活选择。</p>
<p><img src="https://www.hello-algo.com/chapter_sorting/bucket_sort.assets/scatter_in_buckets_recursively.png"></p>
<p>如果我们提前知道商品价格的概率分布，<strong>则可以根据数据概率分布设置每个桶的价格分界线</strong>。值得注意的是，数据分布并不一定需要特意统计，也可以根据数据特点采用某种概率模型进行近似。</p>
<p>我们假设商品价格服从正态分布，这样就可以合理地设定价格区间，从而将商品平均分配到各个桶中。</p>
<p><img src="https://www.hello-algo.com/chapter_sorting/bucket_sort.assets/scatter_in_buckets_distribution.png"></p>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>树查找</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E6%A0%91%E6%9F%A5%E6%89%BE/%E6%A0%91%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p><strong>树查找</strong></p>
<ul>
<li>适用于海量数据，因为树节点在内存中是分散存储的。</li>
<li>适合需要维护有序数据或范围查找的场景。</li>
<li>在持续增删节点的过程中，二叉搜索树可能产生倾斜，时间复杂度劣化至 O(n) 。</li>
<li>若使用 AVL 树或红黑树，则各项操作可在 O(log⁡n) 效率下稳定运行，但维护树平衡的操作会增加额外开销。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>汉诺塔</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E6%B1%89%E8%AF%BA%E5%A1%94/%E6%B1%89%E8%AF%BA%E5%A1%94/</url>
    <content><![CDATA[<p>分治策略专场</p>
<p><img src="/image/image_xu8rNSU-yY.png"></p>
<p><img src="/image/image_VeDKbHwE-x.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 移动一个圆盘 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;src, vector&lt;<span class="type">int</span>&gt; &amp;tar)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从 src 顶部拿出一个圆盘</span></span><br><span class="line">    <span class="type">int</span> pan = src.<span class="built_in">back</span>();</span><br><span class="line">    src.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="comment">// 将圆盘放入 tar 顶部</span></span><br><span class="line">    tar.<span class="built_in">push_back</span>(pan);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求解汉诺塔：问题 f(i) */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, vector&lt;<span class="type">int</span>&gt; &amp;src, vector&lt;<span class="type">int</span>&gt; &amp;buf, vector&lt;<span class="type">int</span>&gt; &amp;tar)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若 src 只剩下一个圆盘，则直接将其移到 tar</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">move</span>(src, tar);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子问题 f(i-1) ：将 src 顶部 i-1 个圆盘借助 tar 移到 buf</span></span><br><span class="line">    <span class="built_in">dfs</span>(i - <span class="number">1</span>, src, tar, buf);</span><br><span class="line">    <span class="comment">// 子问题 f(1) ：将 src 剩余一个圆盘移到 tar</span></span><br><span class="line">    <span class="built_in">move</span>(src, tar);</span><br><span class="line">    <span class="comment">// 子问题 f(i-1) ：将 buf 顶部 i-1 个圆盘借助 src 移到 tar</span></span><br><span class="line">    <span class="built_in">dfs</span>(i - <span class="number">1</span>, buf, src, tar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求解汉诺塔 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solveHanota</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B, vector&lt;<span class="type">int</span>&gt; &amp;C)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 将 A 顶部 n 个圆盘借助 B 移到 C</span></span><br><span class="line">    <span class="built_in">dfs</span>(n, A, B, C);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法评估</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AF%84%E4%BC%B0/%E7%AE%97%E6%B3%95%E8%AF%84%E4%BC%B0/</url>
    <content><![CDATA[<p><strong>统计算法运行时间：<br>除了对实时性要求高的场景；统计算法运行时间既不合理也不现实</strong>。<br>1）因为算法需要在不同硬件平台上运行；<br>2）要获知每种操作的运行时间<br>3）要测试各种数据规模下算法的表现（在现代，尤其只关心在非小规模数据量下的表现）这给预估过程带来了极大的难度和成本→并非不关心局部有界性问题（有限时间解决某数量级输入问题），但这并非算法主要所研究</p>
<p>「渐近<strong>复杂度分析</strong> asymptotic complexity analysis」：(1.统计操作数2.取最高项f(n)，并判断渐近上界)<br><strong>时间复杂度 [time complexity」O(f(n)):</strong><br>1）<strong>视 计算操作 执行时间都为单位时间</strong>；由1可知T(n)肯定有误差；但不失为好的判断分析方式<br>2）<strong>输入数据量-时空开销的关系曲线 T(n) ；最高阶项</strong>f(n)（无穷大时的线性主部ex:2n+1为n）；因常数项和系数在不同场景下不同，并不关键；除此以外相同算法不同情况下会有不同f(n)：所以有不同O(f(n))；一般取常见情况或最坏情况f(n)<br>3）<strong>时间复杂度</strong>O&#x3D;常见或最坏情况f(n)划定的上界<br>3.2）最佳时间复杂度Ω&#x3D;由最佳f(n)划定的下界&#x20;<br>3.3）<strong>平均时间复杂度</strong>Θ&#x3D;随机数据的分布的数学期望E(X)作为?????</p>
<p><img src="/image/image_Vhag6jo-Ub.png"></p>
<p><img src="/image/image_sC9xXOsrZB.png"></p>
<p>空间复杂度 [space complexity」:</p>
<p><img src="/image/image_JQ0zrXX29e.png"></p>
<p><strong>输入空间</strong>：用于存储算法的输入数据<br><strong>暂存空间</strong>：<br>1）<strong>暂存数据</strong>：用于保存算法运行过程中的各种常量、变量、对象等。<br>2）<strong>栈帧空间</strong>：用于保存调用函数的上下文数据。系统在每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放。<br>3）<strong>指令空间</strong>：用于保存编译后的程序指令，在实际统计中通常忽略不计。<br><strong>输出空间</strong>：用于存储算法的输出数据。<br>一般情况下，空间复杂度的统计范围<strong>暂存数据、栈帧空间和输出数据三部分</strong>。</p>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>生成分量无序结构的h元组合(子集/组合问题)</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E7%94%9F%E6%88%90%E5%88%86%E9%87%8F%E6%97%A0%E5%BA%8F%E7%BB%93%E6%9E%84%E7%9A%84h%E5%85%83%E7%BB%84%E5%90%88(%E5%AD%90%E9%9B%86-%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98)/%E7%94%9F%E6%88%90%E5%88%86%E9%87%8F%E6%97%A0%E5%BA%8F%E7%BB%93%E6%9E%84%E7%9A%84h%E5%85%83%E7%BB%84%E5%90%88(%E5%AD%90%E9%9B%86-%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98)/</url>
    <content><![CDATA[<p>给定分量集：<br>1）分量集<strong>元素可无限次选取</strong>2）解空间的解无序结构<br>求解空间所有子集（也可以说是组合问题）</p>
<p>回溯策略：遍历所有h元组合所有可能<br>1）求出问题的解空间<br>2）声明3个容器：<br>1.路径：问题的解在搜索过程中动态产生<br>2.分量列表<br>3.符合约束条件的解<br>3）遍历分量集选择第一个分量→迭代地遍历分量集选择第二个分量…….直至到达递归终止条件<br>{每选择一个分量：判定是否满足约束条件<br>不满足：continue跳至下轮本分量选择的下一轮遍历，相当于放弃了本轮遍历的子树<br>满足：把路径里的结果push into 结果列表；pop路径；返回上一个分量选择调用<br>}</p>
<h2 id="分量集无重复元素"><a href="#分量集无重复元素" class="headerlink" title="分量集无重复元素"></a>分量集无重复元素</h2><p><img src="/image/image_Y42Q1u1CJE.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 回溯算法：子集和 I */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;state, <span class="type">int</span> target, <span class="type">int</span> total, vector&lt;<span class="type">int</span>&gt; &amp;choices, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子集和等于 target 时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (total == target) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(state);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有分量，开启一轮分量选择</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; choices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 剪枝：若子集和超过 target ，则跳过该选择</span></span><br><span class="line">        <span class="keyword">if</span> (total + choices[i] &gt; target) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;<span class="comment">//不满足约束条件：选下个分量</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试：做出选择，更新元素和 total</span></span><br><span class="line">        state.<span class="built_in">push_back</span>(choices[i]);</span><br><span class="line">        <span class="comment">// 进行下一轮选择</span></span><br><span class="line">        <span class="built_in">backtrack</span>(state, target, total + choices[i], choices, res);</span><br><span class="line">        <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">        state.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求解子集和 I（包含重复子集） */</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetSumINaive</span>(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; state;       <span class="comment">// 状态（子集）</span></span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;           <span class="comment">// 子集和；约束条件&lt;=9，大于9直接剪掉</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res; <span class="comment">// 结果列表（子集列表）</span></span><br><span class="line">    <span class="built_in">backtrack</span>(state, target, total, nums, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为组合（无序结构）；（5，4）（4，5）是一样的组合，考虑去重<br>1）<strong>对结果列表进行去重</strong>。但这个方法效率很低，因为：</p>
<ul>
<li>当数组元素较多，尤其是当 <code>target</code> 较大时，搜索过程会产生大量的重复子集。</li>
<li>比较子集（数组）的异同非常耗时 <strong>，需要先排序数组</strong>，再比较数组中每个元素的异同。</li>
</ul>
<p>2）优雅的实现方式是生成过程识别到这种情况直接减枝<br>第一个分量$x_{i}$的子树生成了所有包含$x_{i}$的组合；第一个分量非$x_{i}$的子树遍历{分量集-$x_{i}$}生成的子树可以避免生成包含$x_{i}$的组合</p>
<p><img src="/image/image_6-pW4Ku-cP.png"></p>
<p><img src="/image/image_4zmdtxP-LZ.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 回溯算法：子集和 I */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;state, <span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt; &amp;choices, <span class="type">int</span> start, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子集和等于 target 时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(state);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有选择</span></span><br><span class="line">    <span class="comment">// 剪枝二：从 start 开始遍历，避免生成重复子集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; choices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 剪枝一：若子集和超过 target ，则直接结束循环</span></span><br><span class="line">        <span class="comment">// 这是因为数组已排序，后边元素更大，子集和一定超过 target</span></span><br><span class="line">        <span class="keyword">if</span> (target - choices[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试：做出选择，更新 target, start</span></span><br><span class="line">        state.<span class="built_in">push_back</span>(choices[i]);</span><br><span class="line">        <span class="comment">// 进行下一轮选择</span></span><br><span class="line">        <span class="built_in">backtrack</span>(state, target - choices[i], choices, i, res);<span class="comment">//</span></span><br><span class="line">        <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">        state.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求解子集和 I */</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetSumI</span>(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; state;              <span class="comment">// 状态（子集）</span></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 对 nums 进行排序</span></span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;                  <span class="comment">// 遍历起始点</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;        <span class="comment">// 结果列表（子集列表）</span></span><br><span class="line">    <span class="built_in">backtrack</span>(state, target, nums, start, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/image/image_J546v1kZbz.png"></p>
<h2 id="分量集有重复元素"><a href="#分量集有重复元素" class="headerlink" title="分量集有重复元素"></a>分量集有重复元素</h2><p><img src="/image/image_B33S91ZSFZ.png"></p>
<p>解决思路：规定每个值只能在每个分量位置上出现一次；实现方式比较巧妙：由于数组是已排序的，因此相等元素都是相邻的。这意味着在某轮选择中，若当前元素与其左边元素相等，则说明它已经被选择过，因此直接跳过当前元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 回溯算法：子集和 II */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;state, <span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt; &amp;choices, <span class="type">int</span> start, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子集和等于 target 时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(state);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有选择</span></span><br><span class="line">    <span class="comment">// 剪枝二：从 start 开始遍历，避免生成重复子集</span></span><br><span class="line">    <span class="comment">// 剪枝三：从 start 开始遍历，避免重复选择同一元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; choices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 剪枝一：若子集和超过 target ，则直接结束循环</span></span><br><span class="line">        <span class="comment">// 这是因为数组已排序，后边元素更大，子集和一定超过 target</span></span><br><span class="line">        <span class="keyword">if</span> (target - choices[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剪枝四：如果该元素与左边元素相等，说明该搜索分支重复，直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; start &amp;&amp; choices[i] == choices[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试：做出选择，更新 target, start</span></span><br><span class="line">        state.<span class="built_in">push_back</span>(choices[i]);</span><br><span class="line">        <span class="comment">// 进行下一轮选择</span></span><br><span class="line">        <span class="built_in">backtrack</span>(state, target - choices[i], choices, i + <span class="number">1</span>, res);</span><br><span class="line">        <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">        state.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求解子集和 II */</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetSumII</span>(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; state;              <span class="comment">// 状态（子集）</span></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 对 nums 进行排序</span></span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;                  <span class="comment">// 遍历起始点</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;        <span class="comment">// 结果列表（子集列表）</span></span><br><span class="line">    <span class="built_in">backtrack</span>(state, target, nums, start, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/image/image_SyymLH9ypz.png"></p>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>线性查找的hash优化</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE%E7%9A%84hash%E4%BC%98%E5%8C%96/%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE%E7%9A%84hash%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>Question：</p>
<p>给定整数数组 <code>nums</code> 和目标元素 <code>target</code> ，在数组中搜索“和”为 <code>target</code> 的两个元素，并返回它们的索引。返回任意一个解即可。</p>
<p>枚举策略：直接遍历所有可能的组合；</p>
<p>1）开启一个两层循环，第一轮循环遍历第一个因数a（即所有元素）；第二轮循环遍历a以后的元素；判断是否为 <code>target</code>-a ，若是则返回它们的索引。<br>这个枚举策略用到了两次线性查找O(n^2)，空间复杂度为 O(1)；以时间换空间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 方法一：暴力枚举 */</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSumBruteForce</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 两层循环，时间复杂度 O(n^2)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target)</span><br><span class="line">                <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>线性搜索</strong></p>
<ul>
<li>通用性较好，无须任何数据预处理操作。假如我们仅需查询一次数据，那么其他三种方法的数据预处理的时间比线性搜索的时间还要更长。</li>
<li>适用于体量较小的数据，此情况下时间复杂度对效率影响较小。</li>
<li>适用于数据更新频率较高的场景，因为该方法不需要对数据进行任何额外维护。</li>
</ul>
<p><strong>线性查找替换为哈希查找来降低算法的时间复杂度</strong>：</p>
<p><img src="/image/image_DBoCbV_0o-.png"></p>
<p><img src="/image/image_7kn_qZDyDS.png"></p>
<p><img src="/image/image_RlA776ajq3.png"></p>
<p>此方法通过哈希查找将时间复杂度从 O(n^2) 降低至 O(n) ，大幅提升运行效率。由于需要维护一个额外的哈希表，因此空间复杂度为 O(n) 。<br>1)第一次直接遍历变成哈希建表O(n)；2）第二次线性条件查找变成哈希条件查找value→indexO(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 方法二：辅助哈希表 */</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSumHashTable</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 辅助哈希表，空间复杂度 O(n)</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; dic;</span><br><span class="line">    <span class="comment">// 单层循环，时间复杂度 O(n)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dic.<span class="built_in">find</span>(target - nums[i]) != dic.<span class="built_in">end</span>()) &#123;<span class="comment">//.find查找是否在hash table内；存在返回索引，不存在返回.end()指向最后元素后一位索引 </span></span><br><span class="line">            <span class="keyword">return</span> &#123;dic[target - nums[i]], i&#125;;<span class="comment">//？？这题在插入hash前可以在表中进行一次查找，找不到可能不存在也可能存在后边，在后边必会找到（可理解为退化的线性查找？）</span></span><br><span class="line">        &#125;</span><br><span class="line">        dic.<span class="built_in">emplace</span>(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>哈希查找</strong></p>
<ul>
<li>适合对查询性能要求很高的场景，平均时间复杂度为 O(1) 。</li>
<li>不适合需要有序数据或范围查找的场景，因为哈希表无法维护数据的有序性。</li>
<li>对哈希函数和哈希冲突处理策略的依赖性较高，具有较大的性能劣化风险。</li>
<li>不适合数据量过大的情况，因为哈希表需要额外空间来最大程度地减少冲突，从而提供良好的查询性能。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>编辑距离问题</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>两字符串转换所需最小修改次数，常用于信息检索和自然语言处理中<strong>度量两个序列的相似度</strong></p>
<p><img src="/image/image_zRXPngAvUE.png"></p>
<p>字符编辑行为进行抽象：<strong>很自然地用决策树模型来看待</strong>;字符串可以看作有序对；一个一个分量进行比较，并进行增删改编辑都是一轮决策；高度是最长组合的size：本题的目标是求解两个组合节点 间的最短路径</p>
<p><img src="/image/image_StRTiPBS90.png"></p>
<p>分治：S的前i个字符编辑成T的前j个字符&#x3D;对每个对应分量字符进行编辑（3叉树）<br>dp策略：S的前i个字符编辑成T的前j个字符的最短路径&#x3D;<br>S的前i-1个字符编辑成T的前j个字符的最短路径+一次删除操作<br>S的前i个字符编辑成T的前j-1个字符的最短路径+一次插入操作<br>S的前i-1个字符编辑成T的前j-1个字符的最短路径+一次修改操作<br>$f(i,j)&#x3D;min(f(i-1,j),f(i,j-1),f(i-1,j-1))+1$<br>边界：f(0,j)&#x3D;j,f(i,0)&#x3D;i,f(0,0)&#x3D;0<br>优化：如果新增最末尾字符s[i-1]&#x3D;t[i-1]相同时无需修改；f(i,j)&#x3D;f(i-1,j-1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 编辑距离：动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">editDistanceDP</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>(), m = t.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 状态转移：首行首列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 状态转移：其余行列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 若两字符相等，则直接跳过此两字符</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 最少编辑步数 = 插入、删除、替换这三种操作的最少编辑步数 + 1</span></span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/image/image_i6DtYoYlJP.png"></p>
<h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p><img src="/image/image_qvk_Ic8bIF.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 编辑距离：空间优化后的动态规划 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">editDistanceDPComp</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>(), m = t.<span class="built_in">length</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 状态转移：首行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        dp[j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 状态转移：其余行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 状态转移：首列</span></span><br><span class="line">        <span class="type">int</span> leftup = dp[<span class="number">0</span>]; <span class="comment">// 暂存 dp[i-1, j-1]</span></span><br><span class="line">        dp[<span class="number">0</span>] = i;</span><br><span class="line">        <span class="comment">// 状态转移：其余列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="type">int</span> temp = dp[j];</span><br><span class="line">            <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 若两字符相等，则直接跳过此两字符</span></span><br><span class="line">                dp[j] = leftup;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 最少编辑步数 = 插入、删除、替换这三种操作的最少编辑步数 + 1</span></span><br><span class="line">                dp[j] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[j - <span class="number">1</span>], dp[j]), leftup) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            leftup = temp; <span class="comment">// 更新为下一轮的 dp[i-1, j-1]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>计数排序 counting sort；O(n)</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%20counting%20sort%EF%BC%9BO(n)/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%20counting%20sort%EF%BC%9BO(n)/</url>
    <content><![CDATA[<p>专门用于排序非负整数序列；</p>
<p>从桶排序的角度理解，可将计数排序中的计数数组 <code>counter</code> 的每个索引视为一个桶，将统计数量的过程看作是将各个元素分配到对应的桶中。本质上，计数排序是桶排序在整型数据下的一个特例</p>
<p>简单实现：<br>1）遍历原数组，找到整数范围；建立一个计数数组<br>2）遍历原数组；统计各整数出现次数；<br>3）按计数插入值个数到原数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 计数排序 */</span></span><br><span class="line"><span class="comment">// 简单实现，无法用于排序对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">countingSortNaive</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 统计数组最大元素 m</span></span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        m = <span class="built_in">max</span>(m, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 统计各数字的出现次数</span></span><br><span class="line">    <span class="comment">// counter[num] 代表 num 的出现次数</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(m + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        counter[num]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 遍历 counter ，将各元素填入原数组 nums</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num = <span class="number">0</span>; num &lt; m + <span class="number">1</span>; num++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; counter[num]; j++, i++) &#123;</span><br><span class="line">            nums[i] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>稳定性优化的思路是：计数之后把计数值映射为一个尾索引；遍历原数组每个值，找到对应的尾索引插入辅助数组，尾索引-1，这样能保持稳定性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 计数排序 */</span></span><br><span class="line"><span class="comment">// 完整实现，可排序对象，并且是稳定排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">countingSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 统计数组最大元素 m</span></span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        m = <span class="built_in">max</span>(m, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 统计各数字的出现次数</span></span><br><span class="line">    <span class="comment">// counter[num] 代表 num 的出现次数</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">counter</span><span class="params">(m + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        counter[num]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 求 counter 的前缀和，将“出现次数”转换为“尾索引”</span></span><br><span class="line">    <span class="comment">// 即 counter[num]-1 是 num 在 res 中最后一次出现的索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        counter[i + <span class="number">1</span>] += counter[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 倒序遍历 nums ，将各元素填入结果数组 res</span></span><br><span class="line">    <span class="comment">// 初始化数组 res 用于记录结果</span></span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//遍历原数组，保持稳定性</span></span><br><span class="line">        <span class="type">int</span> num = nums[i];</span><br><span class="line">        res[counter[num] - <span class="number">1</span>] = num; <span class="comment">// 将 num 放置到对应索引处</span></span><br><span class="line">        counter[num]--;              <span class="comment">// 令前缀和自减 1 ，得到下次放置 num 的索引</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用结果数组 res 覆盖原数组 nums</span></span><br><span class="line">    nums = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还能就内存开销继续优化</p>
<ul>
<li><strong>时间复杂度 O(n+m)</strong> ：涉及遍历 <code>nums</code> 和遍历 <code>counter</code> ，都使用线性时间。一般情况下 n≫m ，时间复杂度趋于 O(n) 。</li>
<li><strong>空间复杂度 O(n+m)、非原地排序</strong>：借助了长度分别为 n 和 m 的数组 <code>res</code> 和 <code>counter</code> 。</li>
<li><strong>稳定排序</strong>：由于向 <code>res</code> 中填充元素的顺序是“从右向左”的，因此倒序遍历 <code>nums</code> 可以避免改变相等元素之间的相对位置，从而实现稳定排序。实际上，正序遍历 <code>nums</code> 也可以得到正确的排序结果，但结果是非稳定的。</li>
</ul>
<p>&#x20;局限性:</p>
<p><strong>计数排序只适用于整数</strong>(这里还没优化，只能用于正整数)。若想要将其用于其他类型的数据，需要确保这些数据可以被转换为非负整数，并且在转换过程中不能改变各个元素之间的相对大小关系。例如，对于包含负数的整数数组，可以先给所有数字加上一个常数，将全部数字转化为正数，排序完成后再转换回去即可。</p>
<p><strong>计数排序适用于数据量大但数据范围较小的情况</strong>。比如，在上述示例中 m 不能太大，否则会占用过多空间。而当 n≪m 时，计数排序使用 O(m) 时间，可能比 O(nlog⁡n) 的排序算法还要慢。(其实是还没优化)</p>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-cmd</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/linux-cmd/linux-cmd/</url>
    <content><![CDATA[<p>linux-cmd程序大都基于系统函数实现</p>
<h2 id="shell特性"><a href="#shell特性" class="headerlink" title="shell特性"></a>shell特性</h2><p>shell应用程序：提供命令交互方式获取用户输入，并显示程序的执行结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1)shell启动脚本:</span><br><span class="line">∼/.bashrc</span><br><span class="line"></span><br><span class="line">2)启用补齐（大都默认加入了∼/.bashrc）:</span><br><span class="line"><span class="built_in">source</span> /etc/bash_completion      </span><br><span class="line"></span><br><span class="line">3)cmd历史</span><br><span class="line"><span class="built_in">history</span></span><br><span class="line"></span><br><span class="line">4）</span><br><span class="line">创建终端标签 Ctrl + Shift + t</span><br><span class="line">切换标签 Alt+n</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h2><h3 id="目录-文件操作"><a href="#目录-文件操作" class="headerlink" title="目录&#x2F;文件操作"></a>目录&#x2F;文件操作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1）列出</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"><span class="built_in">ls</span> -a</span><br><span class="line"><span class="built_in">ls</span> -R        //连同子目录列出</span><br><span class="line">ll</span><br><span class="line"></span><br><span class="line">2）查看路径</span><br><span class="line"><span class="built_in">cd</span> -        // 进入上次目录</span><br><span class="line"><span class="built_in">cd</span> ~        // 进入家目录</span><br><span class="line"><span class="built_in">which</span>        //查看指定命令路径<span class="built_in">which</span> <span class="built_in">ls</span></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line"></span><br><span class="line">3)创建/删除</span><br><span class="line"><span class="built_in">mkdir</span></span><br><span class="line"><span class="built_in">rmdir</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">touch</span>          //创建文件或更新时间</span><br><span class="line"><span class="built_in">rm</span>             //Delete the file</span><br><span class="line"><span class="built_in">rm</span> -rf   </span><br><span class="line"></span><br><span class="line">4）重命名/移动文件</span><br><span class="line"><span class="built_in">mv</span> f1 f2       //重命名</span><br><span class="line"><span class="built_in">mv</span> f1 ~/       //移动</span><br><span class="line"></span><br><span class="line">5）拷贝</span><br><span class="line"><span class="built_in">cp</span> f1 ../</span><br><span class="line"><span class="built_in">cp</span> f1 f2       //f1拷贝为f2</span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> dir1 dir2 -r  //Copy the directory</span><br><span class="line"><span class="built_in">cp</span> dir1 ~/ -r</span><br><span class="line"></span><br><span class="line">6) 查看数据块内的文件内容</span><br><span class="line"><span class="built_in">cat</span></span><br><span class="line">more            //单屏查看</span><br><span class="line"><span class="built_in">head</span> -5 f1            //查看头5行</span><br><span class="line"><span class="built_in">tail</span> -5 f1      //查看末5行</span><br><span class="line"></span><br><span class="line">tree            //树形显示，要查看目录文件数据块中的下属文件哈希表（inode:name）</span><br><span class="line"></span><br><span class="line">7）查看数据块内的文件头</span><br><span class="line">file -bcvz -f hello.c     //查看文件格式类型；-L 直接显示符号连接所指向的文件的类别；-m&lt;魔法数字文件&gt; 　指定魔法数字文件；-z 尝试解读压缩文件内容</span><br><span class="line"></span><br><span class="line">8）查看文件Inode</span><br><span class="line"><span class="built_in">stat</span> f1         //查看文件f1的Inode</span><br><span class="line"></span><br><span class="line"><span class="built_in">du</span> -hk ./*             //查看目录大小,以K为单位</span><br><span class="line"></span><br><span class="line"><span class="built_in">wc</span> -l f1              //读取文件行数</span><br><span class="line"><span class="built_in">wc</span> -c f1              //读取文件字节数</span><br><span class="line"><span class="built_in">wc</span> –bytes f1</span><br><span class="line"><span class="built_in">wc</span> –chars f1</span><br><span class="line"><span class="built_in">wc</span> -w f1              //读取文件”字长“数</span><br><span class="line"></span><br><span class="line">9）查看文件系统（查看磁盘）</span><br><span class="line"><span class="built_in">df</span> --block-size=GB      //查看磁盘使用情况</span><br><span class="line"><span class="built_in">df</span> --block-size=MB </span><br><span class="line"></span><br><span class="line">10）链接（软：快捷方式；硬：副本链接）</span><br><span class="line"><span class="built_in">touch</span> f1</span><br><span class="line"><span class="built_in">ln</span> f1 f_hard       //f_hard为f1的硬链接文件；不同名但有相同incode</span><br><span class="line"><span class="built_in">ln</span> -s f1 f_soft    //ls -li可显示出软链接文件具有不同incode;但f_soft的incode指向数据块存放的是f1的路径名；（类比快捷方式）</span><br></pre></td></tr></table></figure>

<h3 id="文件属性-用户（组）管理"><a href="#文件属性-用户（组）管理" class="headerlink" title="文件属性&#x2F;用户（组）管理"></a>文件属性&#x2F;用户（组）管理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1）文件权限/所属管理</span><br><span class="line"><span class="built_in">chmod</span> 777 f1                        //用户-同组-其他的权限rwx-rwx-rwx</span><br><span class="line"></span><br><span class="line">sudo <span class="built_in">chown</span> -Rv user2:group2 f1      //f1改变为user2和group2所有</span><br><span class="line">sudo <span class="built_in">chgrp</span> xvjin f1                  //f1改变为xvjin组所有</span><br><span class="line"></span><br><span class="line"><span class="built_in">umask</span>                        //创建文件时的默认权限掩码</span><br><span class="line"><span class="built_in">umask</span> 0022                  //将文件权限掩码设置为 0022，000-010-010;表示新创建的文件对组用户屏蔽写权限&amp;~<span class="built_in">umask</span></span><br><span class="line"><span class="built_in">umask</span> -S</span><br><span class="line"></span><br><span class="line">2）用户（组）管理</span><br><span class="line"><span class="built_in">who</span>           //查看用户列表</span><br><span class="line"><span class="built_in">whoami</span>        //查看登录用户</span><br><span class="line"><span class="built_in">cd</span> /home &amp;&amp; <span class="built_in">ls</span>         //查看用户/用户组</span><br><span class="line"></span><br><span class="line">sudo adduser -g mygroup -G g2,root -d /home/xvjin -m xvjin     //添加用户xvjin：-g mygroup指定属于mygroup 组；-d /home/xvjin -m指定创建用户家目录;-G g2,root指定其还属于g2,root组</span><br><span class="line">sudo deluser -r xvjin     //删除用户</span><br><span class="line"></span><br><span class="line">sudo addgoup xvjin     //添加用户组</span><br><span class="line">sudo delgroup xvjin     //删除用户组</span><br><span class="line"></span><br><span class="line">su xvjin               //切换用户</span><br><span class="line">sudo su                 //切换为root用户</span><br><span class="line"></span><br><span class="line">sudo passwd xvjin      //设置密码</span><br><span class="line">passwd                 //设置root密码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h3><p>-type</p>
<p><img src="/image/image_jWUUhpsMZO.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1）搜文件</span><br><span class="line">find / -name <span class="string">&#x27;f*&#x27;</span>    //找根目录下f开头的</span><br><span class="line">find / -<span class="built_in">type</span> l      //找根目录下的软链接</span><br><span class="line">find / -maxdepth 1 -name <span class="string">&#x27;f*&#x27;</span>    //找根目录下f开头的文件，搜索深度为1</span><br><span class="line">find / -size +20M -size -50M    //找根目录下找大于20M,小于50M的</span><br><span class="line">find / -ctime 1      //找根目录下修改时间在1D以内的</span><br><span class="line">find /usr/ -name <span class="string">&quot;*tmp*&quot;</span> -<span class="built_in">exec</span> <span class="built_in">ls</span> -l &#123; &#125; \;       //搜索含tmp字样文件；每个参数传给&#123;&#125;；对每个参数启动新的 <span class="built_in">ls</span> -l 进程；-<span class="built_in">exec</span>的交互版-ok</span><br><span class="line">find /usr/ -name <span class="string">&quot;*tmp*&quot;</span> | xargs grep <span class="string">&quot;printf&quot;</span>       //| xargs把find的输出转换为参数集传递给grep <span class="string">&quot;printf&quot;</span>命令</span><br><span class="line">find /usr/ -name <span class="string">&quot;*tmp*&quot;</span> -print0 | xargs -0 grep <span class="string">&quot;printf&quot;</span>     //-print0表示以null作为参数间隔标记</span><br><span class="line"></span><br><span class="line">2）搜内容</span><br><span class="line">grep ‘<span class="built_in">printf</span>’ /usr/include -R -I -n //在头文件目录下查找包含<span class="built_in">printf</span>的文件;-R递归；-n显示行号；-I不区分大小写</span><br><span class="line">grep </span><br><span class="line">grep -nc <span class="string">&quot;this&quot;</span> demo_file     //从单个文件中查找指定的字符串</span><br><span class="line">sudo grep -nc <span class="string">&quot;this&quot;</span> demo_*        //从多个文件中查找指定的字符串</span><br><span class="line">grep -l <span class="string">&#x27;root&#x27;</span> /etc/fstab /etc/passwd /etc/mtab  //打印有root内容的文件名</span><br><span class="line">grep -vnc <span class="string">&#x27;nobody&#x27;</span> /etc/passwd           //打印没有内容nobody的行</span><br><span class="line">grep -nc ^backup /etc/passwd              //打印以 “backup” 开头的行</span><br><span class="line">grep -nc bash$ /etc/passwd             //打印以 “bash” 结尾的行</span><br><span class="line">sudo grep -rnc nobody /etc             //递归查找</span><br><span class="line">grep -inc IP_Forward /etc/sysctl.conf     //忽略大小写</span><br><span class="line">sudo sysctl -a | grep -wnc <span class="string">&#x27;vm.swappiness&#x27;</span>    //仅匹配整个单词</span><br><span class="line">grep -nc -e nobody -e mail /etc/passwd         //搜索多个</span><br><span class="line">grep -nc -E <span class="string">&quot;nobody|mail&quot;</span> /etc/passwd</span><br><span class="line"></span><br><span class="line">grep -nc -f grep_pattern /etc/passwd           //搜索规则文件中的内容；grep_pattern文件中内容： </span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> grep_pattern</span><br><span class="line">^linuxtechi</span><br><span class="line">root</span><br><span class="line"><span class="literal">false</span>$</span><br><span class="line">$</span><br><span class="line"></span><br><span class="line">grep -nc -B 4 <span class="string">&quot;games&quot;</span> /etc/passwd             //打印在模式匹配之前的四行</span><br><span class="line">grep -nc -A 4 <span class="string">&quot;games&quot;</span> /etc/passwd             //打印在模式匹配后四行</span><br><span class="line">grep -nc -C 4 <span class="string">&quot;games&quot;</span> /etc/passwd             //打印在模式匹配周围四行</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h3><p><a href="https://blog.csdn.net/baidu_36602427/article/details/86551862" title="   https://blog.csdn.net/baidu_36602427/article/details/86551862">   https://blog.csdn.net/baidu_36602427&#x2F;article&#x2F;details&#x2F;86551862</a></p>
<p><a href="https://blog.csdn.net/weixin_48016395/article/details/123197489#:~:text=sudo%20apt-get%20install%20package%20%E5%AE%89%E8%A3%85%E5%8C%85%20sudo%20apt-get%20remove,search%20package%20%E6%90%9C%E7%B4%A2%E8%BD%AF%E4%BB%B6%E5%8C%85%20sudo%20apt-cache%20show%20package%20%E8%8E%B7%E5%8F%96%E5%8C%85%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%A6%82%E8%AF%B4%E6%98%8E%E3%80%81%E5%A4%A7%E5%B0%8F%E3%80%81%E7%89%88%E6%9C%AC%E7%AD%89" title=" Ubuntu使用apt管理安装软件包_ubuntu安装apt_白白甜甜冰的博客-CSDN博客 一、apt简介 apt 是 Advanced Packaging Tool 的简称，是一款安装包管理工具。在 Ubuntu 下，我们可以使用 apt 命令可用于软件包的安装、删除、清理等，类似于 Windows 中的软件管理工具。 二、apt管理软件包的相关命令sudo apt-get update 更新源sudo apt-get install package 安装包 sudo apt-get  https://blog.csdn.net/weixin_48016395/article/details/123197489#:~:text=sudo%20apt-get%20install%20package%20%E5%AE%89%E8%A3%85%E5%8C%85%20sudo%20apt-get%20remove,search%20package%20%E6%90%9C%E7%B4%A2%E8%BD%AF%E4%BB%B6%E5%8C%85%20sudo%20apt-cache%20show%20package%20%E8%8E%B7%E5%8F%96%E5%8C%85%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%A6%82%E8%AF%B4%E6%98%8E%E3%80%81%E5%A4%A7%E5%B0%8F%E3%80%81%E7%89%88%E6%9C%AC%E7%AD%89"> Ubuntu使用apt管理安装软件包_ubuntu安装apt_白白甜甜冰的博客-CSDN博客 一、apt简介 apt 是 Advanced Packaging Tool 的简称，是一款安装包管理工具。在 Ubuntu 下，我们可以使用 apt 命令可用于软件包的安装、删除、清理等，类似于 Windows 中的软件管理工具。 二、apt管理软件包的相关命令sudo apt-get update 更新源sudo apt-get install package 安装包 sudo apt-get  https://blog.csdn.net/weixin_48016395&#x2F;article&#x2F;details&#x2F;123197489#:~:text&#x3D;sudo%20apt-get%20install%20package%20%E5%AE%89%E8%A3%85%E5%8C%85%20sudo%20apt-get%20remove,search%20package%20%E6%90%9C%E7%B4%A2%E8%BD%AF%E4%BB%B6%E5%8C%85%20sudo%20apt-cache%20show%20package%20%E8%8E%B7%E5%8F%96%E5%8C%85%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%A6%82%E8%AF%B4%E6%98%8E%E3%80%81%E5%A4%A7%E5%B0%8F%E3%80%81%E7%89%88%E6%9C%AC%E7%AD%89</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/apt/sources.list                 //修改软件源（包存储服务器）</span><br><span class="line">apt-get update                            //更新源</span><br><span class="line"></span><br><span class="line">apt-cache search sqlite                      //搜索软件包</span><br><span class="line">apt-cache show sqlite                       //获取包的相关信息，如说明、大小、版本等</span><br><span class="line"></span><br><span class="line">apt-get install sqlite                     //安装</span><br><span class="line">apt-get install sqlite --reinstall       //重新安装包</span><br><span class="line"></span><br><span class="line">apt-get upgrade                         //更新已安装的包</span><br><span class="line"></span><br><span class="line">apt-get remove sqlite                      //删除包</span><br><span class="line">apt-get remove sqlite --purge          //删除包，包括配置文件等</span><br><span class="line"></span><br><span class="line">apt-get -f install 修复安装</span><br><span class="line"></span><br><span class="line">apt-get dist-upgrade                 //升级系统</span><br><span class="line"></span><br><span class="line">//查看已安装包的小工具</span><br><span class="line">apt-get install aptitude</span><br><span class="line">aptitude show sqlite                  //查看本机sqlite包</span><br><span class="line"></span><br><span class="line"><span class="comment">#）源码安装</span></span><br><span class="line">1）</span><br><span class="line">apt-get <span class="built_in">source</span> sqlite                  //下载该包的源代码</span><br><span class="line">2）</span><br><span class="line">apt-cache depends sqlite               //了解使用该包依赖那些包</span><br><span class="line">apt-cache rdepends sqlite              //查看该包被哪些包依赖</span><br><span class="line">apt-get check                          //检查是否有损坏的依赖</span><br><span class="line">apt-get build-dep sqlite               //安装相关的编译环境</span><br><span class="line">apt-get clean &amp;&amp; apt-get autoclean       //清理无用的包</span><br><span class="line">3）解压</span><br><span class="line">4）<span class="built_in">cd</span> sqlite &amp;&amp; ./configure            //检测文件是否缺失，生成Makefile,检测编译环境</span><br><span class="line">5)make                                 //编译源码，生成库和可执行程序</span><br><span class="line">6）make install                        //把库和可执行程序，安装到系统路径下</span><br><span class="line">make distclean                         //删除和卸载软件</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">du</span> -ah ./src            //查看路径所占用的磁盘空间；会递归列出其下各目录文件情况</span><br><span class="line"><span class="built_in">du</span> -ah src | <span class="built_in">sort</span> -nr    //按大小排序</span><br><span class="line"><span class="built_in">du</span> -sh ./src           //只显示src目录占用的磁盘空间总大小</span><br><span class="line"><span class="built_in">du</span> -h --max-depth src   //输出当前目录下各个子目录所使用的空间</span><br><span class="line"><span class="built_in">du</span> -c a.log b.log       //显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="压缩包管理"><a href="#压缩包管理" class="headerlink" title="压缩包管理"></a>压缩包管理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gz算法：</span><br><span class="line">tar zcvf xvjin.tar.gz d1 f2             //将d1，f2压缩为xvjin.tar.gz</span><br><span class="line">tar zxvf xvjin.tar.gz -C ./tmp                  //解压到tmp文件夹</span><br><span class="line"></span><br><span class="line">bz2算法:</span><br><span class="line">tar jcvf xvjin.tar.bz2 d1 f2 </span><br><span class="line">tar jxvf xvjin.tar.bz2</span><br><span class="line"></span><br><span class="line">rar:</span><br><span class="line">rar a -r newdir d1                      //将d1压缩成newdir.rar</span><br><span class="line">unrar x newdir.rar                      //解压</span><br><span class="line"></span><br><span class="line">zip:</span><br><span class="line">zip -r newdir.zip d1                      //将d1压缩成newdir.zip</span><br><span class="line">unzip newdir.zip </span><br></pre></td></tr></table></figure>

<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -aux                                    //进程管理器</span><br><span class="line">ps -Lf 2423                                 //显示pid为2423的进程</span><br><span class="line">ps -aux | grep chrome                       //进程过滤出chrome</span><br><span class="line">top                                      //文字UI的进程管理器</span><br><span class="line"></span><br><span class="line">//cmd+&amp;后台运行/或ctrl+z</span><br><span class="line"><span class="built_in">cat</span> &amp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">jobs</span>                                 //查看后台作业</span><br><span class="line"></span><br><span class="line"><span class="built_in">fg</span> %1                                //把挂起的作业1移到前台</span><br><span class="line"><span class="built_in">bg</span> 5893</span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span> -SIGKILL 5893                   //强制终止进程5893，适用于不能处理信号的进程</span><br><span class="line"><span class="built_in">kill</span> 5893                            //给进程5893发终止信号</span><br><span class="line"></span><br><span class="line">free -m                           //查看空闲内存</span><br><span class="line"></span><br><span class="line"><span class="built_in">env</span>                                 //环境变量列表</span><br><span class="line"><span class="built_in">export</span> PATH=./lib                   //设置当前shell进程的临时环境变量(PATH,ARCH , CROSS_COMPILE)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig                                //查看网卡信息</span><br><span class="line"></span><br><span class="line">ifconfig eth0 up                        //开启网卡eth0</span><br><span class="line">ifconfig eth0 down                       //关闭网卡</span><br><span class="line"></span><br><span class="line">ifconfig eth0 192.168.120.110          //给eth0配置临时IP</span><br><span class="line"></span><br><span class="line">ping</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="常用服务器构建"><a href="#常用服务器构建" class="headerlink" title="常用服务器构建"></a>常用服务器构建</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>man man</p>
<p><img src="/image/image_9Rgpa7aLox.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">命令 --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">man -k <span class="built_in">read</span> | grep transform                //以<span class="built_in">read</span>为关键字查找相关的man page，并过滤出transform 相关内容</span><br><span class="line">man 2 <span class="built_in">read</span>                            //在2section查看<span class="built_in">read</span></span><br><span class="line"></span><br><span class="line">clear                          //清屏;快捷键：Ctrl-l</span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span>                      //别名列表</span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -alh&#x27;</span>           //取别名</span><br><span class="line"></span><br><span class="line"><span class="built_in">date</span>                           //查看时间</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;text&quot;</span></span><br><span class="line"></span><br><span class="line">sudo poweroff                         //切断电源</span><br><span class="line"></span><br><span class="line">shutdown -r now                            //立刻重新开机</span><br><span class="line">shutdown -t3 -r now                            //立刻重新开机, 但在警告和删除processes 之间, 延迟3秒钟.</span><br><span class="line">reboot</span><br><span class="line"></span><br><span class="line">shutdown -h now                            //立刻关机</span><br><span class="line">shutdown -r 10 <span class="string">&#x27;Hey! Go away!&#x27;</span>          //10 分钟後关机</span><br><span class="line">shutdown -k now <span class="string">&#x27;Hey! Go away! now....&#x27;</span>          //发出警告讯息, 但没有真的关机</span><br><span class="line">shutdown -h 10:42 <span class="string">&#x27;Hey! Go away!&#x27;</span>          //10:42 分关机</span><br><span class="line"></span><br><span class="line"><span class="built_in">uname</span> -a                           //查看内核版本</span><br><span class="line"></span><br><span class="line">lsb_release -a                           //查看发行版本信息</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.查看网卡信息</span><br><span class="line">ifconfig</span><br><span class="line">2.关闭网卡</span><br><span class="line">sudo ifconfig eth0 down</span><br><span class="line">3.开启网卡eth0</span><br><span class="line">sudo ifconfig eth0 up</span><br><span class="line">4.给eth0配置临时IP</span><br><span class="line">sudo ifconfig eth0 IP</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>echo:打印字符串或者打印变量的值(比如打印出PATH),也可以echo xxx &gt; 1.txt,即进行cin操作</p>
<p>sudo gedit &#x2F;etc&#x2F;enviroment用gedit编辑器编辑环境变量,然后需要重启,sudo使普通权限用户具备管理员允许的高级权限</p>
<p><img src="/image/image_FdKS7ys3i0.png"></p>
<p>chmod xxx file_name编辑文件权限xxx是9位二进制表示的权限的十进制形式(拥有者,组,其他)</p>
<blockquote>
<p>直接键入程序名shell会去PATH找这个程序</p>
</blockquote>
<p><img src="/image/image_7VoPcJmkoq.png"></p>
<p>注意：&#x20;</p>
<p>如果没有指定查找目录，则为当前目录。</p>
<p>&#x20;</p>
<p><img src="/image/image_1aJwL6RmQh.png"></p>
<p>$ find . -name “ *.txt “    <a href="//xn--fiqw3f.xn--mnq06f04pwfl25qw6g" title="//其中.代表当前路径">&#x2F;&#x2F;其中.代表当前路径</a>。 &#x20;</p>
<p>$ find -name “ *.txt “      &#x2F;&#x2F;没加路径，默认是当前路径下查找。&#x20;</p>
<p>find 还有一些高级的用法，如查找最近几天(几个小时)之内(之前)有变动的文件 &#x20;</p>
<p>$ find  &#x2F;home&#x2F;book  -mtime -2       &#x2F;&#x2F;查找&#x2F;home 目录下两天内有变动的文件。</p>
<p>其他命令:</p>
<p>定位</p>
<p>which   命令名&#x2F;应用程序名&#x20;<br>whereis  命令名&#x2F;应用程序名</p>
<p>设置密码</p>
<p>sudu passwd root&#x2F;book</p>
<p>su root&#x2F;book切换用户</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序 selection sort</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%20selection%20sort/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%20selection%20sort/</url>
    <content><![CDATA[<p>退化分治（子问题间存在依赖，必须先解决前面的才能解决后面的）+枚举策略：<br>设数组长度 n，排序&#x3D;枚举n个数中找到最小值放在索引0+枚举剩下n-1个数中找到次小值放在索引1。。。。。。。<br>外循环缩小排序区间；内循环遍历比较,每次比较更小值留下跟后面继续比（放在一个迭代器K（目前最小值）中），内循环结束后k为本区间最小值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 选择排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 外循环：未排序区间为 [i, n-1]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;<span class="comment">//是n-1而不是n因为排序区间缩小到n-1索引时只剩一个值，就是最大值</span></span><br><span class="line">        <span class="comment">// 内循环：找到未排序区间内的最小元素</span></span><br><span class="line">        <span class="type">int</span> k = i;<span class="comment">//设最小值为k</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;<span class="comment">//从j到size-1</span></span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[k])</span><br><span class="line">                k = j; <span class="comment">// 记录最小元素的索引</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将该最小元素与未排序区间的首个元素交换</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度为 O(n^2)、非自适应排序</strong>：外循环共 n−1 轮，第一轮的未排序区间长度为 n ，最后一轮的未排序区间长度为 2 ，即各轮外循环分别包含 n、n−1、…、3、2 轮内循环，求和为 $\frac{(n−1)(n+2)}{2}$&#x20;</li>
<li><strong>空间复杂度 O(1)、原地排序</strong>：指针 i 和 j使用常数大小的额外空间。</li>
<li><strong>非稳定排序</strong>：元素 <code>nums[i]</code> 有可能被交换至与其相等的元素的右边，导致两者相对顺序发生改变。</li>
</ul>
<p><img src="/image/image_LlNnFiYkcG.png"></p>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法 greedy algorithm</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%20greedy%20algorithm/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%20greedy%20algorithm/</url>
    <content><![CDATA[<p>每一步决策都选局部最优解，进而导致全局最优解。<br>严格应用greedy algorithm：必然要证明：<strong>全局最优解能由局部最优解（子问题的优解）构造</strong></p>
<p>贪心算法和动态规划都常用于解决优化问题。它们之间存在一些相似之处，比如都依赖最优子结构性质，但工作原理是不同的：</p>
<ul>
<li>贪心算法不会重新考虑过去的决策，而是一路向前地进行贪心选择，不断缩小问题范围，直至问题被解决。</li>
<li>动态规划根据之前阶段的所有决策来考虑当前决策，并使用过去子问题的解来构建当前子问题的解。</li>
</ul>
<p><img src="/image/image_BF-simJpCh.png"></p>
<p>有一篇论文给出了一个 O(n^3) 时间复杂度的算法，用于判断一个硬币组合是否可以使用贪心算法找出任何金额的最优解。</p>
<p>Pearson, David. A polynomial-time algorithm for the change-making problem. Operations Research Letters 33.3 (2005): 231-234.</p>
<h2 id="贪心优点与局限性"><a href="#贪心优点与局限性" class="headerlink" title="贪心优点与局限性"></a>贪心优点与局限性</h2><p>严格使用要给出可行性证明</p>
<h2 id="贪心典型例题"><a href="#贪心典型例题" class="headerlink" title="贪心典型例题"></a>贪心典型例题</h2><p>贪心算法常常应用在满足贪心选择性质和最优子结构的优化问题中，以下列举了一些典型的贪心算法问题。</p>
<ul>
<li><strong>硬币找零问题</strong>：在某些硬币组合下，贪心算法总是可以得到最优解。</li>
<li><strong>区间调度问题</strong>：假设你有一些任务，每个任务在一段时间内进行，你的目标是完成尽可能多的任务。如果每次都选择结束时间最早的任务，那么贪心算法就可以得到最优解。</li>
<li><strong>分数背包问题</strong>：给定一组物品和一个载重量，你的目标是选择一组物品，使得总重量不超过载重量，且总价值最大。如果每次都选择性价比最高（价值 &#x2F; 重量）的物品，那么贪心算法在一些情况下可以得到最优解。</li>
<li><strong>股票买卖问题</strong>：给定一组股票的历史价格，你可以进行多次买卖，但如果你已经持有股票，那么在卖出之前不能再买，目标是获取最大利润。</li>
<li><strong>霍夫曼编码</strong>：霍夫曼编码是一种用于无损数据压缩的贪心算法。通过构建霍夫曼树，每次选择出现频率最小的两个节点合并，最后得到的霍夫曼树的带权路径长度（即编码长度）最小。</li>
<li><strong>Dijkstra 算法</strong>：它是一种解决给定源顶点到其余各顶点的最短路径问题的贪心算法。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>重复操作（迭代&amp;递归）</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E9%87%8D%E5%A4%8D%E6%93%8D%E4%BD%9C%EF%BC%88%E8%BF%AD%E4%BB%A3&amp;%E9%80%92%E5%BD%92%EF%BC%89/%E9%87%8D%E5%A4%8D%E6%93%8D%E4%BD%9C%EF%BC%88%E8%BF%AD%E4%BB%A3&amp;%E9%80%92%E5%BD%92%EF%BC%89/</url>
    <content><![CDATA[<h2 id="迭代iteration"><a href="#迭代iteration" class="headerlink" title="迭代iteration"></a>迭代iteration</h2><p>随参数变化进行重复操作;其典型就是各种循环，嵌套结构<br><code>for</code> 循环是最常见的迭代形式之一，<strong>适合预先知道迭代次数时使用</strong>。需注意的是，Python 中 <code>range(a, b)</code> 对应的区间是“左闭右开”的，对应的遍历范围为 a,a+1,…,b−1&#x20;</p>
<p><img src="/image/image_gioLlUT71L.png"></p>
<p><img src="/image/image_OcaOHgI-wr.png"></p>
<h2 id="递归recursion"><a href="#递归recursion" class="headerlink" title="递归recursion"></a>递归recursion</h2><p>通过函数调用自身来解决问题。包含两阶段</p>
<ol>
<li><strong>递</strong>：程序一级级调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。</li>
<li><strong>归</strong>：触发“终止条件”后，程序从最深层的递归函数开始逐层把解返回上一层，最终构建原问题的解</li>
</ol>
<p>从实现的角度看，递归代码主要包含三要素</p>
<ol>
<li><strong>终止条件</strong>：用于决定什么时候由“递”转“归”。</li>
<li><strong>递归调用</strong>：对应“递”，函数调用自身，通常输入更小或更简化的参数。</li>
<li><strong>返回结果</strong>：对应“归”，将当前递归层级的结果返回至上一层。</li>
</ol>
<p><img src="/image/image_-QUL99FZUr.png"></p>
<h3 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h3><p><a href="../../%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/C.md" title="C">C</a>参考栈帧部分</p>
<p>递归函数每次调用自身时，系统都会在栈区分配内存，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果。在触发终止条件前，同时存在 n 个未返回的递归函数，<strong>递归深度为 n</strong> 。</p>
<ul>
<li>函数的上下文数据都存储在称为“栈帧空间”的内存区域中，直至函数返回后才会被释放。因此，<strong>递归通常比迭代更加耗费内存空间</strong>。</li>
<li>递归调用会产生额外开销。<strong>因此通常比循环时间效率低</strong></li>
</ul>
<p><img src="/image/image_yadn-YSsoh.png"></p>
<h3 id="尾递归tail-recursion"><a href="#尾递归tail-recursion" class="headerlink" title="尾递归tail recursion"></a>尾递归tail recursion</h3><p><strong>若函数在返回前的最后一步才进行递归调用</strong>，则该函数可被某些语言的编译器&#x2F;解释器优化，使其在空间效率上与迭代相当<br>尾递归优化原理：以计算 1+2+⋯+n 为例f（n）&#x3D;n+f(n-1)</p>
<p><img src="/image/image_k1yOC5fNN6.png"></p>
<p><img src="/image/image_XWILw2wK-U.png"></p>
<ul>
<li><strong>普通递归</strong>：解决原问题f(n)需递归地解决n+f(n-1)这种形式的子问题；每级向下调用都要暂存n参数等待下级调用返回再计算；如此每级调用都会push一个栈帧，产生额外开销</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 递归 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">recur</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 递：递归调用</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">recur</span>(n - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 归：返回结果</span></span><br><span class="line">    <span class="keyword">return</span> n + res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>尾递归</strong>：解决原问题f(n)需递归地解决n+f(n-1)这种形式的子问题；<strong>每级向下调用都把本要暂存的n参数传参到下级调用；如此到最后一级调用再把每级收集的参数加入计算</strong>；某些编译器识别到这种情况；便会进行优化；节约每级调用产生栈帧的开销；<br>递归树向下传递会有栈帧开销的原因是要暂存数据等回归时计算，把这些数据即时计算了在传递下去，则暂存栈帧是多余的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 尾递归 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tailRecur</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> res)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// 尾递归调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tailRecur</span>(n - <span class="number">1</span>, res + n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代模拟递归"><a href="#迭代模拟递归" class="headerlink" title="迭代模拟递归"></a>迭代模拟递归</h3><p>思路是：<strong>用一个显式的栈模拟调用栈的行为</strong>；递归多少层，栈就应该多少层；<br>递：通过迭代计算出每级递归暂存的参数push into stack<br>归：然后遍历pop stack一级级计算返回值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 使用迭代模拟递归 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">forLoopRecur</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用一个显式的栈来模拟系统调用栈</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 递：递归调用</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 通过“入栈操作”模拟“递”</span></span><br><span class="line">        stack.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 归：返回结果</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 通过“出栈操作”模拟“归”</span></span><br><span class="line">        res += stack.<span class="built_in">top</span>();</span><br><span class="line">        stack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// res = 1+2+3+...+n</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用途：尽管迭代和递归在很多情况下可以互相转换，但也不一定值得这样做</p>
<ul>
<li>对于某些复杂问题，模拟系统调用栈的行为可能非常困难。</li>
<li>当递归被转换为迭代后，代码可能变得更复杂（可读性更差）</li>
</ul>
<p>总之，<strong>选择迭代还是递归取决于特定问题的性质</strong>。在编程实践中，权衡两者的优劣并根据情境选择合适的方法</p>
<p>递归常见3种优化：<br>1）写成尾递归→编译器自动进行尾递归优化<br>&#x20;                     →手动改写成迭代进行尾递归优化（因为没有尾递归优化还是会暂存调用现场）</p>
<p><a href="https://zhuanlan.zhihu.com/p/36587160" title=" 尾递归为啥能优化？ 扩展阅读brambles：通用的递归转循环方法前言这篇文章其实是我两年以前写的，文尾给自己开了一个坑，说是要手写一个自动将尾递归的函数优化成一个用循环迭代的函数，结果这坑一拖就是两年，我也差不多忘了有这回事… https://zhuanlan.zhihu.com/p/36587160"> 尾递归为啥能优化？ 扩展阅读brambles：通用的递归转循环方法前言这篇文章其实是我两年以前写的，文尾给自己开了一个坑，说是要手写一个自动将尾递归的函数优化成一个用循环迭代的函数，结果这坑一拖就是两年，我也差不多忘了有这回事… https://zhuanlan.zhihu.com/p/36587160</a></p>
<p>2）直接改写成迭代形式<br>3）</p>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>队列queue</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E9%98%9F%E5%88%97queue/%E9%98%9F%E5%88%97queue/</url>
    <content><![CDATA[<p>遵循先入先出规则的线性数据结构。队列头部称为“队首”，尾部称为“队尾”，将把元素加入队尾的操作称为“入队”，删除队首元素的操作称为“出队”。</p>
<p><img src="https://www.hello-algo.com/chapter_stack_and_queue/queue.assets/queue_operations.png"></p>
<h3 id="队列常用操作"><a href="#队列常用操作" class="headerlink" title="队列常用操作"></a>队列常用操作</h3><p><img src="/image/image_ZszKYnS0p9.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 初始化队列 */</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; queue;</span><br><span class="line"><span class="comment">/* 元素入队 */</span></span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">queue.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line"><span class="comment">/* 访问队首元素 */</span></span><br><span class="line"><span class="type">int</span> front = queue.<span class="built_in">front</span>();</span><br><span class="line"><span class="comment">/* 元素出队 */</span></span><br><span class="line">queue.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">/* 获取队列的长度 */</span></span><br><span class="line"><span class="type">int</span> size = queue.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">/* 判断队列是否为空 */</span></span><br><span class="line"><span class="type">bool</span> empty = queue.<span class="built_in">empty</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="队列实现"><a href="#队列实现" class="headerlink" title="队列实现"></a>队列实现</h3><p>可在一端添加元素，并在另一端删除元素的数据结构。因此，链表和数组都可以用来实现队列。</p>
<h4 id="1-基于链表的实现"><a href="#1-基于链表的实现" class="headerlink" title="1.   基于链表的实现"></a>1.   基于链表的实现</h4><p>可将链表“头节点”和“尾节点”分别视为“队首”和“队尾”，规定队尾仅可添加节点，队首仅可删除节点</p>
<p><img src="/image/image_2hNc01pfyI.png"></p>
<p><img src="/image/image_3pLJG0tjb6.png"></p>
<p><img src="/image/image_GmsdAXGai5.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基于链表实现的队列 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedListQueue</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    ListNode *front, *rear; <span class="comment">// 头节点 front ，尾节点 rear</span></span><br><span class="line">    <span class="type">int</span> queSize;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkedListQueue</span>() &#123;</span><br><span class="line">        front = <span class="literal">nullptr</span>;</span><br><span class="line">        rear = <span class="literal">nullptr</span>;</span><br><span class="line">        queSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">LinkedListQueue</span>() &#123;</span><br><span class="line">        <span class="comment">// 遍历链表删除节点，释放内存</span></span><br><span class="line">         <span class="built_in">freeMemoryLinkedList</span>(front); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取队列的长度 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断队列是否为空 */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queSize == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 入队 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 尾节点后添加 num</span></span><br><span class="line">        ListNode *node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(num);</span><br><span class="line">        <span class="comment">// 如果队列为空，则令头、尾节点都指向该节点</span></span><br><span class="line">        <span class="keyword">if</span> (front == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            front = node;</span><br><span class="line">            rear = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果队列不为空，则将该节点添加到尾节点后</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            rear-&gt;next = node;</span><br><span class="line">            rear = node;</span><br><span class="line">        &#125;</span><br><span class="line">        queSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 出队 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">peek</span>();</span><br><span class="line">        <span class="comment">// 删除头节点</span></span><br><span class="line">        ListNode *tmp = front;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        queSize--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问队首元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> front-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将链表转化为 Vector 并返回 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">toVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListNode *node = front;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            res[i] = node-&gt;val;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-基于数组的实现"><a href="#2-基于数组的实现" class="headerlink" title="2.   基于数组的实现"></a>2.   基于数组的实现</h4><p>由于数组删除首元素的时间复杂度为 O(n) ，这会导致出队操作效率较低。可采用以下方法避免这个问题。</p>
<p>我们可以使用一个变量 <code>front</code> 指向队首元素的索引，并维护一个变量 <code>size</code> 用于记录队列长度。定义 <code>rear = front + size</code> ，这个公式计算出的 <code>rear</code> 指向队尾元素之后的下一个位置。</p>
<p>基于此设计，**数组中包含元素的有效区间为<code>[front, rear - 1]</code>**，各种操作的实现方法如图 5-6 所示。</p>
<ul>
<li>入队操作：将输入元素赋值给 <code>rear</code> 索引处，并将 <code>size</code> 增加 1 。</li>
<li>出队操作：只需将 <code>front</code> 增加 1 ，并将 <code>size</code> 减少 1 。</li>
</ul>
<p>可以看到，入队和出队操作都只需进行一次操作，时间复杂度均为 �(1) 。</p>
<p><img src="/image/image_2rHBBh8kSB.png"></p>
<p><img src="/image/image_wopj38EUqU.png"></p>
<p><img src="/image/image_zyhO0OmXia.png"></p>
<p>不断入队和出队，<code>front</code> 和 <code>rear</code> 都在向右移动，<strong>当rear到达数组尾部时就无法继续移动了</strong>。可将数组视为首尾相接的“环形数组”。对于环形数组，我们需要让 <code>front</code> 或 <code>rear</code> 在越过数组尾部时，直接回到数组头部继续遍历。这种周期性规律可以通过“取余操作”实现（队列是模系统）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基于环形数组实现的队列 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayQueue</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *nums;       <span class="comment">// 用于存储队列元素的数组</span></span><br><span class="line">    <span class="type">int</span> front;       <span class="comment">// 队首指针，指向队首元素</span></span><br><span class="line">    <span class="type">int</span> queSize;     <span class="comment">// 队列长度</span></span><br><span class="line">    <span class="type">int</span> queCapacity; <span class="comment">// 队列容量</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ArrayQueue</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        <span class="comment">// 初始化数组</span></span><br><span class="line">        nums = <span class="keyword">new</span> <span class="type">int</span>[capacity];</span><br><span class="line">        queCapacity = capacity;</span><br><span class="line">        front = queSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ArrayQueue</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取队列的容量 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取队列的长度 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 判断队列是否为空 */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">size</span>() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 入队 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queSize == queCapacity) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;队列已满&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算队尾指针，指向队尾索引 + 1</span></span><br><span class="line">        <span class="comment">// 通过取余操作，实现 rear 越过数组尾部后回到头部</span></span><br><span class="line">        <span class="type">int</span> rear = (front + queSize) % queCapacity;<span class="comment">//模queCapacity系统首尾相连，0=queCapacity</span></span><br><span class="line">        <span class="comment">// 将 num 添加至队尾</span></span><br><span class="line">        nums[rear] = num;</span><br><span class="line">        queSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 出队 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">peek</span>();</span><br><span class="line">        <span class="comment">// 队首指针向后移动一位，若越过尾部则返回到数组头部</span></span><br><span class="line">        front = (front + <span class="number">1</span>) % queCapacity;</span><br><span class="line">        queSize--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问队首元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> nums[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将数组转化为 Vector 并返回 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">toVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 仅转换有效长度范围内的列表元素</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(queSize)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = front; i &lt; queSize; i++, j++) &#123;</span><br><span class="line">            arr[i] = nums[j % queCapacity];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上实现的队列仍然具有局限性，即其长度不可变。然而，这个问题不难解决，我们可以将数组替换为动态数组，从而引入扩容机制。有兴趣的同学可以尝试自行实现。？？？？？？？</p>
<p>两种实现的对比结论与栈一致，在此不再赘述。</p>
<h3 id="队列典型应用"><a href="#队列典型应用" class="headerlink" title="队列典型应用"></a>队列典型应用</h3><ul>
<li><strong>淘宝订单</strong>。购物者下单后，订单将加入队列中，系统随后会根据顺序依次处理队列中的订单。在双十一期间，短时间内会产生海量订单，高并发成为工程师们需要重点攻克的问题。</li>
<li><strong>各类待办事项</strong>。任何需要实现“先来后到”功能的场景，例如打印机的任务队列、餐厅的出餐队列等。队列在这些场景中可以有效地维护处理顺序。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>程序运行时，程序的数据会加载到内存；<strong>裸机 CPU 直接操作内存的「物理地址」</strong>；如果想在内存中并发运行两个程序，各进程却共享相同的物理内存简直灾难；</p>
<p>内存管理为了解决以下问题：<br>1）内存冲突→虚拟内存；使得进程之间的内存地址互不影响<br>2）虚拟内存地址映射物理地址→MMU，页表维护虚拟页与物理页的映射关系<br>3）内存碎片→内存分页<br>4)逻辑段与虚拟内存地址间的映射关系→段表维护段号与页表基地址关系；页表维护虚拟页与物理页的映射关系<br>5）页表项时空复杂度问题：页表树节约存储,TLB解决页表树时间复杂度上升问题<br>6）内存资源紧张→内存交换：CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域</p>
<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a><strong>虚拟内存</strong></h1><p>每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响</p>
<p><img src="/image/image_xBa7Q_F2EV.png"></p>
<p><img src="/image/image_ba9ELML_Gd.png"></p>
<p><img src="/image/image_LhUQGPEu0l.png"></p>
<p>每个进程都独立占有一套<strong>虚拟地址空间</strong>；操作内存时，cpu通过对TLB或段表，页表查询虚拟地址对应的物理页表基地址；再通过内存管理单元（MMU）把物理页基地址+偏移地址映射到物理地址；虚拟内存可使进程运行内存超过物理内存；</p>
<p>由于进程无法访问其他进程的页表（私有），解决了多进程间地址冲突问题；</p>
<p>32位地址总线的地址空间0x0~0xffff ffff大小就是$2^{32}&#x3D;4G;G&#x3D;2^{10}*2^{10}*2^{10}$；每个地址指向一个字节，<strong>虚拟空间</strong>大小为4GB</p>
<p>Linux下虚拟地址空间的内部又被分为<strong>内核空间和用户空</strong>间：</p>
<p><img src="/image/image_s15d6Bk4FA.png"></p>
<p>用户态虚拟内存空间为 3 GB，虚拟内存地址范围为：0x0000 0000 - 0xC000 000&#x20;<br>内核态虚拟内存空间为 1 GB，虚拟内存地址范围为：0xC000 000 - 0xFFFF FFFF<br>不可访问的保留区: C 语言中我们通常会将一些无效的指针设置为 NULL，指向这块不允许访问的地址</p>
<ul>
<li>代码段，包括二进制可执行代码；</li>
<li>数据段，包括已初始化的静态常量和全局变量；</li>
<li>BSS 段，包括未初始化的静态变量和全局变量；</li>
<li>堆段，包括动态分配的内存，从低地址开始向上增长；</li>
<li>文件映射段，包括动态库、共享内存等，从低地址开始向上增长（<a href="http://lishiwen4.github.io/linux/linux-process-memory-location" title="跟硬件和内核版本有关 (opens new window)">跟硬件和内核版本有关 (opens new window)</a>）；</li>
<li>栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 <code>8 MB</code>。当然系统也提供了参数，以便我们自定义大小；</li>
</ul>
<p>上图中的内存布局可以看到，代码段下面还有一段内存空间的（灰色部分），这一块区域是「保留区」，之所以要有保留区这是因为在大多数的系统里，我们认为比较小数值的地址不是一个合法地址，例如，我们通常在 C 的代码里会将无效的指针赋值为 NULL。因此，这里会出现一段不可访问的内存保留区，防止程序因为出现 bug，导致读或写了一些小内存地址的数据，而使得程序跑飞。</p>
<p>在这 7 个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的 <code>malloc()</code> 或者 <code>mmap()</code> ，就可以分别在堆和文件映射段动态分配内存</p>
<h1 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h1><p><img src="/image/image_ROzb8ueuCN.png"></p>
<p><img src="/image/image_TJ5lWPh2X2.png"></p>
<p><strong>分页是把虚拟&#x2F;物理内存空间划分</strong>为连续且尺寸固定的内存空间（<strong>页</strong><em>Page</em>）； Linux 下每页大小 <code>4KB</code>；若内存不以固定的页单位分配，释放；会产生内存碎片（进程需要连续的空闲内存，离散分布的空闲内存的容纳能力取决于最大连续空闲内存）</p>
<h1 id="内存交换"><a href="#内存交换" class="headerlink" title="内存交换"></a><strong>内存</strong>交换</h1><p>os会把「最近没被使用」的内存页释放掉，也就是暂时写在硬盘上，称为<strong>换出</strong>（<em>Swap Out</em>）。需要时再加载进来，称为<strong>换入</strong>（<em>Swap In</em>）；<strong>机器卡顿</strong>的原因之一</p>
<p>内存交换空间，在 Linux 系统下称为 Swap 空间，这块空间从硬盘划分出来用于内存与硬盘的空间交换</p>
<h1 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h1><p><img src="/image/image_cApb-RJlea.png"></p>
<p><img src="/image/image_4Cwy9VlWwr.png"></p>
<p>程序运行时数据可分为逻辑段：汇编层面为代码段** +<strong>数据段</strong> **+堆栈段+扩展段；这样同属性数据都放在了一块连续空间；</p>
<p>在程序开始运行时，os将可执行文件中的代码段载入物理内存，并建立虚拟内存地址到物理地址的映射。当执行到操作内存指令时，指令所需数据从可执行文件中的数据段载入到内存中。此时，os根据虚拟地址到物理地址的映射关系，对物理内存数据段进行操作；</p>
<p>CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域<br>**<br><strong>段页式内存管理</strong>虚拟地址(win)&#x3D;段号+段内页号+页内位移**<br>页式内存管理<strong>虚拟地址（linux）&#x3D;多级页号+页内位移</strong></p>
<p>虚拟地址到物理地址的映射关系主要由段表和页表维护：<br>页式内存管理:段表维护段号与页表基地址关系（该段存在哪些页里边）；页表维护该段页号与物理页基地址的映射关系（页的物理地址）；页表里的页表项还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等</p>
<p>页式内存管理:段基地址缺省为0；主要由页表维护该段页号与物理页基地址的映射关系（页的物理地址）</p>
<p><img src="/image/image_xJH-7n4icx.png"></p>
<p><img src="/image/image_tvvesMQyJ1.png"></p>
<h2 id="页表树"><a href="#页表树" class="headerlink" title="页表树"></a>页表树</h2><p>32 位环境下，虚拟空间共有 $2^{32}$B&#x3D;4GB，假设一个页的大小 4KB（2^12），那么虚拟内存就要划分2^20 页，每个「页表项」需要 4 字节存储页表基地址，需要 <code>4MB</code> 内存存储页表；每个进程都有自己的页表；进程创建时默认就有4MB开销；运行多个进程时是非常大的内存了，更别说 64 位环境了</p>
<p>所以页表项引入页表树来维护：2^20&#x3D;1024*1024个页表项可划分为每层1024个节点的2级页表；如果按深度优先序去建表，那么最后没用到的连续的页表虚拟基地址的页表项就不用建立，且二级页表项也可等到要用时再插入节点；大大节约内存</p>
<p><img src="/image/image_Xn6aLCNX1L.png"></p>
<p>64 位环境下一般是四级目录：$2^{64}B$空间，$2^{52}$&#x3D;$2^{13}<em>$$2^{13}</em>$$2^{13}<em>$$2^{13}</em>$页;每层8K个节点<br>1）全局页目录项 PGD（<em>Page Global Directory</em><br>2）上层页目录项 PUD（<em>Page Upper Directory</em>）<br>3）中间页目录项 PMD（<em>Page Middle Directory</em><br>4）页表项 PTE（<em>Page Table Entry</em>）<br>每个进程都用一张段表维护段号与该段页表基地址关系；该段页表维护虚拟页号与物理页号的映射关系</p>
<p><img src="/image/image_z7CmDSJh0-.png"></p>
<p><img src="/image/image_tPMM5W3Jxb.png"></p>
<h2 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h2><p><img src="/image/image_Ft0oF4nx0D.png"></p>
<p><img src="/image/image_0PRgmPXC0t.png"></p>
<p>把最常访问的几个页表项存储到 CPU 芯片中的 Cache，这个 Cache 就是 TLB（<em>Translation Lookaside Buffer</em>） ，通常称为页表缓存、转址旁路缓存、快表等;<br>CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表</p>
<h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a><strong>内存</strong>分配</h1>]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>linux指南</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/linux%E6%8C%87%E5%8D%97/linux%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="x20-Linux文件组织标准-https-zhuanlan-zhihu-com-p-107263805"><a href="#x20-Linux文件组织标准-https-zhuanlan-zhihu-com-p-107263805" class="headerlink" title="&#x20;Linux文件组织标准 https://zhuanlan.zhihu.com/p/107263805"></a>&#x20;Linux文件组织标准 <a href="https://zhuanlan.zhihu.com/p/107263805" title="https://zhuanlan.zhihu.com/p/107263805">https://zhuanlan.zhihu.com/p/107263805</a></h2><p>确定每个目录下该放什么文件和数据，并希望 Linux 用户能遵循该准则</p>
<p><img src="/image/image_KEN1jWMntU.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/ 根目录</span><br><span class="line">bin //存放2进制可执行文件，如命令</span><br><span class="line">boot //内核和启动程序</span><br><span class="line">  grub //引导器相关文件</span><br><span class="line">dev //设备文件；字符设备，块设备</span><br><span class="line">etc //存放用户信息和系统配置文件；系统软件的启动配置文件，系统在启动过程中需要读取的文件都在这个目录。如LILO参数、用</span><br><span class="line">户账户和密码。</span><br><span class="line">home //用户的主目录。下面是自己定义的用户名的文件夹</span><br><span class="line">lib //系统程序库文件,这个目录里存放着系统最基本的动态链接共享库，类似于Windows下的system32</span><br><span class="line">目录，几乎所有的应用程序都需要用到这些共享库。</span><br><span class="line">media //挂载媒体设备，如光驱、U盘等</span><br><span class="line">mnt //目录是让用户临时挂载别的文件系统，如挂载Windows下的某个分区，ubuntu默认还是挂载在/media目录。</span><br><span class="line">opt //可选的应用软件包（很少使用）</span><br><span class="line">proc //这个目录是系统内存的映射，我们可以直接访问这个目录来获取系统信息。也就是说，这个目录的内容不在硬盘上而是在内存里。</span><br><span class="line">sbin //管理员系统程序</span><br><span class="line">selinux</span><br><span class="line">srv</span><br><span class="line">sys //udev用到的设备目录树，/sys反映你机器当前所接的设备</span><br><span class="line">tmp //临时文件夹</span><br><span class="line">usr //这是个最庞大的目录，用户应用程序资源目录</span><br><span class="line">  bin // 应用程序</span><br><span class="line">  game //游戏程序</span><br><span class="line">  include</span><br><span class="line">  lib //应用程序的库文件</span><br><span class="line">  lib64</span><br><span class="line">  <span class="built_in">local</span> //包含用户程序等</span><br><span class="line">  sbin //管理员应用程序</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>FHS 建议所有软件开发者都应该将数据合理地放置到usr目录的子目录下。</p>
<p>一般来说，&#x2F;usr 下的子目录有：</p>
<ul>
<li>&#x2F;usr&#x2F;bin&#x2F;：绝大部分的用户命令都在此处，它与&#x2F;bin目录的区别在于后者存放与开机相关的命令。</li>
<li>&#x2F;usr&#x2F;include&#x2F;：C&#x2F;C++的头文件和包含文件。</li>
<li>&#x2F;usr&#x2F;lib&#x2F;：包含各应用软件的函数库、目标文件，以及一些不被用户惯用的执行文件。</li>
<li>&#x2F;usr&#x2F;local&#x2F;：系统管理员在本机自行下载的软件。</li>
<li>&#x2F;usr&#x2F;sbin&#x2F;：非系统正常运行需要的系统命令。</li>
<li>&#x2F;usr&#x2F;share&#x2F;：放置共享文件的地方</li>
<li>&#x2F;usr&#x2F;src&#x2F;：源码放置的地方</li>
</ul>
<p>&#x2F;var 目录下主要放置常态化变动的文件，例如缓存、登录日志文件、软件运行产生的文件等。</p>
<p>&#x2F;var 下的子目录常见有：</p>
<ul>
<li>&#x2F;var&#x2F;cache&#x2F;：应用程序运行过程中产生的暂存文件。</li>
<li>&#x2F;var&#x2F;lib&#x2F;：应用程序运行过程中，需要使用到的数据文件放置的目录。</li>
<li>&#x2F;var&#x2F;lock&#x2F;：某些设备或文件要求使用时具有排他性，即上锁，该目录存放这类设备文件。</li>
<li>&#x2F;var&#x2F;log&#x2F;：日志或登录文件放置的目录。</li>
<li>&#x2F;var&#x2F;mail&#x2F;：放置个人电子邮件的目录。</li>
<li>&#x2F;var&#x2F;run&#x2F;：某些程序或者是服务启动后，将它们的 PID 记录在这个目录下</li>
<li>&#x2F;var&#x2F;spool&#x2F;：这个目录通常会放置一些队列数据，包括等待收寄的电子邮件、cron 任务等</li>
</ul>
<p>usr存放系统非必须app的不可改变数据,var存储可变临时数据</p>
<blockquote>
<p>共享文件夹在&#x2F;mnt下找</p>
</blockquote>
<p>7种文件类型:</p>
<p>f&#x2F;-:普通文件</p>
<p>d:目录文件</p>
<p>i:链接文件</p>
<p>p:管道文件(系统编程</p>
<p>s:网络套接字(网络编程</p>
<p>c:字符设备文件</p>
<p>b:块设备文件</p>
<h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><p>在Windows下，可直接访问检测到的外设，如磁盘、U盘等,因windos会自动分盘;将各分区(新设备)存储挂载到其对应根目录下；</p>
<p>在Linux下，外部硬件设备如磁盘、<a href="https://so.csdn.net/so/search?q=SD%E5%8D%A1&spm=1001.2101.3001.7020" title="SD卡">SD卡</a>等无法直接访问,要手动挂载实体存储到某目录下:</p>
<p>cd  &#x2F;dev查看新设备</p>
<p>mount &#x2F;dev&#x2F;sdb1 &#x2F;mountdir      # 将外部设备 &#x2F;dev&#x2F;sdb1 挂载到 mountdir</p>
<p>umount &#x2F;mountdir # 使用完以后，取消挂载</p>
<p>lsblk查看挂载情况</p>
<h2 id="软件包管理器"><a href="#软件包管理器" class="headerlink" title="软件包管理器"></a>软件包管理器</h2><p>下载一个软件:你可能需要下载,解压,编译,链接(写makefile,cmake);更别提要遵守fhs</p>
<p>.&#x2F;configure  自动生成make<br>make &#x20;<br>make install</p>
<p>软件包管理系统提供了易于使用的GUI和命令行工具，使用户能在线搜索,安装预编译的二进制发布版本、更新和删除软件包.还提供依赖管理功能，自动处理软件包之间的依赖关系</p>
<p>命令概览：</p>
<p>两大包管理系统（.deb技术）（.rpm技术）<br>低级工具（rpm)(dpkg）<br>高级工具（apt-get,aptitude）（yum）<br>查找软件包(apt-get update，apt-cache search search_string),(yum search search_string)<br>高级安装软件包（apt-get update ; apt-get install package_name）,(yum install package_name)<br>低级软件包安装命令（dpkg –install package_file）(rpm -i package_file)<br>删除&#x2F;卸载软件包（apt-get remove package_name）(yum erase package_name)<br>更新库中的软件包（apt-get update; apt-get upgrade）（yum update）<br>更新软件包文件中的软件包（dpkg –install package_file）（rpm -U package_file）<br>查看系统已安装软件包（dpkg –list）（rpm -qa）<br>判断软件是否安装（dpkg –status packagename）（rpm -q package_name）<br>显示已安装软甲的相关信息（apt-cache show packagename）（yum info package_name）<br>查看某文件或目录谁装的（dpkg –search filename）（rpm -qf file_name）</p>
<h2 id="以太网设置"><a href="#以太网设置" class="headerlink" title="以太网设置"></a>以太网设置</h2><p>如果是板子要有桥接网卡并网;若是虚拟机,要虚拟网卡;</p>
<p>硬件有了,驱动装了,协议服务装了,应用装了,还得设置ip</p>
<p>ip设置</p>
<p>临时设置:ifconfig  port xxx.xxx.xxx.xxx</p>
<p>设置端口port的IP为xxxx;port用ifconfig查询</p>
<blockquote>
<p>虚拟机和主机的默认网关不一致</p>
</blockquote>
<p>永久设置:</p>
<p>vi &#x2F;etc&#x2F;network&#x2F;interfaces</p>
<p>修改ip,掩码,默认网关;或把临时设置写进bootload</p>
<p>重启网络&#x20;</p>
<p>&#x2F;etc&#x2F;init.d&#x2F;S40network restart</p>
<p>虚拟机联网</p>
<p><a href="https://blog.csdn.net/qq_37131111/article/details/54000029" title=" VMware 虚拟机如何连接网络_vmware虚拟机连接网络_王一一的博客的博客-CSDN博客 ps：本教程是针对虚拟机NAT模式连接网络一、首先查看自己的虚拟机服务有没有开启，选择电脑里面的服务查看；1.计算机点击右键选择管理 2.进入管理选择VM开头的服务如果没有开启的话就右键开启 二、虚拟机服务开启后就查看本地网络虚拟机的网卡启动没有1.电脑右下角网络标志右键进入网络和共享中心2.点击更改适配器，查看虚拟机的虚拟网卡启动没有，没有启动的话右键点击启动  3.网卡开启后设置ip地址_vm https://blog.csdn.net/qq_37131111/article/details/54000029"> VMware 虚拟机如何连接网络_vmware虚拟机连接网络_王一一的博客的博客-CSDN博客 ps：本教程是针对虚拟机NAT模式连接网络一、首先查看自己的虚拟机服务有没有开启，选择电脑里面的服务查看；1.计算机点击右键选择管理 2.进入管理选择VM开头的服务如果没有开启的话就右键开启 二、虚拟机服务开启后就查看本地网络虚拟机的网卡启动没有1.电脑右下角网络标志右键进入网络和共享中心2.点击更改适配器，查看虚拟机的虚拟网卡启动没有，没有启动的话右键点击启动  3.网卡开启后设置ip地址_vm https://blog.csdn.net/qq_37131111&#x2F;article&#x2F;details&#x2F;54000029</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/130984945" title="VMware虚拟机网络配置-NAT篇 0 前言网上有好多VMware的网络配置教程，各个方法都不一样，新人往往云里雾里，本人亦深受其害，偶尔成功一次，也不明白原理，下一次照样犯错，故写博客记录。 1 想要达成的效果主机和虚拟机之间，可以互相ping通… https://zhuanlan.zhihu.com/p/130984945">VMware虚拟机网络配置-NAT篇 0 前言网上有好多VMware的网络配置教程，各个方法都不一样，新人往往云里雾里，本人亦深受其害，偶尔成功一次，也不明白原理，下一次照样犯错，故写博客记录。 1 想要达成的效果主机和虚拟机之间，可以互相ping通… https://zhuanlan.zhihu.com/p/130984945</a></p>
<p>0）开启vm的服务<br>1）设置虚拟子网vmnetx：192.168.80.0;gateway:2；自动分配范围<br>2)虚拟适配器静态设置ip为1；动态有时会分配到相同网段出问题<br>3）虚拟网络设置为vmnetx;<br>4）虚拟机设置本机ip；不能占用上述几个IP；在分配范围内；重启搞定</p>
<p>桥接:</p>
<p><a href="https://blog.csdn.net/he_and/article/details/86589239" title=" win10 vmware没有vmnet0(桥接后无法上网）解决办法_vm无法将网络更改为桥接状态_tnt阿信的博客-CSDN博客 这个问题困扰了我好久_vm无法将网络更改为桥接状态 https://blog.csdn.net/he_and/article/details/86589239"> win10 vmware没有vmnet0(桥接后无法上网）解决办法_vm无法将网络更改为桥接状态_tnt阿信的博客-CSDN博客 这个问题困扰了我好久_vm无法将网络更改为桥接状态 https://blog.csdn.net/he_and&#x2F;article&#x2F;details&#x2F;86589239</a></p>
<p>虚拟网络设置选择网卡;分配同主机网段ip</p>
<p>nat:</p>
<p>设置虚拟的IP子网,分配虚拟网关IP</p>
<p>分配适配器和虚拟机虚拟ip</p>
<h2 id="配置环境变量指定交叉编译工具链"><a href="#配置环境变量指定交叉编译工具链" class="headerlink" title="配置环境变量指定交叉编译工具链"></a>配置环境变量指定交叉编译工具链</h2><p>首先你要下载交叉工具链</p>
<p>1)临时指定</p>
<p>只对本次终端有效</p>
<p>export ARCH&#x3D;arm&#x20;<br>export CROSS_COMPILE&#x3D;arm-buildroot-linux-gnueabihf-&#x20;<br>export PATH&#x3D;$PATH:&#x2F;home&#x2F;book&#x2F;100ask_imx6ull-sdk&#x2F;ToolChain&#x2F;arm-buildroot-linux-gnueabihf_sdk-buildroot&#x2F;bin</p>
<p>2)通过配置bash自动脚本永久指定</p>
<p>进入~&#x2F;.bashrc输入上述3条指令</p>
<blockquote>
<p>设置完毕后，要执行<br>source ~&#x2F;.bashrc<br>命令使其生效，可通过<br>arm <em>-buildroot</em>-linux-gnueabihf-gcc -v</p>
</blockquote>
<blockquote>
<p>或echo打印设置的变量</p>
</blockquote>
<blockquote>
<p>验证是否成功</p>
</blockquote>
<h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>开启防火墙</p>
<p>sudo ufw status<br>sudo ufw enable</p>
<p><strong>关闭防火墙</strong></p>
<p>sudo ufw disable</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>文件系统（磁盘管理系统）</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%89/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%88%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/183238194" title="一口气搞懂「文件系统」，就靠这 25 张图了 前言不多 BB，直接上「硬菜」。 正文文件系统的基本组成文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以… https://zhuanlan.zhihu.com/p/183238194">一口气搞懂「文件系统」，就靠这 25 张图了 前言不多 BB，直接上「硬菜」。 正文文件系统的基本组成文件系统是操作系统中负责管理持久数据的子系统，说简单点，就是负责把用户的文件存到磁盘硬件中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以… https://zhuanlan.zhihu.com/p/183238194</a></p>
<p>文件格式：数据以比特流的形式存储，为了能够流通；需要一套编码&#x2F;解码规则，即文件格式；当我们打开一个文件时，计算机会根据文件格式来解析文件的内容，并将其呈现给用户或进行相应的处理操作</p>
<p>文件系统：1，2就是建立数据结构维护数据并设计数据操作算法<br>1）文件存储以及磁盘空间管理：负责在磁盘上分配空间存储文件并记录文件相关信息；文件删除时，文件系统回收这些空间<br>1.2）文件备份和恢复</p>
<p>2）文件管理：实现增删改查，移动，重命名等系统功能；用户通过文件系统的接口管理文件<br>2.2）文件访问控制</p>
<p>3）文件压缩和加密<br>4）文件共享：文件系统可以将文件共享给其他计算机或用户，使得多个用户可以同时访问和修改文件</p>
<h1 id="ELF文件格式"><a href="#ELF文件格式" class="headerlink" title="ELF文件格式"></a>ELF文件格式</h1><table>
<thead>
<tr>
<th>ELF 文件类型</th>
<th>说明</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>可重定位文件(Relocatable File)</td>
<td>包含代码和数据、可被链接为可执行文件或共享目标文件，静态链接库被归为此类</td>
<td>Linux 下的 *.o</td>
</tr>
<tr>
<td>可执行文件(Executable File)</td>
<td>此类文件包含了可以直接执行的文件</td>
<td>&#x2F;bin&#x2F;bash</td>
</tr>
<tr>
<td>共享目标文件(Share Object File)</td>
<td>此类文件包含了可以直接执行的文件</td>
<td>linux 的 *.so&#xA;&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so</td>
</tr>
<tr>
<td>核心转储文件(Core Dump File)</td>
<td>当进程意外终止，系统生成的核心转储文件</td>
<td>Linux 下的 core dump文件</td>
</tr>
</tbody></table>
<p><img src="/image/image_s1VyhB2QNc.png"></p>
<p><img src="/image/image_LUCdweUOM0.png"></p>
<h2 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">readelf -h hello.o </span><br><span class="line"><span class="comment">#读取elf文件头；文件头描述文件属性：文件类型、目标硬件、目标操作系统等；</span></span><br><span class="line">- ELF 魔数。</span><br><span class="line">- 文件机器字节长度。</span><br><span class="line">- 数据存储方式。</span><br><span class="line">- 版本。</span><br><span class="line">- 运行平台。</span><br><span class="line">- ABI 版本。</span><br><span class="line">- ELF 重定位类型。</span><br><span class="line">- 硬件平台。</span><br><span class="line">- 硬件平台版本。</span><br><span class="line">- 入口地址（目标文件入口地址为 0，只有相对位置）。</span><br><span class="line">- 程序的入口和长度。</span><br><span class="line">- 段表的位置和长度。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/image/image_R3rXd-Wqm-.png"></p>
<p><img src="/image/image_y9RNrr9HSX.png"></p>
<h2 id="逻辑段表"><a href="#逻辑段表" class="headerlink" title="逻辑段表"></a>逻辑<strong>段表</strong></h2><p><img src="/image/image_e4xoVFJsqZ.png"></p>
<p>readelf -S f1或objdump -h f1查看段表属性</p>
<p><img src="/image/image_FyB2rpFAvp.png"></p>
<p><img src="/image/image_U9l0DJAWpJ.png"></p>
<h2 id="代码段（-text）"><a href="#代码段（-text）" class="headerlink" title="代码段（.text）"></a>代码段（.text）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#C 编译后的机器指令保存在代码段（.text）； </span></span><br><span class="line">objdump -ds hello.o | grep -A 9 -E <span class="string">&#x27;main:&gt;|f:&gt;&#x27;</span><span class="comment">#-d输出汇编源码;-s 16进制显示；过滤main和f函数</span></span><br></pre></td></tr></table></figure>

<p><img src="/image/image_-mG7-kZwwz.png"></p>
<p><img src="/image/image_0taojPzF2G.png"></p>
<h2 id="数据段（-data）"><a href="#数据段（-data）" class="headerlink" title="数据段（.data）"></a>数据段（.data）</h2><p>保存非零初始化全局变量和局部静态变量</p>
<p><img src="/image/image_nXnR1PIlZ8.png"></p>
<h2 id="只读数据段（-rodata）"><a href="#只读数据段（-rodata）" class="headerlink" title="只读数据段（.rodata）"></a>只读数据段（.rodata）</h2><p>const 修饰的变量和字符串常量（包括 printf 函数中的格式化字符串%d）;可以通过优化.rodata 段的大小，进而优化程序的大小</p>
<p><img src="/image/image_GyCTpHeHBT.png"></p>
<h2 id="bss-段"><a href="#bss-段" class="headerlink" title="bss 段"></a>bss 段</h2><p>记录零初始化全局变量&#x2F;局部静态变量大小总和；并预留位置，最终链接时在分配到.bss段（具体和编译器有关）</p>
<h2 id="符号表段（-symtab）"><a href="#符号表段（-symtab）" class="headerlink" title="符号表段（.symtab）"></a>符号表段（.symtab）</h2><p><img src="https://pic3.zhimg.com/80/v2-19eb0bd6897bd2eb201f1f8a8b11a5a6_720w.webp"></p>
<p>以数组结构形式保存符号信息（函数和变量），符号值即地址。</p>
<p>readelf -s查看段表属性：name符号名称；Ndx:所处段；Type:符号类型；value:首字节在段内的偏移量<br>eg:<br>f 和 main 函数的 Ndx 对应的值是 1，表示在.text 段（.text 段在段表中的索引是 1）,类型为 FUNC，value 分别是 0x00000000 和 0x00000040，表明两个函数指令字节码的首字节分别在.text 的 0x00000000 和 0x00000040 偏移处。</p>
<p>printf 的 Ndx 是 UND，表明这个符号在 object_file.o 里面没有被定义，仅仅是引用。</p>
<p>static_val.1843 和 gint_val 两个符号的 Ndx 都是 3，说明他们都被定义在数据段。value 分别是 0x00000000 和 0x00000004，表明两个函数指令字节码的首字节分别在.data 的 0x00000000 和 0x00000004 偏移处。</p>
<h2 id="comment"><a href="#comment" class="headerlink" title=".comment"></a>.comment</h2><p>存放编译器版本信息</p>
<h2 id="符号表-shstrtab-：Section-String-table"><a href="#符号表-shstrtab-：Section-String-table" class="headerlink" title="符号表(.shstrtab)：Section String table"></a>符号表(.shstrtab)：Section String table</h2><p>存放符号的名称字符串</p>
<h2 id="dynamic"><a href="#dynamic" class="headerlink" title=".dynamic"></a>.dynamic</h2><p>动态链接信息</p>
<h2 id="重定位代码段（-rel-text）"><a href="#重定位代码段（-rel-text）" class="headerlink" title="重定位代码段（.rel.text）"></a>重定位代码段（.rel.text）</h2><p>描述在重定位时连接器如何修改相应段里的内容。对于.text，对应的重定位表是.rel.text。使用objdump -r 查看重定位表。</p>
<p><img src="https://pic2.zhimg.com/80/v2-ab4bf8b83a7cf4ec8f2f9496d24ed319_720w.webp"></p>
<h2 id="自定义段表"><a href="#自定义段表" class="headerlink" title="自定义段表"></a><strong>自定义段表</strong></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*GCC 编译出来的目标文件默认放到.text ，全局变量和静态变量默认放到.data 和.bss 段。但有时我们希望有些变量或代码可以放到指定的段中，以实现某些特定功能。*/</span></span><br><span class="line"><span class="comment">//GCC 指定段扩展机制:全局变量或者函数前加入 _attribute_((section(&quot;name&quot;))) 属性就可把变量或函数放入到”name“段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把变量放到start_var_init段：</span></span><br><span class="line">__attribute__((section(<span class="string">&quot;start_var_init&quot;</span>))) <span class="type">int</span> init_status = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//把函数放到start_fun_init段：</span></span><br><span class="line">__attribute__((section(<span class="string">&quot;start_fun_init&quot;</span>))) <span class="type">void</span> <span class="title function_">start_func</span><span class="params">()</span>&#123;    </span><br><span class="line">    <span class="comment">//init code    </span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查看段表中的符号名字符串表shstrtab确认:readelf -s</span></span><br></pre></td></tr></table></figure>

<p><img src="/image/image_sma3mLOaUm.png"></p>
<p><img src="/image/image_R_bVlgz6df.png"></p>
<h1 id="文件系统基本组成"><a href="#文件系统基本组成" class="headerlink" title="文件系统基本组成"></a>文件系统基本组成</h1><p><img src="/image/image_APl8uir-hH.png"></p>
<p>文件系统由2个数据结构维护：<strong>dientry</strong>→inode→盘块中存储的文件内容（目录文件的文件内容是子目录和文件信息）<br>1）<strong>目录项</strong><em><strong>directory entry</strong></em>**（dientry）**:{文件名，inode，与其他目录项的层级关系…};<strong>是由内核维护的数据结构，不存放于磁盘，缓存在内存</strong><br>2）<em><strong>index node</strong></em><strong>（</strong>inode**） **:记录文件的属性:inode 编号、权限、类型、大小、时间、用户、盘块位置等;多数的inode都存储在磁盘上。少量常用、近期使用的inode会被缓存到内存中</p>
<p>硬链接的实现就是多个目录项中的索引节点指向同一个文件</p>
<p>磁盘进行格式化会被分成三个存储区域<br>1）超级块：存储文件系统的详细信息，比如块个数、块大小、空闲块等<br>2）索引节点区<br>3）数据块区<br>当文件系统挂载时超级块区加载进内存；当文件被访问时索引节点区进入内存</p>
<h1 id="虚拟文件系统Virtual-File-System，VFS接口"><a href="#虚拟文件系统Virtual-File-System，VFS接口" class="headerlink" title="虚拟文件系统Virtual File System，VFS接口"></a>虚拟文件系统<em><strong>Virtual File System，VFS</strong></em>接口</h1><p>win常见的文件系统：fat32  ntfs  exfat&#x20;<br>linux常见：<br>1)磁盘文件系统: 它是直接把数据存储在磁盘中，比如 Ext 2&#x2F;3&#x2F;4、XFS 等都是这类文件系统。<br>2)内存文件系统: 这类文件系统的数据不是存储在硬盘的，而是占用内存空间，我们经常用到的 <code>/proc</code> 和 <code>/sys</code> 文件系统都属于这一类，读写这类文件，实际上是读写内核中相关的数据数据。<br>3)网络文件系统:用来访问其他计算机主机数据的文件系统，比如 NFS、SMB 等等。</p>
<p>文件系统的种类众多，故在其上定义了<strong>统一接口</strong>标准vfs<br>文件系统首先要先挂载到某个目录才可以正常使用，比如 Linux 系统在启动时，会把文件系统挂载到根目录。</p>
<p><img src="/image/image_SoU77l0gee.png"></p>
<p>系统调用要经过两层接口：</p>
<p><img src="/image/image_sgp3QStLIm.png"></p>
<p>vfs接口层核心封装:file、dentry、inode、super_block结构体协同工作以实现对各种文件系统的访问和操作</p>
<p><img src="/image/image_WG1yi2l4ZM.png"></p>
<p>PCB</p>
<ul>
<li>File<ul>
<li>dientry<ul>
<li>Inode<ul>
<li>super_block</li>
</ul>
</li>
<li>inode_operations</li>
</ul>
</li>
<li>file_operations</li>
</ul>
</li>
</ul>
<p>进程控制块（Process Control Block，PCB）中维护着一份文件描述符表。索引为文件描述符，表项中FILE*指向维护已打开的文件的file结构体</p>
<p>file结构体指向file_operations结构体，其中的成员都是函数指针，指向各种文件操作的内核函数</p>
<p>file结构体指向dentry结构体，dentry结构体指向inode结构体；</p>
<p>inode结构体指向inode_operations结构体，其中的成员都是函数指针，指向影响文件和目录布局的函数</p>
<p>inode结构体指向super_block结构体，super_block结构体保存着该文件系统的超级块信息，例如文件系统类型、块大小等。同时，super_block结构体的s_root成员是一个指向dentry的指针，表示该文件系统的根目录被挂载到了哪里。</p>
<p>eg:把fd传入fopen()<br>1）fopen根据文件描述符找到打开文件信息的file结构体；<br>2）从dentry获取全局信息和磁盘数据位置<br>3）调用file_operations结构体中的open函数</p>
<h1 id="磁盘上文件系统"><a href="#磁盘上文件系统" class="headerlink" title="磁盘上文件系统"></a>磁盘上文件系统</h1><h2 id="磁盘上的文件系统结构"><a href="#磁盘上的文件系统结构" class="headerlink" title="磁盘上的文件系统结构"></a>磁盘上的文件系统结构</h2><p><img src="/image/image_GkiPYIRBcr.png"></p>
<p>Linux 文件系统由多个块组组成。<strong>每个</strong>块组包含<br>超级块：文件系统全局信息；inode 总数、块总数；各块组 inode 数、块数；文件系统版本号、上次<code>mount</code>的时间等<br>块组描述符表：块组描述符存储当前块组信息；空闲块和空闲 inode 总数，从哪里开始是inode表，数据块等；表中有多个块组描述符<br>数据块区：包含文件有用数据<br>inode列表 ：数据块区中各文件都有一个Inode；其记录文件属性(inode 编号、权限、类型、大小、时间、用户、盘块位置、索引信息等）<br>数据块&#x2F;inode 位图：对应数据块或 inode空间 是空闲，还是被使用中</p>
<p><strong>超级块和块组描述符表</strong>在许多块组开头都有一份拷贝，原因是系统崩溃后；如果有冗余的副本，该信息是可能恢复的。 - 通过使文件和管理数据尽可能接近，减少了磁头寻道和旋转，这可以提高文件系统的性能</p>
<p>Ext2 的后续版本采用了稀疏技术。只写入到块组 0、块组 1 和其他 ID 可以表示为 3、 5、7 的幂的块组中；减少了磁盘空间的占用</p>
<h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><p>非连续存储：即文件数据块链式存储的关键，是要用节点指针&#x2F;额外建立的数据结构存储节点关系</p>
<h3 id="连续存储"><a href="#连续存储" class="headerlink" title="连续存储"></a>连续存储</h3><p><strong>inode需指定「起始块的位置」和「长度」</strong>；<br><strong>优点：读写效率高</strong>，一次磁盘寻道就可读出整个文件<br>缺点：<br>「磁盘碎片」:连续存储文件被删除产生磁盘碎片；存储文件长度要小于磁盘碎片才能存入<br>「文件长度不易扩展」:文件扩展后长度如果＞所在连续空闲空间长度，则不能扩展或扩展非常耗时</p>
<h3 id="隐式链表（指针存储数据块节点关系）"><a href="#隐式链表（指针存储数据块节点关系）" class="headerlink" title="隐式链表（指针存储数据块节点关系）"></a>隐式链表（指针存储数据块节点关系）</h3><p>隐式链表形式：文件头Inode存储起始块和末尾块指针；数据块有一个指针指向下一块；<br>数据块指针会多消耗一些磁盘空间；且通过指针遍历节点的方式访问文件；O(节点数)时间复杂度</p>
<h3 id="显式链表（文件分配表存储数据块节点关系）"><a href="#显式链表（文件分配表存储数据块节点关系）" class="headerlink" title="显式链表（文件分配表存储数据块节点关系）"></a>显式链表（<strong>文件分配表</strong>存储数据块节点关系）</h3><p>Inode存储起始块；内存中开辟<strong>文件分配表（</strong><em><strong>File Allocation Table，FAT</strong></em><strong>）</strong>；数据块号：下个块号的数组；<br>缺点是大磁盘有太多块，fat将会很占内存；优点是查找文件是在内存中进行，文件检索效率加快；支撑随机访问<br>eg:<br>文件A为4-7-2-10-12–1;</p>
<p><img src="/image/image_r0gv14yvR6.png"></p>
<h3 id="索引块（索引块存储数据块节点关系表）"><a href="#索引块（索引块存储数据块节点关系表）" class="headerlink" title="索引块（索引块存储数据块节点关系表）"></a>索引块（索引块存储数据块节点关系<strong>表</strong>）</h3><p>Inode存储索引块指针（索引块可以是1个，或链式，树状多级的多个）→磁盘<strong>索引块</strong>维护的数据块指针；支撑随机访问</p>
<p>若文件大到一个索引数据块放不下索引信息，使用以下两种</p>
<h3 id="链式索引存储（链式索引块存储数据块节点关系）"><a href="#链式索引存储（链式索引块存储数据块节点关系）" class="headerlink" title="链式索引存储（链式索引块存储数据块节点关系）"></a>链式索引存储（链式索引块存储数据块节点关系）</h3><p>Inode存储首个索引块指针，索引块存储文件数据块指针和下一个索引块指针，当索引块存满，就可通过指针找到下一索引块。这种方式会出现链表普遍的问题：万一某个指针损坏了，后面的数据就无法读取了</p>
<p><img src="/image/image_dzTRr3bswL.png"></p>
<h3 id="多级索引存储：（多叉树存储数据块节点关系）"><a href="#多级索引存储：（多叉树存储数据块节点关系）" class="headerlink" title="多级索引存储：（多叉树存储数据块节点关系）"></a><strong>多级索引</strong>存储：（多叉树存储数据块节点关系）</h3><p><img src="/image/image_uk0yGIxi1g.png"></p>
<p><img src="/image/image_Nb6iICv1L1.png"></p>
<p>Linux  Ext 2&#x2F;3文件系统存储方式：<br>根据文件的大小，存放的方式会有所变化：<br>文件所需数据块小于 10 ，则采用直接查找的方式；（Inode指向连续数据块）<br>文件所需数据块超过 10 ，则采用一级间接索引方式；（数据块链式存储，索引块维护数据块指针）<br>前两种方式都不够存放大文件，则采用二级间接索引方式；<br>二级索引也不够存放大文件，采用三级间接索引方式；</p>
<p><img src="/image/image_HOAl9ipYMl.png"></p>
<h3 id="目录文件存储"><a href="#目录文件存储" class="headerlink" title="目录文件存储"></a>目录文件存储</h3><p>磁盘上的目录文件数据块存储文件&#x2F;子目录信息<br>1)默认有.和..两个文件的（Inode,文件类型，文件名）信息<br>2)其他文件的信息都存在一张哈希表中(文件名：文件信息所在块号)</p>
<p>目录查询是通过在磁盘上反复搜索完成，需要不断地进行 I&#x2F;O 操作，开销较大。所以，为了减少 I&#x2F;O 操作，把当前使用的文件目录缓存在内存，以后要使用该文件时只要在内存中操作，从而降低了磁盘操作次数，提高了文件系统的访问速度</p>
<p><img src="/image/image_9AP0mFFLdu.png"></p>
<h2 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h2><p>空闲表法：为空闲空间建一张表，内容为该空闲区第一个块号和连续空闲块数；<br>当请求分配磁盘空间时，系统依次扫描空闲表里的内容，直到找到合适空闲区域；<br>当用户撤销一个文件时，系统回收文件空间；os顺序扫描空闲表找一个空闲表条目并将释放空间的第一个物理块号及它占用的块数填到这个条目中;<br>缺点：<br>当有大量离散分布的空闲区，空闲表将很大，查询效率会很低。另外，这种分配技术适用于建立连续文件。</p>
<p><img src="/image/image_tPEkEry1o2.png"></p>
<p>空闲链表法：每个空闲块里有一个指针指向下一个空闲块;主存中保存一个指针指向第一个空闲块<br>创建文件时:从链头上依次取下需要的块。<br>回收空间时：把这些空闲块依次接到链头上</p>
<p>缺点：不能随机访问，在链上增加或移动空闲块时需要做很多 I&#x2F;O 操作，工作效率低；同时数据块的指针消耗了一定的存储空间。</p>
<p><img src="/image/image_7mIDy-q5h0.png"></p>
<p>位图法（Linux 文件系统采用）：二进制每位都表示磁盘中1个盘块的使用情况，0&#x3D;空闲；1&#x3D;已分配；<br>空闲Inode位图和空闲数块位图管理磁盘数据空闲块和 inode 空闲块</p>
<h1 id="软硬链接"><a href="#软硬链接" class="headerlink" title="软硬链接"></a>软硬链接</h1><p>硬链接是**多个文件的dientry的「索引节点」**指向同一个 inode;即指向同一文件；<br><strong>只有删除所有硬链接及原文件对inode的索引，系统才会彻底删除该文件</strong></p>
<p><img src="/image/image_XIeDjlmue4.png"></p>
<p>软链接创建有<strong>独立的 inode</strong>的文件，但<strong>文件内容是另一文件的路径</strong>，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以<strong>软链接是可跨文件系统的</strong></p>
<p><img src="/image/image_r1yADyjkt3.png"></p>
<h1 id="文件操作posix"><a href="#文件操作posix" class="headerlink" title="文件操作posix"></a>文件操作posix</h1><h2 id="stat-access-utime"><a href="#stat-access-utime" class="headerlink" title="stat&#x2F;access&#x2F;utime"></a>stat&#x2F;access&#x2F;utime</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">dev_t</span>     st_dev;     <span class="comment">/* 设备号（主设备号，次设备号）*/</span></span><br><span class="line">    <span class="type">ino_t</span>     st_ino;     <span class="comment">/* inode的数量 */</span></span><br><span class="line">    <span class="type">mode_t</span>    st_mode;    <span class="comment">/* 文件的类型和存取的权限 */</span></span><br><span class="line">    <span class="type">nlink_t</span>   st_nlink;   <span class="comment">/* 硬链接的数量 */</span></span><br><span class="line">    <span class="type">uid_t</span>     st_uid;     <span class="comment">/* 所用者的uid */</span></span><br><span class="line">    <span class="type">gid_t</span>     st_gid;     <span class="comment">/* 所有者的组id */</span></span><br><span class="line">    <span class="type">dev_t</span>     st_rdev;    <span class="comment">/* device ID (if special file) */</span></span><br><span class="line">    <span class="type">off_t</span>     st_size;    <span class="comment">/* 总大小,字节数 */</span></span><br><span class="line">    <span class="type">blksize_t</span> st_blksize; <span class="comment">/* blocksize for filesystem I/O */</span></span><br><span class="line">    <span class="type">blkcnt_t</span>  st_blocks;  <span class="comment">/* number of 512B blocks allocated */</span></span><br><span class="line">    <span class="type">time_t</span>    st_atime;   <span class="comment">/* 最后访问时间（access）*/</span></span><br><span class="line">    <span class="type">time_t</span>    st_mtime;   <span class="comment">/* 最后修改时间（modification）文件内容的改动时间 */</span></span><br><span class="line">    <span class="type">time_t</span>    st_ctime;   <span class="comment">/* 最后改动时间（change）文件属性的改动时间 */</span></span><br><span class="line">&#125;;</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//根据传入文件路径读取文件的inode，把inode文件属性填入一个struct stat结构体传出给调用者。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">stat/fstat检查符号链接时，检查的是符号链接所引用的文件</span></span><br><span class="line"><span class="comment">lstat检查符号链接时，检查的是符号链接本身</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*实现原理：假设传入路径/opt/file</span></span><br><span class="line"><span class="comment">1）读出inode表中第2项，即根目录inode，并找到根目录数据块位置</span></span><br><span class="line"><span class="comment">2）从根目录的数据块中找出文件名为opt的记录，从记录中读出它的inode号</span></span><br><span class="line"><span class="comment">3）读出opt目录的inode，从中找出它的数据块的位置</span></span><br><span class="line"><span class="comment">4）从opt目录的数据块中找出文件名为file的记录，从记录中读出它的inode号</span></span><br><span class="line"><span class="comment">5）读出file文件的inode</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> stat(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> stat *buf);</span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"></span><br><span class="line">@ret:成功返回<span class="number">0</span>；失败返回<span class="number">-1</span>，并设置相应errno的值</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//检查执行当前进程的用户访问pathname是否有mode权限</span></span><br><span class="line"><span class="comment">//实现：access函数取出文件inode中的st_mode字段，比较一下访问权限</span></span><br><span class="line"><span class="type">int</span> access(<span class="type">const</span> <span class="type">char</span> * pathname,  <span class="type">int</span> mode);</span><br><span class="line"></span><br><span class="line">@mode:</span><br><span class="line"><span class="number">06</span> 检查读写权限</span><br><span class="line">R_OK/<span class="number">04</span> 检查读权限(目录的读是能否ls)</span><br><span class="line">W_OK/<span class="number">02</span> 检查写权限</span><br><span class="line">X_OK /<span class="number">01</span> 检查执行权限(目录的执行是cd)</span><br><span class="line">F_OK/<span class="number">00</span> 检查文件的存在性</span><br><span class="line"></span><br><span class="line">@ret:返回<span class="number">0</span>表示允许访问，返回<span class="number">-1</span>表示错误或不允许访问；并设置erno:</span><br><span class="line">EACCESS  参数pathname 所指定的文件不符合所要求测试的权限。</span><br><span class="line">EROFS   欲测试写入权限的文件存在于只读文件系统内。</span><br><span class="line">EFAULT  参数pathname指针超出可存取内存空间。</span><br><span class="line">EINVAL  参数mode 不正确。</span><br><span class="line">ENAMETOOLONG  参数pathname太长。</span><br><span class="line">ENOTDIR  参数pathname为一目录。</span><br><span class="line">ENOMEM  核心内存不足    </span><br><span class="line">ELOOP   参数pathname有过多符号连接问题。</span><br><span class="line">EIO I/O  存取错误。</span><br><span class="line">============================================================================================</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="chown-chmod-utime-truncate"><a href="#chown-chmod-utime-truncate" class="headerlink" title="chown&#x2F;chmod&#x2F;utime&#x2F;truncate"></a>chown&#x2F;chmod&#x2F;utime&#x2F;truncate</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//改变文件所有者和组，即修改inode中的User和Group字段，只有超级用户才能正确调用这几个函数</span></span><br><span class="line"><span class="comment">/*差异：</span></span><br><span class="line"><span class="comment">chown、fchown修改符号链接时，修改符号链接指向的文件的权限</span></span><br><span class="line"><span class="comment">lchown修改软链接时，修改的是符号链接权限。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">chown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span>;<span class="comment">//posix</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fchown</span><span class="params">(<span class="type">int</span> fd, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span>;<span class="comment">//ansi</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lchown</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">uid_t</span> owner, <span class="type">gid_t</span> group)</span>;</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="comment">//改变文件的访问权限，也就是修改inode中的st_mode字段</span></span><br><span class="line">============================================================================================</span><br><span class="line"><span class="comment">//改变文件的访问时间和修改时间，也就是修改inode中的atime和mtime字段</span></span><br><span class="line">============================================================================================</span><br><span class="line"><span class="comment">//把文件截断到某个长度，若比原来短，则后面的数据被截掉了，比原来长，则后面多出来的部分用0填充，这需要修改inode中的Blocks索引项以及块位图中相应的bit</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="link-symlink-unlink-readlink"><a href="#link-symlink-unlink-readlink" class="headerlink" title="link&#x2F;symlink&#x2F;unlink&#x2F;readlink"></a>link&#x2F;symlink&#x2F;unlink&#x2F;readlink</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建硬链接，其原理是在目录的数据块中添加一条新记录，其中的inode号字段和原文件相同</span></span><br><span class="line">============================================================================================</span><br><span class="line"><span class="comment">//创建一个符号链接，这需要创建一个新的inode，其中st_mode字段的文件类型是符号链接，原文件的路径保存在inode中或者分配一个数据块来保存</span></span><br><span class="line">============================================================================================</span><br><span class="line"><span class="comment">//删除一个链接。如果是符号链接则释放这个符号链接的inode和数据块，清除inode位图和块位图中相应的位。如果是硬链接则从目录的数据块中清除一条文件名记录，如果当前文件的硬链接数已经是1了还要删除它，就同时释放它的inode和数据块，清除inode位图和块位图中相应的位</span></span><br><span class="line">============================================================================================</span><br><span class="line"><span class="comment">//读取一个符号链接所指向的目标路径，其原理是从符号链接的inode或数据块中读出保存的数据，这就是目标路径</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//给文件改名，移动文件位置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rename</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br><span class="line"></span><br><span class="line">@ret:成功返回<span class="number">0</span>，失败返回<span class="number">-1</span>，并设置相应errno</span><br><span class="line"></span><br><span class="line"><span class="comment">//改变文件名，需要修改目录数据块中的文件名记录，如果原文件名和新文件名不在一个目录下则需要从原目录数据块中清除一条记录然后添加到新目录的数据块中。mv(1)命令是基于rename函数实现的，因此在同一分区的不同目录中移动文件并不需要复制和删除文件的inode和数据块，只需要一个改名操作，即使要移动整个目录，这个目录下有很多子目录和文件也要随着一起移动，移动操作也只是对顶级目录的改名操作，很快就能完成。但是，如果在不同的分区之间移动文件就必须复制和删除inode和数据块，如果要移动整个目录，所有子目录和文件都要复制删除，这就很慢了</span></span><br></pre></td></tr></table></figure>

<h2 id="basename-dirname"><a href="#basename-dirname" class="headerlink" title="basename&#x2F; dirname"></a><strong>basename&#x2F;</strong> dirname</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libgen.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">dirname</span><span class="params">(<span class="type">char</span> *path)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">basename</span><span class="params">(<span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure>

<p>mkdir&#x2F;rmdir</p>
<h2 id="opendir-closedir"><a href="#opendir-closedir" class="headerlink" title="opendir&#x2F;closedir"></a>opendir&#x2F;closedir</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">  <span class="type">ino_t</span>          d_ino;       <span class="comment">/* inode number */</span></span><br><span class="line">  <span class="type">off_t</span>          d_off;       <span class="comment">/* offset to the next dirent */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> d_reclen;    <span class="comment">/* length of this record */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>  d_type;      <span class="comment">/* type of file */</span></span><br><span class="line">  <span class="type">char</span>           d_name[<span class="number">256</span>]; <span class="comment">/* filename */</span></span><br><span class="line">&#125;;</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="comment">//根据目录的路径字符串，返回一个DIR指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭DIR指针所指向的目录流</span></span><br></pre></td></tr></table></figure>

<h2 id="seekdir"><a href="#seekdir" class="headerlink" title="seekdir"></a>seekdir</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将DIR指针所指向的目录流偏移跳跃到某一位置</span></span><br></pre></td></tr></table></figure>

<h2 id="readdir"><a href="#readdir" class="headerlink" title="readdir"></a>readdir</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据DIR指针，返回DIR指针所指向的目录项的指针（dirent *）</span></span><br></pre></td></tr></table></figure>

<h2 id="telldir"><a href="#telldir" class="headerlink" title="telldir"></a>telldir</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回DIR指针所指向目录流的当前位置（long类型）</span></span><br></pre></td></tr></table></figure>

<h2 id="getcwd"><a href="#getcwd" class="headerlink" title="getcwd"></a>getcwd</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *buf,<span class="type">size_t</span> size)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ex"><a href="#ex" class="headerlink" title="ex"></a>ex</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归列出目录下文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_PATH 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* dirwalk:  apply fcn to all files in dir */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dirwalk</span><span class="params">(<span class="type">char</span> *dir, <span class="type">void</span> (*fcn)(<span class="type">char</span> *))</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[MAX_PATH];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dp</span>;</span></span><br><span class="line">  DIR *dfd;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((dfd = opendir(dir)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;dirwalk: can&#x27;t open %s\n&quot;</span>, dir);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ((dp = readdir(dfd)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dp-&gt;d_name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span></span><br><span class="line">        || <span class="built_in">strcmp</span>(dp-&gt;d_name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">continue</span>;    <span class="comment">/* skip self and parent */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(dir)+<span class="built_in">strlen</span>(dp-&gt;d_name)+<span class="number">2</span> &gt; <span class="keyword">sizeof</span>(name))</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;dirwalk: name %s %s too long\n&quot;</span>,</span><br><span class="line">        dir, dp-&gt;d_name);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">sprintf</span>(name, <span class="string">&quot;%s/%s&quot;</span>, dir, dp-&gt;d_name);</span><br><span class="line">      (*fcn)(name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  closedir(dfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fsize:  print the size and name of file &quot;name&quot; */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fsize</span><span class="params">(<span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stbuf</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stat(name, &amp;stbuf) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fsize: can&#x27;t access %s\n&quot;</span>, name);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ((stbuf.st_mode &amp; S_IFMT) == S_IFDIR)</span><br><span class="line">    dirwalk(name, fsize);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%8ld %s\n&quot;</span>, stbuf.st_size, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc == <span class="number">1</span>)  <span class="comment">/* default: current directory */</span></span><br><span class="line">    fsize(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">while</span> (--argc &gt; <span class="number">0</span>)</span><br><span class="line">      fsize(*++argv);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个程序还是不如ls -R健壮，它有可能死循环，思考一下什么情况会导致死循环</span></span><br></pre></td></tr></table></figure>

<p>文件组织；文件保护；文件映射，文件共享</p>
<p>readelf -h hello.o读取</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>文件IO</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E6%96%87%E4%BB%B6IO/%E6%96%87%E4%BB%B6IO/</url>
    <content><![CDATA[<p><a href="https://www.runoob.com/cprogramming/c-function-fread.html" title=" C 库函数 – fread() | 菜鸟教程 C 库函数 - fread()   C 标准库 - &lt;stdio.h&gt;  描述 C 库函数 size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) 从给定流 stream 读取数据到 ptr 所指向的数组中。 声明 下面是 fread() 函数的声明。  size_t fread(void *ptr, size_ https://www.runoob.com/cprogramming/c-function-fread.html"> C 库函数 – fread() | 菜鸟教程 C 库函数 - fread()   C 标准库 - &amp;lt;stdio.h&amp;gt;  描述 C 库函数 size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) 从给定流 stream 读取数据到 ptr 所指向的数组中。 声明 下面是 fread() 函数的声明。  size_t fread(void *ptr, size_ https://www.runoob.com/cprogramming/c-function-fread.html</a></p>
<p><a href="https://www.bookstack.cn/read/linuxapi/README.md" title=" 阅前必读 - 《Linux API速查手册》 - 书栈网 · BookStack Linux API速查手册https://github.com/guodongxiaren/LinuxAPI/wiki果冻虾仁 的Linux系统编程学习记录 Linux API速查手册 https://www.bookstack.cn/read/linuxapi/README.md"> 阅前必读 - 《Linux API速查手册》 - 书栈网 · BookStack Linux API速查手册https://github.com/guodongxiaren/LinuxAPI/wiki果冻虾仁 的Linux系统编程学习记录 Linux API速查手册 https://www.bookstack.cn/read/linuxapi/README.md</a></p>
<h1 id="IO机制-编写zeinsos再去弄懂"><a href="#IO机制-编写zeinsos再去弄懂" class="headerlink" title="IO机制?编写zeinsos再去弄懂"></a>IO机制?编写zeinsos再去弄懂</h1><p><a href="https://zhuanlan.zhihu.com/p/183238194" title="https://zhuanlan.zhihu.com/p/183238194">https://zhuanlan.zhihu.com/p/183238194</a></p>
<h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p>全缓冲:缓冲区写满了就写回内核。读写常规文件通常是全缓冲的。</p>
<p>行缓冲:如果用户程序写的数据中有换行符就把这一行写回内核，或者如果缓冲区写满了就写回内核。标准输入和标准输出对应终端设备时通常是行缓冲的。</p>
<p>无缓冲:用户程序每次调库函数做写操作都要通过系统调用写回内核。标准错误输出通常是无缓冲的，这样用户程序产生的错误信息可以尽快输出到设备。</p>
<h2 id="IO缓冲机制"><a href="#IO缓冲机制" class="headerlink" title="IO缓冲机制"></a>IO缓冲机制</h2><p>ansi接口特性：<br>1）跨平台移植性<br>2.1）写缓冲：使用ansi写磁盘，会在用户进程空间创建buffer（默认4096K），写满后一次性进行系统调用把数据写进内核进程空间buffer,内核再进行驱动调用写进磁盘（os缓输出：会在空闲时择机刷到磁盘）；避免因频繁系统&#x2F;驱动调用造成cpu频繁变态（暂存和时间开销）；且直接操作高速设备，减少了等待时间<br>2.2）读缓冲：第一次读磁盘进行系统调用时在用户进程空间开辟buffer缓存从磁盘中读出的数据;再次需要读时直接从buffer读；cpu就不用频繁变态（os预读入：读磁盘会尽量读出更多数据到内核buffer）；且缓存后操作的是高速设备<br>2.3)3种缓冲区类型：</p>
<p>IO频率高，用ansi快,频率低，sys_call实时性好</p>
<h2 id="直接与非直接-I-O机制"><a href="#直接与非直接-I-O机制" class="headerlink" title="直接与非直接 I&#x2F;O机制"></a>直接与非直接 I&#x2F;O机制</h2><h2 id="阻塞与非阻塞-I-O-VS-同步与异步-I-O"><a href="#阻塞与非阻塞-I-O-VS-同步与异步-I-O" class="headerlink" title="阻塞与非阻塞 I&#x2F;O VS 同步与异步 I&#x2F;O"></a>阻塞与非阻塞 I&#x2F;O VS 同步与异步 I&#x2F;O</h2><h2 id="内核读写机制"><a href="#内核读写机制" class="headerlink" title="内核读写机制"></a>内核读写机制</h2><p>内核进程读缓存机制：内核把已读过的目录用目录项这个数据结构缓存在内存，再读到相同目录只需从内存读，提高了文件系统效率</p>
<p>内核进程进行磁盘读写最小单位为数据块：<br>1）磁盘读写的最小单位是<strong>扇区</strong>（<code>512B</code>） ，为提高读写效率，设置每次读写数据块（Linux ：<code>4KB</code>8 个扇区）；<br>eg:<br>用户进程从文件读 1 字节，文件系统则要获取字节所在数据块（内核空间），再返回数据块对应的用户进程所需的数据部分。<br>用户进程写 1 字节进文件，文件系统则找到要写入数据的数据块位置，修改数据块中对应部分，最后再把数据块写回磁盘</p>
<h2 id="打开文件表"><a href="#打开文件表" class="headerlink" title="打开文件表"></a>打开文件表</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">os为每个进程维护一个打开文件表&#123;</span><br><span class="line">    文件位置指针：os跟踪上次读写位置作为当前文件位置指针</span><br><span class="line">    文件打开计数器：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件，该计数器跟踪打开和关闭的数量，当该计数为 0 时，系统关闭文件，删除该条目；</span><br><span class="line">    文件磁盘位置：</span><br><span class="line">    访问权限：进程打开文件有访问模式（创建、只读、读写、添加等），该信息以便操作系统能允许或拒绝 I/O 请求；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ANSI"><a href="#ANSI" class="headerlink" title="ANSI"></a>ANSI</h1><h2 id="stdio-h库全局变量-库宏-库变量类型"><a href="#stdio-h库全局变量-库宏-库变量类型" class="headerlink" title="stdio.h库全局变量&#x2F;库宏&#x2F;库变量类型"></a>stdio.h库全局变量&#x2F;库宏&#x2F;库变量类型</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span>：无符号整数类型，它是 <span class="keyword">sizeof</span> 关键字的结果。</span><br><span class="line">FILE：存储文件流信息的结构体类型。</span><br><span class="line"><span class="type">fpos_t</span>：这是一个适合存储文件中任何位置的对象类型</span><br><span class="line"></span><br><span class="line">errno:调用函数出错时，会重新设置了errno字符串全局变量</span><br><span class="line"></span><br><span class="line"><span class="literal">NULL</span>：空指针常量</span><br><span class="line"></span><br><span class="line">SEEK_CUR、SEEK_END 和 SEEK_SET：fseek 函数中使用，表示文件读写指针（光标位置）</span><br><span class="line"></span><br><span class="line">EOF：文档的结尾都有一个隐藏字符”EOF”，当程序读取它的时候，就会知道文件已经到达结尾；文件结束符只能被clearerr函数清除</span><br><span class="line"></span><br><span class="line"><span class="built_in">stderr</span>、<span class="built_in">stdin</span> 和 <span class="built_in">stdout</span>：这些宏是指向 FILE 类型的指针，对应于标准错误、标准输入和标准输出流。</span><br><span class="line"></span><br><span class="line">_IOFBF、_IOLBF 和 _IONBF：这些宏扩展了带有特定值的整型常量表达式，并适用于 setvbuf 函数的第三个参数。</span><br><span class="line"></span><br><span class="line">BUFSIZ：这个宏是一个整数，该整数代表了 setbuf 函数使用的缓冲区大小。</span><br><span class="line"></span><br><span class="line">FOPEN_MAX：这个宏是一个整数，该整数代表了系统可以同时打开的文件数量。</span><br><span class="line"></span><br><span class="line">FILENAME_MAX：这个宏是一个整数，该整数代表了字符数组可以存储的文件名的最大长度。如果实现没有任何限制，则该值应为推荐的最大值。</span><br><span class="line"></span><br><span class="line">L_tmpnam：这个宏是一个整数，该整数代表了字符数组可以存储的由 tmpnam 函数创建的临时文件名的最大长度。</span><br><span class="line"></span><br><span class="line">TMP_MAX：这个宏是 tmpnam 函数可生成的独特文件名的最大数量。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="fopen-fclose"><a href="#fopen-fclose" class="headerlink" title="fopen&#x2F;fclose"></a>fopen&#x2F;fclose</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line">FILE *<span class="title function_">fdopen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line">FILE *<span class="title function_">freopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *mode, FILE *stream)</span>;</span><br><span class="line"></span><br><span class="line">@path:文件路径名</span><br><span class="line">@mode:打开方式</span><br><span class="line">r  只读，文件必须已存在</span><br><span class="line">r+  可读可写，文件必须已存在（用于更新）</span><br><span class="line">w  只写，不存在则创建，已存在则删除已有文件内容（视为新的空文件）</span><br><span class="line">w+  可读可写，文件不存在则创建，已存在则截断为<span class="number">0</span>字节（视为新的空文件）（用于更新）</span><br><span class="line">a  只允许追加数据，文件不存在则创建</span><br><span class="line">a+  允许读和追加数据，文件不存在则创建</span><br><span class="line">@RET:成功，返回文件指针（FILE *）；否则返回 <span class="literal">NULL</span>，且设置全局变量 errno 标识错误</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fclose(FILE *fp);</span><br><span class="line"></span><br><span class="line">@fp:打开文件的指针</span><br><span class="line">@RET:</span><br><span class="line"><span class="number">0</span>  成功</span><br><span class="line">EOF  失败（EOF为stdio.h定义的宏，=<span class="number">-1</span>）；并设置适当errno的值。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>mode参数加b表示二进制形式打开&#x2F;关闭，否则默认为文本模式t；二进制模式处理是为了跨平台，因为win平台字符处理时会把\n转化为\r\n</p>
<h2 id="fseek-rewind-ftell"><a href="#fseek-rewind-ftell" class="headerlink" title="fseek&#x2F;rewind&#x2F;ftell"></a>fseek&#x2F;rewind&#x2F;ftell</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//移动文件读写位置光标</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *fp,<span class="type">long</span> offset,<span class="type">int</span> whence)</span>;</span><br><span class="line"></span><br><span class="line">@fp:指向打开的文件</span><br><span class="line">@offset:相较whence的偏移字节</span><br><span class="line">@whence:文件内部指针的基准：</span><br><span class="line">SEEK_SET 文件开始位置，其值为<span class="number">0</span></span><br><span class="line">SEEK_CUR 文件当前位置，其值为<span class="number">1</span></span><br><span class="line">SEEK_END 文件结束位置，其值为<span class="number">2</span></span><br><span class="line">@RET:成功<span class="number">0</span>。失败<span class="number">-1</span></span><br><span class="line">============================================================================================</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//重置文件指针到开始位置</span></span><br><span class="line"><span class="type">void</span> rewind(FILE *fp);</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="type">long</span> ftell(FILE *fp);</span><br><span class="line"></span><br><span class="line">@RET:出错返回<span class="number">-1</span>;否则报告当前光标位置距离文件开始处是第几个字符</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="fwrite-fread"><a href="#fwrite-fread" class="headerlink" title="fwrite&#x2F;fread"></a>fwrite&#x2F;fread</h2><p>fread不区分文件结束和错误。如有必要，请使用feof和ferror</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr,<span class="type">size_t</span> size,<span class="type">size_t</span> n,FILE *fp)</span>;</span><br><span class="line"></span><br><span class="line">@ptr:要写入数据内存块的指针</span><br><span class="line">@size:要写入的字节大小，通常为<span class="keyword">sizeof</span>(数据类型)。</span><br><span class="line">@n:写入内存块个数</span><br><span class="line">@fp:要写入文件的指针</span><br><span class="line">@RET:返回写入内存块个数，若与 n 不同，则可能发生了一个错误或者到达了文件末尾。</span><br><span class="line">如果成功写入，文件内部指针会向右移动n*size</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> fread(<span class="type">void</span> *ptr,<span class="type">size_t</span> size,<span class="type">size_t</span> n,FILE *fp);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="fputs-fgets"><a href="#fputs-fgets" class="headerlink" title="fputs&#x2F;fgets"></a>fputs&#x2F;fgets</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//将s指向的字符串，舍去结束标记’\0’后写入到fp指向的文件缓冲区</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s,FILE *fp)</span>;</span><br><span class="line"></span><br><span class="line">@s：指向要写入的字符串</span><br><span class="line">@fp:指向被写入的文件（文件缓冲区）</span><br><span class="line">@RET:返回写入的实际字符数；出现错误，返回EOF</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="comment">//从fp所指向的文件缓冲区当前位置读size-1个字符，并在其后补充’\0’，写入到s指向的内存区；读取到换行符，或到达文件末尾会停止</span></span><br><span class="line"><span class="type">char</span> *fgets(<span class="type">char</span> *s,<span class="type">int</span> size,FILE *fp);</span><br><span class="line"></span><br><span class="line">@RET:成功，返回相同的 fp 参数。如果到达文件末尾或者没有读取到任何字符，返回一个空指针。如果发生错误，返回一个空指针</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="fgetc-fputc"><a href="#fgetc-fputc" class="headerlink" title="fgetc&#x2F;fputc"></a>fgetc&#x2F;fputc</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getchar</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> c, FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">putchar</span><span class="params">(<span class="type">int</span> c)</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="feof-ferror-clearerr-perror"><a href="#feof-ferror-clearerr-perror" class="headerlink" title="feof&#x2F;ferror&#x2F;clearerr&#x2F;perror"></a>feof&#x2F;ferror&#x2F;clearerr&#x2F;perror</h2><p>EOF 宏表示读到文件结尾，还能表示 I&#x2F;O 操作中的读、写错误以及其他一些关联操作的错误状态。仅凭返回 EOF(-1) 就认为文件结束显然是不正确的。 &#x20;<br>实际的程序中，应该每执行一次文件操作，就用 ferror 函数检测是否出错（IO操作<strong>返回值也有所反映</strong>）；用 feof 函数检测文件是否结束</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">feof</span><span class="params">(FILE *fp)</span>;<span class="comment">//查看光标后是否还有内容，有返回0，无返回1</span></span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">    FILE *p;</span><br><span class="line">    p = fopen(<span class="string">&quot;open.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);<span class="comment">//空文件</span></span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) </span><br><span class="line">     &#123;</span><br><span class="line">        perror(<span class="string">&quot;打开文件时发生错误&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    getc(p);</span><br><span class="line">    <span class="keyword">if</span> (feof(p))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件为空。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rewind(p);<span class="comment">//将光标跳回到文件开头</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//无论是空文件，还是存有信息的文件，当文件被打开，光标处于默认的开头时，光标后都有信息(空文件中有EOF)；所以要光标向后一位在调用feof；</span></span><br><span class="line">============================================================================================</span><br><span class="line"><span class="type">int</span> ferror(FILE *fp);<span class="comment">//返回为真时就表示有错误发生</span></span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">   fp = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);<span class="comment">//空文件</span></span><br><span class="line">   c = fgetc(fp);</span><br><span class="line">   <span class="keyword">if</span>( ferror(fp) )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;读取文件：file.txt 时发生错误\n&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   clearerr(fp);</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="type">void</span> clearerr(FILE *stream)<span class="comment">//清除给定流(字节序列) 的文件结束和错误标识符</span></span><br><span class="line">============================================================================================</span><br><span class="line"><span class="type">void</span> perror(<span class="type">const</span> <span class="type">char</span> *str)</span><br><span class="line"><span class="comment">//把一个自定义错误描述str输出到 stderr。首先输出字符串 str，后跟一个冒号，然后是一个空格，然后是errno</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="printf-scanf"><a href="#printf-scanf" class="headerlink" title="printf&#x2F;scanf"></a>printf&#x2F;scanf</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//*printf打印到标准输出，fprintf打印到指定的文件。sprintf打印到用户提供的缓冲区str中并在末尾加&#x27;\0&#x27;；</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line">@RET:成功返回格式化输出的字节数（不包括字符串的结尾<span class="string">&#x27;\0&#x27;</span>），出错返回一个负值</span><br><span class="line"></span><br><span class="line"><span class="comment">//snprintf更安全，参数size指定了缓冲区长度，若格式化后字符串长度超过缓冲区，snprintf就把字符串截断到size-1字节，再加上一个&#x27;\0&#x27;写入缓冲区，能保证字符串以&#x27;\0&#x27;结尾</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line">@RET:成功返回格式化输出的字节数（不包括字符串的结尾<span class="string">&#x27;\0&#x27;</span>），出错返回一个负值;</span><br><span class="line">如果字符串被截断，返回的是截断之前的长度，把它和实际缓冲区中的字符串长度相比较就可以知道是否发生了截断。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vsprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vsnprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//scanf从标准输入读字符，按format解释这些字符后赋给后面的传出参数(传地址而不能传值);fscanf从指定的文件中读字符</span></span><br><span class="line"><span class="comment">//而sscanf从指定的字符串str中读字符</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">scanf</span>(<span class="type">const</span> <span class="type">char</span> *format, ...);</span><br><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"></span><br><span class="line">@RET:成功匹配一个转换说明就给一个参数赋值，如果读到文件或字符串末尾就停止</span><br><span class="line">或者如果遇到和格式化字符串不匹配的地方（比如转换说明是%d却读到字符A）就停止。则<span class="built_in">scanf</span>的返回值可能小于赋值参数的个数，文件的读写位置指向输入中不匹配的地方，下次调用库函数读文件时可以从这个位置继续。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vsscanf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">vfscanf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span>;</span><br><span class="line">============================================================================================</span><br><span class="line">%d 十进制有符号整数</span><br><span class="line">%u 十进制无符号整数</span><br><span class="line">%f 浮点数</span><br><span class="line">%s 字符串</span><br><span class="line">%c 单个字符</span><br><span class="line">%p 指针的值</span><br><span class="line">%e 指数形式的浮点数</span><br><span class="line">%x, %X 无符号以十六进制表示的整数</span><br><span class="line">%o 无符号以八进制表示的整数</span><br><span class="line">%g 把输出的值按照 %e 或者 %f 类型中输出长度较小的方式输出</span><br><span class="line">%p 输出地址符</span><br><span class="line">%lu <span class="number">32</span>位无符号整数</span><br><span class="line">%llu <span class="number">64</span>位无符号整数</span><br><span class="line">%% 输出百分号字符本身。</span><br><span class="line">%<span class="number">-10</span>s：左对齐并占用宽度为 <span class="number">10</span> 的字符串；</span><br><span class="line">%<span class="number">5.2f</span>：右对齐并占用宽度为 <span class="number">5</span>，保留两位小数的浮点数；</span><br><span class="line">%<span class="meta">#x：输出带有 0x 前缀的十六进制数。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h1><h2 id="open-close"><a href="#open-close" class="headerlink" title="open&#x2F;close"></a>open&#x2F;close</h2><p>查看进程当前已打开的文件描述符：cat &#x2F;proc&#x2F;进程ID&#x2F;fd</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname,<span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname,<span class="type">int</span> flags,<span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">creat</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname,<span class="type">mode_t</span> mode)</span>;</span><br><span class="line"></span><br><span class="line">@flags：位图参数；&lt;fcntl.h&gt;中的<span class="number">3</span>类宏可位或|</span><br><span class="line"><span class="number">1</span>）访问方式</span><br><span class="line">O_RDONLY：  只读</span><br><span class="line">O_WRONLY：  只写</span><br><span class="line">O_RDWR：  可读写</span><br><span class="line"><span class="number">2</span>）打开时标志</span><br><span class="line">O_CREAT：  不存在则创建。使用此选项时需要提供第三个参数mode，表示该文件的访问权限；无此标志时打开文件不存在会出错返回</span><br><span class="line">O_EXCL：  与O_CREAT联用，如果文件已存在则返回错误</span><br><span class="line">O_TRUNC：  如果文件已存在，且以只写或可读可写方式打开，则将其长度截断（Truncate）为<span class="number">0</span>字节；即清空文件的内容，仅对普通文件有用；</span><br><span class="line">         open一个文件时必须明确指定O_TRUNC才会截断文件，否则直接在原来的数据上改写</span><br><span class="line">O_NOATIME：不更新访问时间戳</span><br><span class="line">O_NOCTTY：  若打开的文件是终端设备，不让它作为该进程的控制终端</span><br><span class="line">O_NOBLOCK：  以非阻塞模式访问；read/write不会阻塞</span><br><span class="line">O_DIRECTORY：如果文件名是目录，则打开失败</span><br><span class="line"><span class="number">3</span>）IO操作方式</span><br><span class="line">O_DIRECT：   直接IO</span><br><span class="line">O_APPEND：  追加而非覆盖</span><br><span class="line">O_NONBLOCK：  对文件的read()/write()，当无立即可用输入(或输出不能立即写出)时能以EAGAIN错误状态标志立即返回</span><br><span class="line">O_ASYNC：  (异步)此标志被设置，文件描述符有输入数据时会生成SIGIO信号</span><br><span class="line">O_SYNC：每次write都等到物理 I/O 操作完成后才返回</span><br><span class="line">O_DSYNC：等待物理 I/O 数据完成，不等待文件属性更新</span><br><span class="line">O_RSYNC</span><br><span class="line">@mode：知道具有权限；实际要&amp;~umask</span><br><span class="line">@RET：成功返回新分配的文件描述符，出错返回<span class="number">-1</span>并设置errno</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> close(<span class="type">int</span> fd);</span><br><span class="line"></span><br><span class="line">@RET：成功返回<span class="number">0</span>，出错返回<span class="number">-1</span>并设置errno</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h2><p>内核中对一个文件描述符（fd）的偏移量只维护一个值，也就是说你用读写方式打开一个文件，如果先用read读取了n个字符，紧接着用write写入字符，那么后来写入字符从n+1个字符位置开始。所以需要用lseek来使fd的偏移量置于文件开始位置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"></span><br><span class="line">@fd：文件描述符</span><br><span class="line">@offset：偏移量</span><br><span class="line">@whence：偏移量的基准位置。</span><br><span class="line">SEEK_SET 文件开始位置，其值为<span class="number">0</span></span><br><span class="line">SEEK_CUR 文件当前位置，其值为<span class="number">1</span></span><br><span class="line">SEEK_END 文件结束位置，其值为<span class="number">2</span></span><br><span class="line">@RET:</span><br></pre></td></tr></table></figure>

<h2 id="read-write"><a href="#read-write" class="headerlink" title="read&#x2F;write"></a>read&#x2F;write</h2><p>当进程调用一个阻塞的系统函数时，该进程被置于睡眠（Sleep）状态，这时内核调度其它进程运行（read内部实现中：如果缓冲区中没有数据可读，就切换到阻塞态）；<br>直到该进程等待的事件发生了（比如网络上接收到数据包，或者调用<code>sleep</code>指定的睡眠时间到了）它才有可能继续运行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"></span><br><span class="line">@fd: 文件描述符</span><br><span class="line">@buf:  读取数据存在buf指针指向的缓冲区;如果buf是一个字符数组名，count用它的<span class="keyword">sizeof</span>值。若buf是字符指针（字符串）则count用它的<span class="built_in">strlen</span>值</span><br><span class="line">@count:  读取字节数</span><br><span class="line">@RET:成功，返回读取的字节数，提前遇到EOF，则返回<span class="number">0</span>。出错返回<span class="number">-1</span>，并设置相应errno值；如果errno的值是EINTR，表示遇到调用信号而中断了读取，那么我们可以再次尝试read；</span><br><span class="line">从终端设备读，通常以行为单位，读到换行符就返回；</span><br><span class="line">从网络读，根据不同的传输层协议和内核缓存机制，返回值可能小于请求的字节数</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> write(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count);</span><br><span class="line"></span><br><span class="line">@fd：  文件描述符</span><br><span class="line">@buf：  写入的数据存放在buf指针指向的缓冲区</span><br><span class="line">@count：  写入的字节数</span><br><span class="line">@RET:成功，返回值为写入的字节数；否则返回值为<span class="number">-1</span>，并设置相应的errno值</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用O_NONBLOCK标志打开设备时，read&#x2F;write操作不会被阻塞。以read为例，如果设备当前没有可读数据，read函数会立即返回-1，并将errno设置为EWOULDBLOCK&#x2F;EAGAIN。表示在正常情况下应该被阻塞（would block）。调用者应该尝试再次读取（again）。这种行为方式被称为轮询（Poll），调用者只是查询一下设备状态，而不是在这里阻塞等待，这样可以同时监视多个设备。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/dev/device&quot;</span>, O_RDONLY | O_NONBLOCK);  <span class="comment">// 打开设备文件，指定O_NONBLOCK标志</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="type">ssize_t</span> bytesRead;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i)&#123;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">if</span>((bytesRead = read(fd, buffer, <span class="keyword">sizeof</span>(buffer))) &gt; <span class="number">0</span>) &#123;  <span class="comment">// 使用read读取设备数据;如果无数据会在这一步阻塞</span></span><br><span class="line">        <span class="comment">// 处理读取到的数据</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (bytesRead == <span class="number">-1</span>) &#123;<span class="comment">//不等待就绪，而是在一个较短的时间窗口内轮询几次</span></span><br><span class="line">        <span class="keyword">if</span> (errno == EWOULDBLOCK || errno == EAGAIN) &#123;</span><br><span class="line">            <span class="comment">// 设备暂时没有数据可读，稍后再试</span></span><br><span class="line">            perror(<span class="string">&quot;Try again NO.%d\n&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//出错</span></span><br><span class="line">            perror(<span class="string">&quot;read_error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(fd);  <span class="comment">// 关闭设备文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="fcntl-ioctl？"><a href="#fcntl-ioctl？" class="headerlink" title="fcntl&#x2F;ioctl？"></a>fcntl&#x2F;ioctl？</h2><p><a href="https://zhuanlan.zhihu.com/p/88457656" title=" linux驱动中ioctl函数的讲解 第30章IOCTL函数30-1：ioctl函数的作用：设备在运行的时候可能要求数据的写入是连续的，如果这个时候仍然用WRITE函数去写指令的话，就有可能导致数据的不连续，比如声卡放音乐卡顿，电影播放不流畅等等的情况，为… https://zhuanlan.zhihu.com/p/88457656"> linux驱动中ioctl函数的讲解 第30章IOCTL函数30-1：ioctl函数的作用：设备在运行的时候可能要求数据的写入是连续的，如果这个时候仍然用WRITE函数去写指令的话，就有可能导致数据的不连续，比如声卡放音乐卡顿，电影播放不流畅等等的情况，为… https://zhuanlan.zhihu.com/p/88457656</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">//可用fcntl函数改变已打开文件的访问属性，而不需重新打开文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, <span class="type">long</span> arg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, <span class="keyword">struct</span> flock *lock)</span>;</span><br><span class="line"></span><br><span class="line">@fd： 文件描述符</span><br><span class="line">@cmd： 控制操作命令</span><br><span class="line">F_DUPFD    复制文件描述符</span><br><span class="line">F_GETFD    获取文件描述符标签</span><br><span class="line">F_SETFD    设置文件描述符标签</span><br><span class="line">F_GETFL    获取文件描述符的状态标志</span><br><span class="line">F_SETFL    设置文件描述符的状态标志</span><br><span class="line">F_GETFLK    获取文件锁</span><br><span class="line">F_SETFLK    设置文件锁</span><br><span class="line">F_SETLKW    阻塞地设置或释放文件锁，要等待完成</span><br><span class="line">F_GETOWN    获取收到SIGIO信号的进程或进程组ID</span><br><span class="line">F_SETOWN    设置接收SIGIO信号的进程或进程组ID</span><br><span class="line">@arg： 命令的参数</span><br><span class="line">@RET:</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">    <span class="type">int</span> fd, flags，oldflags;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;file.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((oldflags= fcntl(fd, F_GETFL)) == <span class="number">-1</span>) &#123;<span class="comment">// 获取旧文件描述符标志</span></span><br><span class="line">        perror(<span class="string">&quot;fcntl - F_GETFL&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flags = oldflags | O_NONBLOCK;</span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETFL, flags) == <span class="number">-1</span>) &#123;<span class="comment">// 设置非阻塞标志</span></span><br><span class="line">        perror(<span class="string">&quot;fcntl - F_SETFL&quot;</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件描述符已设置为非阻塞模式。\n&quot;</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="comment">//可用fcntl函数改变已打开文件的属性（最终要修改设备），而不需重新打开文件</span></span><br><span class="line"><span class="type">int</span> ioctl(<span class="type">int</span> fd, <span class="type">int</span> request, ...);</span><br><span class="line"></span><br><span class="line">@request:命令参数；ioctl-》sys.ioctl-&gt;driver;设备驱动会根据这个传下来的cmd进行操作</span><br><span class="line">可变参数取决于request，通常是一个指向变量或结构体的指针。</span><br><span class="line">@RET:出错返回<span class="number">-1</span>，成功返回值取决于request;并设置全局变量 errno :</span><br><span class="line">EBADF d is not a valid descriptor. </span><br><span class="line">EFAULT argp references an inaccessible memory area. </span><br><span class="line">EINVAL Request or argp is not valid. </span><br><span class="line">ENOTTY d is not associated with a character special device. </span><br><span class="line">ENOTTY The specified request does not apply to the kind of object that the descriptor d references.</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line">ret = ioctl(fd, MYCMD);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ioctl: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//原子操作：文件描述符重定向；重定向目标文件要保证打开</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line"></span><br><span class="line">@RET:dup2成功返回新的文件描述符，出错返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">newfd = dup(<span class="number">1</span>);    <span class="comment">//返回最小可用文件描述符给newfd；并将newfd重定向到标准输出；则newfd和1都指向stdout</span></span><br><span class="line">dup2(<span class="number">1</span>,<span class="number">5</span>);         <span class="comment">//将“5”重定向到标准输出,这样操作5相当于操作1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">eg2:<span class="comment">//重定向stdout</span></span><br><span class="line">  <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>((fd = open(<span class="string">&quot;test.txt&quot;</span>,O_RDWR|O_CREAT|O_TRUNC)) == <span class="number">-1</span>) <span class="comment">//打开并清空外部文件</span></span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;open failed !&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span> oldfd = <span class="number">-1</span>;     </span><br><span class="line">  <span class="keyword">if</span>(oldfd = dup(<span class="number">1</span>) == <span class="number">-1</span>)           <span class="comment">//oldfd-&gt;stdout;保存原来指向</span></span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;fd redirect failed !&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">         </span><br><span class="line">  <span class="keyword">if</span>(dup2(fd,<span class="number">1</span>) == <span class="number">-1</span>)                    <span class="comment">//1-&gt;test.txt</span></span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;1 redirect failed !&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//重定向后进行操作</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>( dup2(oldfd,<span class="number">1</span>) == <span class="number">-1</span>)                    <span class="comment">//1-&gt;stdout;重定向恢复</span></span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;std redirect failed !&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  close(fd);</span><br><span class="line">  close(oldfd);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2><p><img src="/image/image_z9Z3NvZfDU.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="comment">/*把部分磁盘文件映射到内存，则文件中的位置直接就有对应的内存地址，</span></span><br><span class="line"><span class="comment">1）对文件的读写可直接用指针来做；且系统会自动回写脏页面到对应的文件磁盘上；那么就不需要read/write函数;这样能获得较高的性能</span></span><br><span class="line"><span class="comment">2）内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> prot, <span class="type">int</span> flag, <span class="type">int</span> filedes, <span class="type">off_t</span> off)</span>;</span><br><span class="line"></span><br><span class="line">@addr：指向欲映射的内存起始地址，通常设为 <span class="literal">NULL</span>，代表让系统自动选定地址，映射成功后返回该地址。</span><br><span class="line">@length：代表将文件中多大的部分映射到内存。</span><br><span class="line">@prot：映射区域保护方式。为以下宏组合：</span><br><span class="line">PROT_EXEC 映射区域可被执行</span><br><span class="line">PROT_READ 映射区域可读取</span><br><span class="line">PROT_WRITE 映射区域可写入</span><br><span class="line">PROT_NONE 映射区域不能存取</span><br><span class="line">@flags：影响映射区域的各种特性。在调用mmap()时必须要指定MAP_SHARED 或MAP_PRIVATE。</span><br><span class="line">MAP_FIXED： 如果参数start所指的地址无法成功建立映射时，则放弃映射，不对地址做修正。通常不鼓励用此旗标。</span><br><span class="line">MAP_SHARED：对映射区域写入数据会复制回文件内，而且允许其他映射该文件的进程共享。</span><br><span class="line">MAP_PRIVATE： 对映射区域的写入操作会产生一个映射文件的复制，即私人的“写入时复制”（copy on write）对此区域作的任何修改都不会写回原来的文件内容。</span><br><span class="line">MAP_ANONYMOUS：建立匿名映射。此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享。</span><br><span class="line">MAP_DENYWRITE：只允许对映射区域的写入操作，其他对文件直接写入的操作将会被拒绝。</span><br><span class="line">MAP_LOCKED： 将映射区域锁定住，这表示该区域不会被置换（swap）。</span><br><span class="line">@fd：要映射到内存中的文件描述符。如果使用匿名内存映射时，即flags中设置了MAP_ANONYMOUS，fd设为<span class="number">-1</span>。有些系统不支持匿名内存映射，则可以使用fopen打开/dev/zero文件，然后对该文件进行映射，可以同样达到匿名内存映射的效果。</span><br><span class="line">@offset：文件映射的偏移量，通常设置为<span class="number">0</span>，代表从文件最前方开始对应，offset必须是分页大小的整数倍。</span><br><span class="line">@RET：映射成功返回映射区内存起始地址，否则返回MAP_FAILED(－<span class="number">1</span>)，错误原因存于errno 中：</span><br><span class="line">EBADF 参数fd 不是有效的文件描述词</span><br><span class="line">EACCES 存取权限有误。如果是MAP_PRIVATE 情况下文件必须可读，使用MAP_SHARED则要有PROT_WRITE以及该文件要能写入。</span><br><span class="line">EINVAL 参数start、length 或offset有一个不合法。</span><br><span class="line">EAGAIN 文件被锁住，或是有太多内存被锁住。</span><br><span class="line">ENOMEM 内存不足。</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="comment">//该调用在进程地址空间中解除一个映射关系，addr是调用mmap()时返回的地址，len是映射区的大小；</span></span><br><span class="line"><span class="comment">//当映射关系解除后，对原来映射地址的访问将导致段错误发生。</span></span><br><span class="line"><span class="type">int</span> munmap(<span class="type">void</span> *addr, <span class="type">size_t</span> len);</span><br><span class="line"></span><br><span class="line">@RET:成功返回<span class="number">0</span>。失败返回<span class="number">-1</span>，error返回标志和mmap一致；</span><br><span class="line">============================================================================================</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="comment">//在调用了munmap()后或者msync()时，才把内存中的相应内容写回磁盘文件，所写内容不能超过文件大小</span></span><br><span class="line"><span class="type">int</span> msync(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> flags );</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">///////////////ANSI</span></span><br><span class="line"><span class="comment">///////////////posix</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">char</span>* f_name,<span class="type">int</span> mode)</span></span><br><span class="line">@f_name：文件名</span><br><span class="line">@mode：O_RDONLY,O_WRONLY,O_EDWR </span><br><span class="line">@<span class="keyword">return</span>:-1错误;成功返回文件描述符</span><br><span class="line"></span><br><span class="line">creat()</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span>* buf, <span class="type">size_t</span> qty)</span></span><br><span class="line">@fd：从指定文件描述符fd映射的文件读取qty字节放到buf</span><br><span class="line">@buf：</span><br><span class="line">@qty:</span><br><span class="line">@<span class="keyword">return</span>:-1错误;成功返回numread</span><br><span class="line"></span><br><span class="line"><span class="title function_">write</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">@fd</span><br><span class="line">@<span class="keyword">return</span>:-1错误，0成功</span><br><span class="line"><span class="comment">///////////////winapi</span></span><br><span class="line"><span class="comment">///who</span></span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_ls</span><span class="params">(<span class="type">char</span>[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span><span class="comment">//字符串指针数组</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc == <span class="number">1</span>)&#123;<span class="comment">//只有1个参数，为指令本身；查看当前目录</span></span><br><span class="line">        do_ls(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(--argc)&#123;<span class="comment">//查看指定的一个或多个目录</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s : \n&quot;</span>, * ++argv);<span class="comment">//打印当前所查看的目录路径</span></span><br><span class="line">            do_ls(*argv);<span class="comment">//print环节</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_ls</span><span class="params">(<span class="type">char</span> dirname[])</span></span><br><span class="line">&#123;</span><br><span class="line">    DIR *dir_ptr;<span class="comment">//文件夹指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">direntp</span>;</span><span class="comment">//存放文件夹目录内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((dir_ptr = opendir(dirname)) == <span class="literal">NULL</span>)&#123;<span class="comment">//open环节</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ls1: Cannot open %s\n&quot;</span>,dirname);<span class="comment">//打开失败</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>((direntp = readdir(dir_ptr)) != <span class="literal">NULL</span>)&#123;<span class="comment">//while（readdir）</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,direntp -&gt; d_name);<span class="comment">//d_name:当前遍历子项的文件名，限制长度为256，包括字符串终止符’\0’</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> flag;</span><br><span class="line">        <span class="keyword">if</span>(( flag = closedir(dir_ptr)) == <span class="number">-1</span>)&#123;<span class="comment">//close环节</span></span><br><span class="line">            perror(<span class="string">&quot;ls1: Cannot close dir&quot;</span>);<span class="comment">//关闭失败</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E6%93%8D%E4%BD%9C/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="系统时间操作"><a href="#系统时间操作" class="headerlink" title="系统时间操作"></a>系统时间操作</h1>]]></content>
  </entry>
  <entry>
    <title>进程管理（多任务调度器）</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8%EF%BC%89/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8%EF%BC%89/</url>
    <content><![CDATA[<p>编写的代码是存储在硬盘的静态文件，编译后生成二进制可执行文件；**<br>进程（运行中的程序Process）**：运行可执行文件后，其被装载到内存，接着 CPU 执行程序中的指令；可见进程会占用cpu和内存资源</p>
<p>多任务运行的形式：<br>1）多核cpu并行运行多任务<br>2）单核cpu并发（多任务分时运行）</p>
<p><img src="/image/image_qcX7R97Hjv.png"></p>
<p><img src="/image/image_2e7v2-j-HF.png"></p>
<p>进程管理提供：多任务并发&#x2F;并行的基础<br>1）进程资源维护：运行的程序要占有系统资源；由PCB数据结构维护进程数据：主要有）进程描述信息）进程状态及调度优先级信息）资源分配清单）断点现场暂存信息）</p>
<p>2）进程控制：任务的创建，切换，终止机制包括cpu调度、分配资源、进程间通信，及维护进程相关数据结构等操作。<br>2.2）进程调度：设计调度算法,合理分配cpu资源，提高cpu利用率，系统的吞吐量和响应时间;创建状态队列跟踪和管理进程状态；<br>2.3）进程通信与同步</p>
<p>3）多线程：设计调度算法,合理分配cpu资源，提高cpu利用率</p>
<h1 id="进程资源维护"><a href="#进程资源维护" class="headerlink" title="进程资源维护"></a>进程资源维护</h1><h2 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h2><p>1）<strong>进程描述信息：</strong><br>进程标识符PID<br>用户标识符UID：进程归属用户，主要为共享和保护服务；<br><strong>2）</strong>进程状态及调度优先级信息<strong>：</strong><br>进程当前状态，如 new、ready、running、waiting 或 blocked 等；<br>进程优先级：进程抢占 CPU 时的优先级；<br><strong>3）资源分配清单：</strong><br>有关内存地址空间或虚拟地址空间的信息，打开文件列表和所使用的 I&#x2F;O 设备信息（文件描述符表）<br><strong>4）</strong>断点现场暂存信息<strong>：</strong><br>CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">long</span> state; <span class="comment">//说明了该进程是否可以执行，还是可中断等信息</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> flags; <span class="comment">// flags 是进程号，在调用fork()时给出</span></span><br><span class="line">  <span class="type">int</span> sigpending; <span class="comment">// 进程上是否有待处理的信号</span></span><br><span class="line"> </span><br><span class="line">   <span class="type">mm_segment_t</span> addr_limit;  <span class="comment">//进程地址空间,区分内核进程与普通进程在内存存放的位置不同  //0-0xBFFFFFFF for user-thead    //0-0xFFFFFFFF for kernel-thread</span></span><br><span class="line">   <span class="comment">//调度标志,表示该进程是否需要重新调度,若非0,则当从内核态返回到用户态,会发生调度</span></span><br><span class="line">   <span class="keyword">volatile</span> <span class="type">long</span> need_resched;</span><br><span class="line">   <span class="type">int</span> lock_depth;    <span class="comment">//锁深度</span></span><br><span class="line">   <span class="type">long</span> nice;       <span class="comment">//进程的基本时间片</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//进程的调度策略,有三种,实时进程:SCHED_FIFO,SCHED_RR, 分时进程:SCHED_OTHER</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> policy;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>    <span class="comment">//进程内存管理信息</span></span><br><span class="line"> </span><br><span class="line">   <span class="type">int</span> processor;</span><br><span class="line">   <span class="comment">//若进程不在任何CPU上运行, cpus_runnable 的值是0，否则是1 这个值在运行队列被锁时更新</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> cpus_runnable, cpus_allowed;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">run_list</span>;</span>   <span class="comment">//指向运行队列的指针</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> sleep_time;   <span class="comment">//进程的睡眠时间</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//用于将系统中所有的进程连成一个双向循环链表, 其根是init_task</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">next_task</span>, *<span class="title">prev_task</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">active_mm</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">local_pages</span>;</span>      <span class="comment">//指向本地页面      </span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> allocation_order, nr_local_pages;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> *<span class="title">binfmt</span>;</span>      <span class="comment">//进程所运行的可执行文件的格式</span></span><br><span class="line">   <span class="type">int</span> exit_code, exit_signal;</span><br><span class="line">   <span class="type">int</span> pdeath_signal;           <span class="comment">//父进程终止时向子进程发送的信号</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> personality;</span><br><span class="line">   <span class="comment">//Linux可以运行由其他UNIX操作系统生成的符合iBCS2标准的程序</span></span><br><span class="line">   <span class="type">int</span> did_exec:<span class="number">1</span>; </span><br><span class="line">   <span class="type">pid_t</span> pid;          <span class="comment">//进程标识符,用来代表一个进程</span></span><br><span class="line">   <span class="type">pid_t</span> pgrp;        <span class="comment">//进程组标识,表示进程所属的进程组</span></span><br><span class="line">   <span class="type">pid_t</span> tty_old_pgrp;      <span class="comment">//进程控制终端所在的组标识</span></span><br><span class="line">   <span class="type">pid_t</span> session;             <span class="comment">//进程的会话标识</span></span><br><span class="line">   <span class="type">pid_t</span> tgid;</span><br><span class="line">   <span class="type">int</span> leader;    <span class="comment">//表示进程是否为会话主管</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_opptr</span>,*<span class="title">p_pptr</span>,*<span class="title">p_cptr</span>,*<span class="title">p_ysptr</span>,*<span class="title">p_osptr</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">thread_group</span>;</span>          <span class="comment">//线程链表</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">pidhash_next</span>;</span>    <span class="comment">//用于将进程链入HASH表</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> **<span class="title">pidhash_pprev</span>;</span></span><br><span class="line">   <span class="type">wait_queue_head_t</span> wait_chldexit;      <span class="comment">//供wait4()使用</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">vfork_done</span>;</span>         <span class="comment">//供vfork() 使用</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> rt_priority;       <span class="comment">//实时优先级，用它计算实时进程调度时的weight值</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">   <span class="comment">//it_real_value，it_real_incr用于REAL定时器，单位为jiffies, 系统根据it_real_value</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//设置定时器的第一个终止时间. 在定时器到期时，向进程发送SIGALRM信号，同时根据</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//it_real_incr重置终止时间，it_prof_value，it_prof_incr用于Profile定时器，单位为jiffies。</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//当进程运行时，不管在何种状态下，每个tick都使it_prof_value值减一，当减到0时，向进程发送</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//信号SIGPROF，并根据it_prof_incr重置时间.</span></span><br><span class="line">   <span class="comment">//it_virt_value，it_virt_value用于Virtual定时器，单位为jiffies。当进程运行时，不管在何种</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//状态下，每个tick都使it_virt_value值减一当减到0时，向进程发送信号SIGVTALRM，根据</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//it_virt_incr重置初值。</span></span><br><span class="line"> </span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> it_real_value, it_prof_value, it_virt_value;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> it_real_incr, it_prof_incr, it_virt_value;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">real_timer</span>;</span>        <span class="comment">//指向实时定时器的指针</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">tms</span> <span class="title">times</span>;</span>                      <span class="comment">//记录进程消耗的时间</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> start_time;          <span class="comment">//进程创建的时间</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//记录进程在每个CPU上所消耗的用户态时间和核心态时间</span></span><br><span class="line">   <span class="type">long</span> per_cpu_utime[NR_CPUS], per_cpu_stime[NR_CPUS]; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">   <span class="comment">//内存缺页和交换信息:</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//min_flt, maj_flt累计进程的次缺页数（Copy on　Write页和匿名页）和主缺页数（从映射文件或交换</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//设备读入的页面数）； nswap记录进程累计换出的页面数，即写到交换设备上的页面数。</span></span><br><span class="line">   <span class="comment">//cmin_flt, cmaj_flt, cnswap记录本进程为祖先的所有子孙进程的累计次缺页数，主缺页数和换出页面数。</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//在父进程回收终止的子进程时，父进程会将子进程的这些信息累计到自己结构的这些域中</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> min_flt, maj_flt, nswap, cmin_flt, cmaj_flt, cnswap;</span><br><span class="line">   <span class="type">int</span> swappable:<span class="number">1</span>; <span class="comment">//表示进程的虚拟地址空间是否允许换出</span></span><br><span class="line">   <span class="comment">//进程认证信息</span></span><br><span class="line">   <span class="comment">//uid,gid为运行该进程的用户的用户标识符和组标识符，通常是进程创建者的uid，gid</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//euid，egid为有效uid,gid</span></span><br><span class="line">   <span class="comment">//fsuid，fsgid为文件系统uid,gid，这两个ID号通常与有效uid,gid相等，在检查对于文件</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//系统的访问权限时使用他们。</span></span><br><span class="line">   <span class="comment">//suid，sgid为备份uid,gid</span></span><br><span class="line">   <span class="type">uid_t</span> uid,euid,suid,fsuid;</span><br><span class="line">   <span class="type">gid_t</span> gid,egid,sgid,fsgid;</span><br><span class="line">   <span class="type">int</span> ngroups;                  <span class="comment">//记录进程在多少个用户组中</span></span><br><span class="line">   <span class="type">gid_t</span> groups[NGROUPS];      <span class="comment">//记录进程所在的组</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//进程的权能，分别是有效位集合，继承位集合，允许位集合</span></span><br><span class="line">   <span class="type">kernel_cap_t</span> cap_effective, cap_inheritable, cap_permitted;</span><br><span class="line"> </span><br><span class="line">   <span class="type">int</span> keep_capabilities:<span class="number">1</span>;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim</span>[<span class="title">RLIM_NLIMITS</span>];</span>    <span class="comment">//与进程相关的资源限制信息</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">short</span> used_math;         <span class="comment">//是否使用FPU</span></span><br><span class="line">   <span class="type">char</span> comm[<span class="number">16</span>];                      <span class="comment">//进程正在运行的可执行文件名</span></span><br><span class="line">   <span class="type">int</span> link_count, total_link_ count;  <span class="comment">//文件系统信息</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//NULL if no tty 进程所在的控制终端，如果不需要控制终端，则该指针为空</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> locks;</span><br><span class="line">   <span class="comment">//进程间通信信息</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> *<span class="title">semundo</span>;</span>       <span class="comment">//进程在信号灯上的所有undo操作</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> *<span class="title">semsleeping</span>;</span>   <span class="comment">//当进程因为信号灯操作而挂起时，他在该队列中记录等待的操作</span></span><br><span class="line">   <span class="comment">//进程的CPU状态，切换时，要保存到停止进程的task_struct中</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> <span class="title">thread</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span>           <span class="comment">//文件系统信息</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span>    <span class="comment">//打开文件信息</span></span><br><span class="line">   <span class="type">spinlock_t</span> sigmask_lock;   <span class="comment">//信号处理函数</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">sig</span>;</span>   <span class="comment">//信号处理函数</span></span><br><span class="line">   <span class="type">sigset_t</span> blocked;                <span class="comment">//进程当前要阻塞的信号，每个信号对应一位</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> <span class="title">pending</span>;</span>      <span class="comment">//进程上是否有待处理的信号</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> sas_ss_sp;</span><br><span class="line">   <span class="type">size_t</span> sas_ss_size;</span><br><span class="line">   <span class="type">int</span> (*notifier)(<span class="type">void</span> *priv);</span><br><span class="line">   <span class="type">void</span> *notifier_data;</span><br><span class="line">   <span class="type">sigset_t</span> *notifier_mask;</span><br><span class="line">   u32 parent_exec_id;</span><br><span class="line">   u32 self_exec_id;</span><br><span class="line"> </span><br><span class="line">   <span class="type">spinlock_t</span> alloc_lock;</span><br><span class="line">   <span class="type">void</span> *journal_info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="状态队列"><a href="#状态队列" class="headerlink" title="状态队列"></a>状态队列</h2><p>多任务调度会使进程占有的系统资源状态发生变化：</p>
<table>
<thead>
<tr>
<th>状态3&#x2F;5&#x2F;7</th>
<th>cpu</th>
<th>虚拟内存</th>
<th>外存中是否由虚拟内存静态映像</th>
<th>使用到的设备</th>
</tr>
</thead>
<tbody><tr>
<td>运行态（<em>Running</em>）</td>
<td>1</td>
<td>1</td>
<td></td>
<td>占有</td>
</tr>
<tr>
<td>阻塞态（<em>Blocked</em>）</td>
<td>0</td>
<td>1</td>
<td></td>
<td>等待设备空闲才进入阻塞</td>
</tr>
<tr>
<td>就绪态（<em>Ready</em>）：随时可上cpu</td>
<td>0</td>
<td>1</td>
<td></td>
<td>设备空闲；内存已载入.text;相关数据结果创建完毕</td>
</tr>
<tr>
<td>创建态（<em>new</em>）</td>
<td>0</td>
<td>1&#x2F;0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>结束态（<em>Exit</em>）</td>
<td>1</td>
<td>1&#x2F;0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>阻塞挂起态：挂起前阻塞</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>就绪挂起态：挂起前就绪；进入内存可即刻运行</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td></td>
</tr>
</tbody></table>
<p>状态变迁：<br><em>NULL -&gt; 创建态</em>：<br><em>创建态 -&gt; 就绪态</em>：PCB创建完成并初始化后，一切就绪准备运行时，进入就绪队列<br><em>就绪态 -&gt; 运行态</em>：被os进程调度器选中，分配给 CPU 运行该进程；<br><em>运行态 -&gt; 结束态</em>：进程运行完&#x2F;出错&#x2F;exit系统调用;<br><em>运行态 -&gt; 就绪态</em>：分配的时间片用完，进入就绪队列，并从就绪队列选中另外一个进程运行；<br><em>运行态 -&gt; 阻塞态</em>：当某些资源正被其他进程占用，导致相关指令无法继续执行，进入阻塞队列等待；<br><em>阻塞态 -&gt; 就绪态</em>：等待事件完成时（请求的系统资源空闲时），从阻塞态变到就绪态；</p>
<p><em>阻塞态 -&gt; 挂起态</em>：大量阻塞态进程占用内存，导致浪费或sleep定时器系统调用&#x2F;ctrl+Z&#x20;<br><em>就绪态 -&gt; 挂起态</em>：大量<em>就绪态</em>进程占用内存<br>挂起态 <em>-&gt; 就绪态</em>：</p>
<p>进程状态被登记在PCB;且有7个状态队列跟踪并维护进程状态；<br>一般都为链表实现的队列：方便插入，删除<br>阻塞&#x2F;就绪队头指针→PCB1→PCB2→……<br>运行态PCB只需要一个指针管理</p>
<p><img src="/image/image_6-DOGlyRJC.png"></p>
<p><img src="/image/image_8cYzsyN6WX.png"></p>
<h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h1><p>任务的创建，切换，终止基于cpu调度、分配资源、进程间通信，原子操作等机制，以及需要维护进程相关数据结构。</p>
<p><a href="cpu%E8%B0%83%E5%BA%A6/cpu%E8%B0%83%E5%BA%A6.md" title="cpu调度">cpu调度</a></p>
<p><a href="%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1.md" title="进程通信">进程通信</a></p>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a><strong>创建</strong></h2><p>操作系统允许一个进程创建另一个进程，而且允许子进程继承父进程所拥有的资源。<br>1）创建PCB<br>2）为该进程分配运行时所必需资源<br>3）将 PCB 插入就绪队列</p>
<h2 id="终止"><a href="#终止" class="headerlink" title="终止"></a><strong>终止</strong></h2><p>进程的 3 种终止方式：正常结束、异常结束以及外界干预（信号 <code>kill</code> 掉）；<br>当子进程被终止时，其在父进程处继承的资源应当还给父进程。当父进程被终止时，该父进程的子进程就变为孤儿进程，会被 1 号进程收养，并由 1 号进程对它们完成状态收集工作。<br>1）查找进程 PCB,获得状态等信息；<br>2）若处于运行态，则立即终止，将 CPU 资源分配给其他进程；<br>3）若有子进程，则将子进程交给 1 号进程接管；<br>4）将系统资源都归还<br>5）将其从 PCB 所在队列中删除；</p>
<p>僵尸进程：进程终止时会关闭所有文件描述符，释放用户空间内存，但仍保留其PCB。内核保存了终止态和终止信号信息。父进程可调用wait&#x2F;waitpid获取这些信息，然后彻底清除掉这个进程。若父进程未对已终止的子进程进行清理，称为僵尸进程。正常情况下，僵尸进程会立刻被父进程清理；</p>
<p>进程退出状态可在Shell中用特殊变量<code>$?</code>查看，因为Shell是它的父进程，当它终止时Shell调用<code>wait</code>或<code>waitpid</code>得到它的退出状态同时彻底清除掉这个进程</p>
<h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a><strong>阻塞</strong></h2><p>当进程需要等待某一事件完成时，它可以调用阻塞语句把自己阻塞等待。而一旦被阻塞等待，它只能由另一个进程唤醒。<br>1）找到要阻塞进程UID对应的 PCB；<br>2）若为运行态，将现场信息暂存进PCB;然后将 CPU 资源分配给其他进程<br>3）将PCB 插入阻塞队列；</p>
<h2 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a><strong>唤醒</strong></h2><p>若某进程正在等待 I&#x2F;O 事件，需由别的进程发消息给它，则只有当该进程所期待的事件出现时，才由发现者进程用唤醒语句叫醒它。<br>1）在该事件的阻塞队列中找到相应进程的 PCB；<br>2）将其从阻塞队列中移出到就绪队列</p>
<h2 id="进程控制posix"><a href="#进程控制posix" class="headerlink" title="进程控制posix"></a>进程控制posix</h2><h3 id="fork-vfork"><a href="#fork-vfork" class="headerlink" title="fork&#x2F;vfork"></a>fork&#x2F;vfork</h3><p><img src="/image/image_rQkCd8oIqE.png"></p>
<p><img src="/image/image_MijhoSMrGy.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//创建一个子进程(除了少量数据，比如pid不一样，其他与原来进程一样)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">父进程调用fork创建一个子进程。子进程除了少量数据（eg:pid），可说是父进程的副本。</span></span><br><span class="line"><span class="comment">1）接来若父进程被调度执行：则父进程从fork函数返回并获取子进程的ID作为返回值；pid&gt;0</span></span><br><span class="line"><span class="comment">2)若子进程被调度执行，则子进程从fork函数返回并得到0作为返回值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">@RET:cpu调度父进程，fork返回子进程pid&gt;<span class="number">0</span>;cpu调度子进程，fork返回<span class="number">0</span>；发生错误返回负值，并设置errno:</span><br><span class="line"><span class="number">1</span>）当前进程数已达系统规定上限，这时errno的值被设置为EAGAIN。</span><br><span class="line"><span class="number">2</span>）系统内存不足，这时errno的值被设置为ENOMEM</span><br><span class="line"></span><br><span class="line">eg：</span><br><span class="line">    <span class="type">pid_t</span> pid;         <span class="comment">//fork函数返回值</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)&#123;       <span class="comment">//fork失败</span></span><br><span class="line">        perror(<span class="string">&quot;fork failed&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;      </span><br><span class="line">        <span class="comment">//子进程执行逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//父进程执行逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">eg:循环创建<span class="number">2</span>^n个进程，最初只有一个进程，每经历一次循环进程数*<span class="number">2</span>；n次循环会产生<span class="number">2</span>^n个进程</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调度子进程时执行的逻辑</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">//调度父进程时执行的逻辑</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ----------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> vfork(<span class="type">void</span>);</span><br><span class="line"><span class="comment">/*vfork()不会创建并复制父进程的地址空间，而是和父进程共享</span></span><br><span class="line"><span class="comment">vfork()会阻塞父进程，只运行子进程运行</span></span><br><span class="line"><span class="comment">当子进程调用exec()或_exit()时，内核返回地址空间给父进程并唤醒它*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="exec"><a href="#exec" class="headerlink" title="exec~"></a>exec~</h3><p><img src="/image/image_AGgsufEUgw.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//系统调用execve（）替换当前进程的代码段，替换者为一个指定的程序，其参数包括路径、参数列表（argv）以及环境变量（envp）；只有execve是内核中的系统调用，其他5个都是调用execve的库函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接口差异体现在exec的后缀上;l表示命令行参数列表、p表示PATH环境变量、v表示使用参数数组、e使用环境变量数组</span></span><br><span class="line">(a）待执行程序：由文件名(filename）/由路径名（pathname）指定;</span><br><span class="line">(b）参数列表：一一列出/用一个指针数组引用;</span><br><span class="line">(c）把调用进程的环境传递给新程序/还是给新程序指定新的环境</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> execl(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/* (char  *) NULL */</span>);</span><br><span class="line"><span class="type">int</span> execlp(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...<span class="comment">/* (char  *) NULL */</span>);</span><br><span class="line"><span class="type">int</span> execle(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">const</span> <span class="type">char</span> *arg, ...</span><br><span class="line">               <span class="comment">/*, (char *) NULL, char * const envp[] */</span>);</span><br><span class="line"><span class="type">int</span> execv(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">char</span> *<span class="type">const</span> argv[]);</span><br><span class="line"><span class="type">int</span> execvp(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[]);</span><br><span class="line"><span class="type">int</span> execvpe(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[],<span class="type">char</span> *<span class="type">const</span> envp[]);</span><br><span class="line"></span><br><span class="line">@RET:execl成功调用后进程代码段被替换，自然接下来的代码就不会再执行，且无返回值；调用失败后返回<span class="number">-1</span>并设置errno值：</span><br><span class="line"><span class="number">1.</span> 找不到文件或者路径，此时errno为ENOENT。</span><br><span class="line"><span class="number">2.</span> 数组argv和envp(环境变量数组)没有以<span class="literal">NULL</span>结尾，此时errno为EFAULT。</span><br><span class="line"><span class="number">3.</span> 没有对应可执行文件的运行权限，此时errno为EACCES。</span><br><span class="line"><span class="comment">//由于只有错误返回值，只要返回了一定是出错了，直接在后面调用perror即可</span></span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">    execl(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">char</span> *argv[] = &#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    execv(<span class="string">&quot;/bin/ls&quot;</span>, argv);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用exec后，原来打开的文件描述符仍然是打开的[37]。利用这一点可以实现I/O重定向    </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="wait-waitpid-exit"><a href="#wait-waitpid-exit" class="headerlink" title="wait&#x2F;waitpid&#x2F;exit"></a>wait&#x2F;waitpid&#x2F;exit</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/*写一个僵尸进程：若父进程终止，子进程还存在（仍在运行或已是僵尸进程），则这些子进程的父进程改为init进程。init是系统中的一个特殊进程，通常程序文件是/sbin/init，进程id是1；</span></span><br><span class="line"><span class="comment">在系统启动时负责启动各种系统服务，之后就负责清理子进程，只要有子进程终止，init就会调用wait函数清理它*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pid_t</span> pid=fork();</span><br><span class="line">  <span class="keyword">if</span>(pid&lt;<span class="number">0</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(pid&gt;<span class="number">0</span>) &#123; <span class="comment">/* parent */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* child */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ps命令显示僵尸进程的状态为Z，在命令行一栏还显示&lt;defunct&gt;</span></span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="comment">//获取进程终止信息，并彻底彻底清除此进程</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br><span class="line">----------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>;</span><br><span class="line"></span><br><span class="line">@status:传出子进程的终止信息；不关心可设为null</span><br><span class="line">@options:options参数指定WNOHANG可使父进程不阻塞而立即返回<span class="number">0</span></span><br><span class="line">@pid:wait等待第一个终止的子进程，而waitpid可以通过pid参数指定等待哪一个子进程</span><br><span class="line">@ret:</span><br><span class="line"><span class="number">1</span>)（子进程已终止，正等待父进程读取其终止信息）:子进程终止信息写入status并立即返回,且返回清理掉的子进程id。</span><br><span class="line"><span class="number">2</span>)（子进程都还在运行）                    :父进程阻塞等待子进程终止;起到进程间同步的作用</span><br><span class="line"><span class="number">3</span>)（eg:没有任何子进程）                   :出错立即返回<span class="number">-1</span>并设置errno:</span><br><span class="line">ECHILD  没有子进程</span><br><span class="line">EINTER  收到中断信号signal，立即返回</span><br><span class="line"></span><br><span class="line">终止信息宏：        缩写              描述</span><br><span class="line">WIFEXITED  wait <span class="keyword">if</span> exited  子进程正常退出时返回真值</span><br><span class="line">WEXITSTATUS  wait <span class="built_in">exit</span> status  当上面宏为真时，返回子进程正常退出时状态</span><br><span class="line">WIFSIGNALED  wait <span class="keyword">if</span> signaled  子进程由于信号导致终止，返回真值</span><br><span class="line">WTERMSIG  wait <span class="built_in">terminate</span> signal  当上面宏为真时，返回终止子进程的信号类型</span><br><span class="line">WIFSTOPPED  wait <span class="keyword">if</span> stopped</span><br><span class="line">WSTOPSIG  wait stop signal</span><br><span class="line">WIFCONTINUED  wait <span class="keyword">if</span> continued</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="线程机制"><a href="#线程机制" class="headerlink" title="线程机制"></a>线程机制</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">export <span class="type">void</span> <span class="title function_">thread1</span><span class="params">()</span>&#123;<span class="comment">//线程1的函数</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      print(<span class="string">&quot;I&#x27;m thread 1&quot;</span>);</span><br><span class="line">      sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="type">void</span> <span class="title function_">thread2</span><span class="params">()</span>&#123;<span class="comment">//线程2的函数</span></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      print(<span class="string">&quot;I&#x27;m thread 2&quot;</span>);</span><br><span class="line">      sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主线程</span></span><br><span class="line">export <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  CreateThread(<span class="string">&quot;thread1&quot;</span>);<span class="comment">//开始线程1</span></span><br><span class="line">  CreateThread(<span class="string">&quot;thread2&quot;</span>);<span class="comment">//开始线程2</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) sleep(<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://picx.zhimg.com/50/v2-c66e1ed28e6a703f1e85fb486beec4c9_720w.webp?source=1def8aca"></p>
<p><img src="/image/image_auTBkz7OIf.png"></p>
<p><img src="/image/image__qlpsuNRec.png"></p>
<p>多线程并发的过程：在并发的过程间来回切换执行；因为计算机执行速度很快,所以最终看起来,这些并发过程就像同时运行一样；这个机制（线程调度器）实现需要：<br>1）执行流（并发的过程）间来回跳转执行时，cpu的调度机制：时间片轮询，且只需现场保护私有的栈段及寄存器资源</p>
<p>2）并发过程的实例（线程）共享进程资源（其实就是共享上下文降低cpu调度切换上下文的开销）；但并发过程产生的中间数据不一样，需独立栈段及寄存器资源</p>
<p>3）需要某种数据结构维护用户注册的线程信息<strong>TCB</strong>：线程描述信息；断点线程暂存信息；时间片大小（每个来回切换执行多少指令）</p>
<p>4）线程阻塞调度机制：用户线程并发时任一线程调用阻塞syscall，则内核会认为是进程调用的从而让进程进入阻塞态；解决方案：<br>1.<em><strong>jacketing</strong></em>避免进程出现阻塞态：线程调用阻塞syscall时<em>检查 I&#x2F;O 设备是否忙，若忙不执行 I&#x2F;O 操作，转而调度其他线程，避免因等待 I&#x2F;O 设备造成进程阻塞</em><br>2.让调度器拥有调度线程的能力：则TCB要在内核空间中维护(为减少cpu变态频率线程私有数据也在内核空间维护)，线程控制操作也变成syscall；所以内核级线程有cpu变态开销</p>
<p>实现上述机制的线程模型：<br>1）运行于用户态的线程管理库实现；其优势是：无需用户态与内核态的切换，所以速度特别快；缺点：若一个线程阻塞，内核机制会让整个进程阻塞；时间片是在进程时间片的基础上再分的，故时间片较小；因完全运行在用户态，一个线程占据 CPU 使用权时，所在进程的其他线程无法打断当前运行线程；不支持线程并行；</p>
<p>2）运行于内核态的内核函数实现：TCB存储于内核空间，优点：线程阻塞不会令其余线程也阻塞；更大的时间片；支撑线程并行；缺点：并发操作由系统调用实现，cpu变态开销大</p>
<p>3）<strong>轻量级进程（</strong><em><strong>LightWeight Process</strong></em><strong>）</strong>：<strong>LWP存储</strong>执行流跳转时的现场信息，及调度所需信息；能共享进程虚拟地址空间；被一个内核线程管理；实现了在进程内进行用户态线程调度；线程阻塞及进程外线程调度和线程并行由内核线程调度器完成</p>
<p>原子操作，通信，锁</p>
<p><img src="/image/image_QTyH_maHC7.png"></p>
<h2 id="线程同步互斥"><a href="#线程同步互斥" class="headerlink" title="线程同步互斥"></a>线程同步互斥</h2><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><h1 id="并行-并发编程"><a href="#并行-并发编程" class="headerlink" title="并行&#x2F;并发编程"></a>并行&#x2F;并发编程</h1><p><a href="%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%82%E6%AD%A5/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%82%E6%AD%A5.md" title="多线程异步">多线程异步</a></p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>C</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/C/</url>
    <content><![CDATA[<p>驱动层，系统层，中间件</p>
<h1 id="C编译器定义的元结构"><a href="#C编译器定义的元结构" class="headerlink" title="C编译器定义的元结构"></a>C编译器定义的元结构</h1><p><strong>场域</strong>（c编译器定义的<strong>基本数据类型</strong>与数据结构构成场域）：占用字节取决于编译器和操作系统环境</p>
<p>空型：void</p>
<p>字符：(<em>unsigned)</em> char</p>
<p>整型：(<em>unsigned)</em> short , int  , long , long long</p>
<p>实型：float,double，long double（4，8，16B）（7 ，15，30位有效数字）</p>
<p>指针：任意类型+ <em>(void</em>,int**等;数组指针<strong>int (*p)[]</strong>  ，函数指针int (*p)(int,int))</p>
<p>布尔型：_Bool（为兼容C++使用stdbool）</p>
<p><strong>运算</strong>：</p>
<p>算术运算：+ ， -  ，*  ，&#x2F;  ，%(取余，模运算) ，++  , - -<br>##浮点数运算可能有四舍五入的误差?<br>比较运算：&gt;，&lt; ，&#x3D;&#x3D; ，!&#x3D;，&gt;&#x3D; ，&lt;&#x3D;<br>逻辑运算：&amp;&amp;  ，||  ，! &#x20;<br>位运算：&amp;，|，^，~，&gt;&gt;，&lt;&lt;<br>地址运算：&amp;变量（取地址）， *指针（返回指针指向的变量），[ ]（数组下指针访问成员运算符），·（结构体变量访问成员），- &gt;(结构体指针访问成员)</p>
<p>特殊运算：()（更改表达式运算顺序）， （类型）强制类型转换，  sizeof（类型）（取类型占用字节数）<br>逗号运算符：，（以逗号分隔列表最后一个表达式的值作为整个逗号表达式的值；用于链式？）<br>条件运算： ？：</p>
<p>语法糖：<br>算术复合： +&#x3D; ，-&#x3D; ， *&#x3D;， &#x2F;&#x3D; ，%&#x3D;<br>位运算复合：&amp;&#x3D;， |&#x3D;，^&#x3D;，~&#x3D;，&gt;&gt;&#x3D;，&lt;&lt;&#x3D;</p>
<p><strong>运算公理：</strong></p>
<p>1）隐式类型转换：两种不同类型进行运算时，由编译器进行类型对齐；占用内存字节小的类型→占用字节大的类型，以保证精度不降低</p>
<p><a href="2%EF%BC%89%E8%BF%90%E7%AE%97%E4%BC%98%E5%85%88%E7%BA%A7/2%EF%BC%89%E8%BF%90%E7%AE%97%E4%BC%98%E5%85%88%E7%BA%A7.md" title="2）运算优先级">2）运算优先级</a></p>
<p>3）常量表示：<br>十进制  1<br>八进制  01<br>十六进制  0x1<br>二进制(C23) 0b1<br>字符：‘1’(对应数字由字符编码表决定ex:ascii)<br>字符串：“1”；自动补‘\0’<br>空指针：NULL<br>float:3.12f;     3.12e3f  &#x2F;&#x2F;3.12*1000<br>double:3.12;     312E-3 &#x2F;&#x2F;312*0.001</p>
<p>4）指针+-法：指针(int *) p+-1相当于地址+-4,指向下一个4字节内存<br>5）<strong>嵌入汇编</strong>：意味着包含汇编的元结构；（应用场景：无C运行环境ex:boot，低延时编程，操作寄存器）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">;code</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="代码流程控制"><a href="#代码流程控制" class="headerlink" title="代码流程控制"></a>代码流程控制</h1><p>顺序，选择，循环结构</p>
<p>选择（分支）结构：</p>
<p>1)if</p>
<p><img src="/image/image_yHLUKaBcLy.png"></p>
<p>2)if…else</p>
<p><img src="/image/image_GR54Ez2zwo.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">条件运算：a?b:c----------------思维上我把它当作以下的语法糖</span><br><span class="line"><span class="keyword">auto</span> <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(a)</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3)if…else if…else</p>
<p><img src="/image/image_-I5JrhG73D.png"></p>
<p>4)switch</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123; </span><br><span class="line"><span class="keyword">case</span> 常量表达式: 语句序列;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> 常量表达式: 语句序列;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: 语句序列;&#125;</span><br></pre></td></tr></table></figure>

<p>循环结构：</p>
<p>1）while</p>
<p>2)do…while</p>
<p>while的语法糖：for</p>
<p>跳转</p>
<p>1)break：跳出本层循环</p>
<p>2)continue：立即执行下次循环</p>
<p>3)goto:跳出多层嵌套循环，跳至错误处理代码</p>
<h1 id="C编译器支持的用户自定义元结构"><a href="#C编译器支持的用户自定义元结构" class="headerlink" title="C编译器支持的用户自定义元结构"></a>C编译器支持的<strong>用户自定义元结构</strong></h1><p>场域：</p>
<p><strong>数组：</strong><br>一维数组：auto nam[x]可类比数域auto上的x元有序对(nam0,…namx-1)；其成员类型相同，内存连续，地址连续<br>多位数组：auto nam[x][y]…可类比为数域auto上的x*y*…..矩阵<br>字符串：特殊的字符数组,其最后一个成员是’\0’（与0等价）</p>
<p><strong>结构体</strong>：struct nam{int a;char b;…}类比n元有序对（a,b…）但每个所属数域不统一；C标准未规定内存连续；但大多编译器都是规定内存连续的</p>
<p><img src="/image/image_ceDhZ1npYN.png"></p>
<p>可声明结构体再定义结构体变量；或声明结构体同时定义结构体变量</p>
<p><strong>共用（联合）体</strong>：声明，定义与结构体类似；不同处：<br>1）成员 <strong>共用内存空间与地址</strong>，所占内存&#x3D;最大成员内存<br>2）因内存共享，当有成员被赋值，会覆盖其他成员值。即<strong>同一时刻联合体中只能保有一个非静态成员的值</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">MyUnion</span> &#123;</span></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> y;</span><br><span class="line">&#125; x;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>枚举体</strong>：唯一成员类型为整型（取决于枚举值数量可能是int,…long long）；枚举变量限定赋值范围</p>
<p>默认初始化值&#x3D;第一个枚举值；或默认0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">weekday</span>&#123;</span></span><br><span class="line">    sun = <span class="number">2</span>, mon, tue, wed, thu, fri, sat</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">weekday</span> <span class="title">a</span>, <span class="title">b</span>, <span class="title">c</span>;</span></span><br><span class="line">a = sun;</span><br><span class="line">b = mon;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>类型取别名：typedef</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INT;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">type</span>&#123;</span><span class="comment">//声明结构体同时取别名确实迷惑</span></span><br><span class="line">    UBYTE a;</span><br><span class="line">    INT b;</span><br><span class="line">    T_BYTE c;</span><br><span class="line">&#125;TYPE, *PTYPE;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>函数：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">返回类型 函数名(类型 形参名<span class="number">1</span>，类型 形参名<span class="number">2</span>，。。。)&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数名&#x3D;运算符<br>形参声明列表&#x3D;输入<br>返回值&#x3D;输出<br>函数体&#x3D;封装实现<br>函数调用：<br>1）给形参分配栈区内存。调用结束内存被释放<br>2.a）值传递：形参&#x3D;实参；将实参值复制给形参；形参在{}的变化不影响实参<br>2.b)地址传递：形参 <em>&#x3D;实参</em>；双向传递<br>3）参数不匹配有可能发生隐式转换<br>4）函数运行时栈帧：</p>
<p><img src="/image/image_GpTKHjPXCa.png"></p>
<p>1.返回地址（Return Address）：父函数中下条要执行指令的地址<br>2.局部变量（Local Variables）<br>3.上一个函数栈帧的指针（Previous Frame Pointer）：指向父函数的栈帧。通过这个指针，可在函数调用链中回溯到上一个函数的栈帧。<br>4.返回值（Return Value）：这个值将被传递给调用该函数的地方。<br>5.参数（Arguments）：存储调用函数时传递的参数值。参数是用于将数据传递给函数的值或引用。<br>以下信息因编程语言、操作系统和编译器而异<br>6.异常处理信息：可以包含异常处理信息，如异常处理程序的地址或指针，用于跳转到恰当的异常处理代码<br>7.寄存器保存：寄存器常被用于存储临时变量、计算结果和函数调用过程中的一些状态；且是共享资源；所以要暂存寄存器值，用于在函数返回时恢复原来寄存器状态</p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p><strong>内存数值存储方式？</strong></p>
<p><strong>声明</strong>：告知编译器&#x2F;解释器 变量存在(C编译器历史包袱)，<strong>为声明变量预留空间，但不分配内存</strong>1）类型声明：比如无成员列表的结构体声明<br>2）函数声明，且无函数体<br>3）extern关键字声明外部链接&#x2F;调用后边定义的变量，且无初始化定义<br><strong>定义：</strong> 告知变量存在，为定义变量预留空间，且分配内存；<strong>C变量声明全是定义</strong><br>ex:<br>char a &#x3D; <code>&#39;ABC&#39;</code><br>1)在内存中创建常量<code>&#39;ABC&#39;</code>；<br>2)在内存中创建了一个名为<code>a</code>的变量，并把它指向<code>&#39;ABC&#39;</code>；</p>
<table>
<thead>
<tr>
<th>限定符</th>
<th>作用域（使用范围）</th>
<th>生命周期（内存存在时间）</th>
<th>内存属性变化（存储位置&#x2F;权限&#x2F;存取方式）</th>
</tr>
</thead>
<tbody><tr>
<td>auto局部定义</td>
<td>定义的函数{}内</td>
<td>运行到变量定义时分配内存，跳出定义的函数{}释放</td>
<td>运行阶段存放于堆栈区</td>
</tr>
<tr>
<td>static 局部定义</td>
<td>限定定义的函数{}内</td>
<td>整个程序进程</td>
<td>编译后存于Data区，不能用变量初始化，若不初始化，默认&#x3D;0；</td>
</tr>
<tr>
<td>全局定义</td>
<td>所有文件，前提是声明extern</td>
<td>整个程序进程</td>
<td>编译后存于Data区，不能用变量初始化，若不初始化，默认&#x3D;0；</td>
</tr>
<tr>
<td>static 全局定义</td>
<td>限定只能当前文件内使用</td>
<td>整个程序进程</td>
<td>编译后存于Data区，不能用变量初始化，若不初始化，默认&#x3D;0；</td>
</tr>
<tr>
<td>register</td>
<td>定义的函数{}内</td>
<td>当前函数{}内</td>
<td>建议型指令，分配寄存器为变量内存，提高效率；但无法获取地址，若无空闲寄存器则无效</td>
</tr>
<tr>
<td>const</td>
<td></td>
<td></td>
<td>变量的内存值不可修改；const auto* nam const；* 前修饰指向的变量是常量；*后指地址是常量</td>
</tr>
<tr>
<td>volatile</td>
<td></td>
<td></td>
<td>每次使用时，直接从该变量内存读取；因为此变量在本程序不修改情况下也会变化</td>
</tr>
<tr>
<td>restrict（C99）</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>初始化：定义变量后，所分配内存的值是随机的；此时便要初始化这块空间，增加程序安全性，确定性</p>
<p><strong>C程序和数据在内存中的组织形式（内存5区）</strong></p>
<p><img src="/image/image_ZMXafRee3O.png"></p>
<p><img src="/image/image_B-8bZTXwA-.png"></p>
<p><strong>编译后代码&#x2F;静态段就存在，可见静态区变量在程序被加载到内存时就存在，堆栈区变量的内存是在运行时临时分配，用完释放****Code Segment（代码区）</strong><br>也称Text Segment，存放可执行程序机器码；只读，原因是防止程序意外修改指令。另外，代码区还规划了局部变量相关信息<br><strong>Data Segment (数据段）</strong><br>存放已初始化全局&#x2F;静态定义变量， 常量数据（如字符串常量,只读）。<br>**BSS（Block started by symbol)**存放0初始化的全局&#x2F;静态定义变量<br><strong>Heap（堆）</strong> 低地址向高地址增长。容量&gt;栈，动态分配内存在此区域；若程序员不释放，程序结束时由操作系统回收<br><strong>Stack（栈）</strong> 高地址向低地址增长。由编译器自动管理分配。局部变量、函数参数值、返回变量等存在此区域</p>
<p>内存操作<br>存储地址空间：<br>统一编址（？架构）：每字节内存对应一个地址（ 是32 &#x2F;64 位与处理器相关）；寄存器无地址</p>
<p>野指针：指针未初始化存着随机值；这个值指向的内存或许是危险的区域或只读区，但编译时不报错<br>空指针：NULL 是一个值为 0 的宏常量：#define NULL ((void <em>)0)<br>空型&#x2F;通用&#x2F;万能指针void</em>:所有指针位数一样，<strong>类型信息表示地址能指向几位内存</strong>；void<em>能接收所有类型指针（作形参好用）；指向具体变量时要强制类型转换<br>多级指针：int**指向int</em>或int* nam[]<br>char*：指向字符或字符串；char *[]的成员可以指向字符；字符串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>;</span><br><span class="line">main 函数是操作系统调用的，第一个参数标明 argv 数组的字符成员数量，argv</span><br><span class="line">数组的每个成员都是 <span class="type">char</span> *类型</span><br><span class="line">argv 是命令行参数的字符串数组</span><br><span class="line">argc 代表命令行参数的数量，程序名字本身算一个参数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span>  <span class="type">int</span>* p  <span class="type">const</span>  =<span class="literal">NULL</span>;<span class="comment">//在*左边表示指向内存*p只读，在*右边表示地址p只读</span></span><br><span class="line">数组名作为数组首地址是只读的指针</span><br></pre></td></tr></table></figure>

<h1 id="Unix系统调用"><a href="#Unix系统调用" class="headerlink" title="Unix系统调用"></a>Unix系统调用</h1><p>exit();用于在函数内直接中断程序进程；而非return返回父函数</p>
<p>常用的即文件系统调用</p>
<h1 id="C库"><a href="#C库" class="headerlink" title="C库"></a>C库</h1><p><a href="https://www.w3schools.cn/c/c_standard_library.html" title="C 标准库 - 参考手册 在本教程中，您将学习如何使用C标准库-参考手册,C语言是一种通用的、面向过程式的计算机程序设计语言。1972年，为了移植与开发UNIX操作系统，丹尼斯·里奇在贝尔电话实验室设计开发了C语言。 https://www.w3schools.cn/c/c_standard_library.html">C 标准库 - 参考手册 在本教程中，您将学习如何使用C标准库-参考手册,C语言是一种通用的、面向过程式的计算机程序设计语言。1972年，为了移植与开发UNIX操作系统，丹尼斯·里奇在贝尔电话实验室设计开发了C语言。 https://www.w3schools.cn/c/c_standard_library.html</a></p>
<p><a href="%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86.md" title="字符串处理">字符串处理</a></p>
<p><a href="%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C/%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C.md" title="内存操作">内存操作</a></p>
<p><a href="%E5%9B%BD%E9%99%85%E5%8C%96/%E5%9B%BD%E9%99%85%E5%8C%96.md" title="国际化">国际化</a></p>
<p><a href="%E8%B0%83%E8%AF%95%EF%BC%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%8C%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AE%B9/%E8%B0%83%E8%AF%95%EF%BC%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%8C%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AE%B9.md" title="调试，错误处理，查看内容">调试，错误处理，查看内容</a></p>
<p><a href="%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97/%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97.md" title="数学计算">数学计算</a></p>
<p><a href="%E6%97%B6%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/%E6%97%B6%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4.md" title="时期和时间">时期和时间</a></p>
<p><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md" title="数据类型">数据类型</a></p>
<h1 id="C模型建立"><a href="#C模型建立" class="headerlink" title="C模型建立"></a>C模型建立</h1><h1 id="C设计模式"><a href="#C设计模式" class="headerlink" title="C设计模式"></a>C设计模式</h1><h1 id="分析，调试，查看内容"><a href="#分析，调试，查看内容" class="headerlink" title="分析，调试，查看内容"></a>分析，调试，查看内容</h1><h1 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h1><p><img src="/image/image_BOa146grFE.png"></p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="预编译，C程序结构"><a href="#预编译，C程序结构" class="headerlink" title="预编译，C程序结构"></a>预编译，C程序结构</h1><p>分文件（模块）编程<br>1）函数实现在 x.c 中；<br>2）函数声明放在同名x .h 中(且要包含x.c所使用头文件)，在主函数中包含头文件<br>防止头文件重复包含：<br>方法一：<br>#ifndefX**_H**<br>#define X**_H**<br>&#x2F;&#x2F; 声明语句<br>#endif<br>方法二：<br>#pragma once<br>&#x2F;&#x2F; 声明语句</p>
<p>.h头文件路径(声明信息)<br>#include &lt;&gt;&#x2F;&#x2F;在编译器的include子目录<br>#include “”&#x2F;&#x2F;当前目录<br>编译时用 -I &lt;&gt;指定目录</p>
<p>.c库函数路径(实现信息)<br>默认在编译器lib路径查找<br>编译时用-L &lt;&gt;指定目录-lname指定共享目标库文件name.so</p>
<h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1><p><a href="%E6%96%B0%E9%A1%B5%E9%9D%A2/%E6%96%B0%E9%A1%B5%E9%9D%A2.md" title="新页面">新页面</a></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/C++/</url>
    <content><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1>]]></content>
  </entry>
  <entry>
    <title>python</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/python/</url>
    <content><![CDATA[<p>解释性：<br>编译性语言如C&#x2F;C++写的程序需要通过编译器将源代码转换成计算机能够理解的二进制代码，然后使用连接&#x2F;转载器软件将程序从硬盘复制到内存中并执行。而Python程序直接从源代码运行，Python解释器会将源代码转换成字节码中间形式，再翻译成计算机可以运行的机器语言。由于不再担心如何编译程序，如何确保连接转载正确的库等等，这使得Python更简单易用，并且更容易移植到其他计算机上（直接copy源码）。<br>可扩展性:<br>如果你需要你的一段关键代码运行得更快或者希望某些算法不公开，你可以把你的部分程序用C或C++编写，然后在你的Python程序中使用它们。<br>可嵌入性:<br>你可以把Python嵌入你的C&#x2F;C++程序，从而向你的程序用户提供脚本功能。<br>丰富的库:<br>Python标准库非常庞大，可以处理各种工作，包括正则表达式、文档生成、单元测试、线程、数据库、网页浏览器、CGI、FTP、电子邮件、XML、XML-RPC、HTML、WAV文件、密码系统、GUI等。只要安装了Python，所有这些功能都是可用的，这被称作Python的“功能齐全”理念。</p>
<p><a href="../C/C.md" title="C">C</a></p>
<p><a href="%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E5%85%83%E7%BB%93%E6%9E%84%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E5%85%83%E7%BB%93%E6%9E%84%EF%BC%89.md" title="数据类型和运算符（元结构）">数据类型和运算符（元结构）</a></p>
<p><a href="%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6.md" title="流程控制">流程控制</a></p>
<p><a href="%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&%E5%87%BD%E6%95%B0/%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&%E5%87%BD%E6%95%B0.md" title="用户自定义数据类型&amp;函数">用户自定义数据类型&amp;函数</a></p>
<p><a href="%E5%8C%85/%E5%8C%85.md" title="包">包</a></p>
<p><a href="%E6%96%B0%E9%A1%B5%E9%9D%A2/%E6%96%B0%E9%A1%B5%E9%9D%A2.md" title="新页面">新页面</a></p>
<p><a href="%E6%96%B0%E9%A1%B5%E9%9D%A2_1/%E6%96%B0%E9%A1%B5%E9%9D%A2.md" title="新页面">新页面</a></p>
<p><a href="%E6%96%B0%E9%A1%B5%E9%9D%A2_2/%E6%96%B0%E9%A1%B5%E9%9D%A2.md" title="新页面">新页面</a></p>
<p><a href="%E6%96%B0%E9%A1%B5%E9%9D%A2_3/%E6%96%B0%E9%A1%B5%E9%9D%A2.md" title="新页面">新页面</a></p>
<p><a href="%E6%96%B0%E9%A1%B5%E9%9D%A2_4/%E6%96%B0%E9%A1%B5%E9%9D%A2.md" title="新页面">新页面</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编？机器指令</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%EF%BC%9F%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/%E6%B1%87%E7%BC%96%EF%BC%9F%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p><img src="/image/image_VhBbRcRhTg.png"></p>
<p><a href="%E7%BC%96%E7%A0%81/%E7%BC%96%E7%A0%81.md" title="编码">编码</a></p>
]]></content>
      <categories>
        <category>汇编？机器指令</category>
      </categories>
      <tags>
        <tag>汇编？机器指令</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87/%E5%B8%B8%E8%A7%81%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/%E6%96%B0%E9%A1%B5%E9%9D%A2/%E6%96%B0%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="新页面"><a href="#新页面" class="headerlink" title="新页面"></a>新页面</h1>]]></content>
  </entry>
  <entry>
    <title>泊松分布推导</title>
    <url>/2024/02/08/%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87/%E5%B8%B8%E8%A7%81%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83%E6%8E%A8%E5%AF%BC/%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83%E6%8E%A8%E5%AF%BC/</url>
    <content><![CDATA[<p>回顾：</p>
<p><img src="/image/image_oPNtj8-lBN.png"></p>
<p>Taylor展开：在x0处的n阶极限一样</p>
<p>e定义:</p>
<p><img src="https://latex-svg.wikimirror.net/163448ac05b0672de07336945cf8c0e8fbcbf508"></p>
<p>二項分佈的定義：</p>
<p><img src="https://latex-svg.wikimirror.net/94cdf18e27c5641888c81d31d97dd447dbaa72fe"></p>
<p>则poisson分布PMF:</p>
<p><img src="https://latex-svg.wikimirror.net/7f3305a795ed8b2ce32f86487f67b44ecd5f69cb"></p>
<p><img src="/image/image_yw67IUkDZm.png"></p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>hash function</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8hash%20table/hash%20function/hash%20function/</url>
    <content><![CDATA[<p><strong>(hashFunc)使将</strong>关键字key映射到索引（数据value实际存储位置），是O(1)的访问方式<br>实际的应用中，键值可能是更复杂的东西，比如浮点数、字符串、结构体等，这时候就要根据具体情况设计合适的哈希函数。哈希函数应当易于计算，并且尽量使计算出来的索引均匀分布。</p>
<h2 id="常见Hash函数："><a href="#常见Hash函数：" class="headerlink" title="常见Hash函数："></a>常见Hash函数：</h2><p>A.直接定制法</p>
<p>原理：取关键字的线性函数为散列地址：Hash（Key）&#x3D; A*Key + B</p>
<p>优点：简单、均匀 缺点：需事先知道关键字分布情况</p>
<p>使用场景：适合查找比较小且连续的情况</p>
<p>B.除留余数法R→[0,m-1]</p>
<p>原理：设散列表允许地址数为m，取一个不大于m，但最接近或者等于m的质数p作为除数，</p>
<p>按哈希函数：Hash(key) &#x3D; key% p(p&lt;&#x3D;m),将关键码转换成哈希地址</p>
<p>注意: 一般情况下，p最好是一个不超过m的最大素数.（后文介绍为什么)</p>
<p><a href="https://www.zhihu.com/question/20806796" title="Hash时取模一定要模质数吗？ - 知乎 排除人为制造的数据外，对质数取模的优势在哪里呢？ https://www.zhihu.com/question/20806796">Hash时取模一定要模质数吗？ - 知乎 排除人为制造的数据外，对质数取模的优势在哪里呢？ https://www.zhihu.com/question/20806796</a></p>
<p>C.平方取中法</p>
<p>原理：假设关键字为1234，对它平方就是1522756，抽取中间的3位227作为哈希地址</p>
<p>再比如关键字为4321，对它平方就是18671041，抽取中间的3位671(或710)作为哈希地址</p>
<p>场景：平方取中法比较适合：不知道关键字的分布，而位数又不是很大的情况</p>
<p>D.折叠法</p>
<p>原理：折叠法是将关键字从左到右分割成位数相等的几部分(最后一部分位数可以短些)，</p>
<p>然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。</p>
<p>场景：折叠法适合事先不需要知道关键字的分布，适合关键字位数比较多的情况</p>
<h2 id="hash-collision"><a href="#hash-collision" class="headerlink" title="hash collision"></a>hash collision</h2><p><strong>通常情况下哈希函数的输入空间远大于输出空间</strong>，因此理论上哈希冲突是不可避免的。<strong>比如，输入空间为全体整数，输出空间为数组容量大小，则必然有多个整数映射至同一数组索引</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">12836</span> % <span class="number">100</span> = <span class="number">36</span></span><br><span class="line"><span class="number">20336</span> % <span class="number">100</span> = <span class="number">36</span></span><br></pre></td></tr></table></figure>

<p><img src="https://www.hello-algo.com/chapter_hashing/hash_map.assets/hash_collision.png"></p>
<p>容易想到，哈希表容量 越大， <code>key</code> 映射到同一个index的概率就越低，冲突就越少。<br><strong>我们可以通过扩容哈希表来减少哈希冲突</strong>。</p>
<p>扩容前键值对 <code>(136, A)</code> 和 <code>(236, D)</code> 发生冲突，扩容后冲突消失。</p>
<p><img src="https://www.hello-algo.com/chapter_hashing/hash_map.assets/hash_table_reshash.png"></p>
<p>类似于数组扩容，哈希表扩容需将所有键值对从原哈希表迁移至新哈希表，非常耗时。并且由于哈希表容量 <code>capacity</code> 改变，我们需要通过哈希函数来重新计算所有键值对的存储位置，这进一步提高了扩容过程的计算开销。为此，编程语言通常会预留足够大的哈希表容量，防止频繁扩容。</p>
<p>「负载因子 load factor」是哈希表的一个重要概念，其定义为哈希表的元素数量除以bucket数量，用于衡量哈希冲突的严重程度，<strong>也常被作为哈希表扩容的触发条件</strong>。例如在 Java 中，当负载因子超过 0.75 时，系统会将哈希表容量扩展为原先的 2 倍。</p>
<p><strong>解决方法：</strong><br>1）当遇到哈希冲突时就进行哈希表扩容，直至冲突消失为止。此方法有效但效率太低，因为哈希表扩容需要进行大量的数据搬运与哈希值计算<br>2）实际处理方法</p>
<ol>
<li>改良哈希表数据结构，<strong>使得哈希表可以在存在哈希冲突时正常工作</strong>。</li>
<li>仅在必要时，即当哈希冲突比较严重时，才执行扩容操作。</li>
</ol>
<p>哈希表结构改良方法主要包括“链式地址”和“开放寻址”</p>
<h3 id="链式地址"><a href="#链式地址" class="headerlink" title="链式地址"></a>链式地址</h3><p>冲突数据放一个链表里，查询时会根据key查到链表的第一个节点，然后遍历整个链表，找到相应的值。</p>
<p>相同index的bucket*放在一个单链表的value里，各链表的头结点存储在哈希表中。</p>
<p><img src="/image/image_JORN6GPGRv.png"></p>
<ul>
<li><strong>查询元素</strong>：输入 <code>key</code> ，经过哈希函数得到数组索引，即可访问链表头节点，然后遍历链表并对比 <code>key</code> 以查找目标键值对。</li>
<li><strong>添加元素</strong>：先通过哈希函数访问链表头节点，然后将节点（即键值对）添加到链表中。</li>
<li><strong>删除元素</strong>：根据哈希函数的结果访问链表头部，接着遍历链表以查找目标节点，并将其删除。</li>
</ul>
<p>局限性：</p>
<ul>
<li><strong>占用空间增大</strong>，链表包含节点指针，它相比数组更加耗费内存空间。</li>
<li><strong>查询效率降低</strong>：<br>1）<strong>链表不会很长</strong>：插入或查找时，当中存在一个循环，即线性遍历链表，检测data是否存在，表面上时间复杂度O(n)，但实际认为操作时的时间复杂度为O(1)<br>2）当链表很长时：查询效率O(n);很差。<strong>此时可以将链表转换为“AVL 树”或“红黑树”</strong>，从而将查询操作的时间复杂度优化至O(logn)</li>
</ul>
<p>以下代码给出了链式地址哈希表的简单实现，需要注意两点。</p>
<ul>
<li>使用列表（动态数组）代替链表，从而简化代码。在这种设定下，哈希表（数组）包含多个桶，每个桶都是一个列表。</li>
<li>以下实现包含哈希表扩容方法。当负载因子超过 0.75 时，我们将哈希表扩容至 2 倍。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 链式地址哈希表 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashMapChaining</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;                       <span class="comment">// 键值对数量</span></span><br><span class="line">    <span class="type">int</span> capacity;                   <span class="comment">// 哈希表容量</span></span><br><span class="line">    <span class="type">double</span> loadThres;               <span class="comment">// 触发扩容的负载因子阈值</span></span><br><span class="line">    <span class="type">int</span> extendRatio;                <span class="comment">// 扩容倍数</span></span><br><span class="line">    vector&lt;vector&lt;Pair *&gt;&gt; buckets; <span class="comment">// 桶数组</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="built_in">HashMapChaining</span>() : <span class="built_in">size</span>(<span class="number">0</span>), <span class="built_in">capacity</span>(<span class="number">4</span>), <span class="built_in">loadThres</span>(<span class="number">2.0</span> / <span class="number">3</span>), <span class="built_in">extendRatio</span>(<span class="number">2</span>) &#123;</span><br><span class="line">        buckets.<span class="built_in">resize</span>(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 析构方法 */</span></span><br><span class="line">    ~<span class="built_in">HashMapChaining</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;bucket : buckets) &#123;<span class="comment">//bucket冲突表</span></span><br><span class="line">            <span class="keyword">for</span> (Pair *pair : bucket) &#123;</span><br><span class="line">                <span class="comment">// 释放内存</span></span><br><span class="line">                <span class="keyword">delete</span> pair;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 哈希函数 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hashFunc</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 负载因子 */</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">loadFactor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>)size / (<span class="type">double</span>)capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查询操作 */</span></span><br><span class="line">    <span class="function">string <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        <span class="comment">// 遍历桶，若找到 key 则返回对应 val</span></span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : buckets[index]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair-&gt;key == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> pair-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若未找到 key 则返回 nullptr</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, string val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当负载因子超过阈值时，执行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">loadFactor</span>() &gt; loadThres) &#123;</span><br><span class="line">            <span class="built_in">extend</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        <span class="comment">// 遍历桶，若遇到指定 key ，则更新对应 val 并返回</span></span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : buckets[index]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair-&gt;key == key) &#123;</span><br><span class="line">                pair-&gt;val = val;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若无该 key ，则将键值对添加至尾部</span></span><br><span class="line">        buckets[index].<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Pair</span>(key, val));</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        <span class="keyword">auto</span> &amp;bucket = buckets[index];</span><br><span class="line">        <span class="comment">// 遍历桶，从中删除键值对</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucket.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket[i]-&gt;key == key) &#123;</span><br><span class="line">                Pair *tmp = bucket[i];</span><br><span class="line">                bucket.<span class="built_in">erase</span>(bucket.<span class="built_in">begin</span>() + i); <span class="comment">// 从中删除键值对</span></span><br><span class="line">                <span class="keyword">delete</span> tmp;                       <span class="comment">// 释放内存</span></span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 扩容哈希表 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 暂存原哈希表</span></span><br><span class="line">        vector&lt;vector&lt;Pair *&gt;&gt; bucketsTmp = buckets;</span><br><span class="line">        <span class="comment">// 初始化扩容后的新哈希表</span></span><br><span class="line">        capacity *= extendRatio;</span><br><span class="line">        buckets.<span class="built_in">clear</span>();</span><br><span class="line">        buckets.<span class="built_in">resize</span>(capacity);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将键值对从原哈希表搬运至新哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;bucket : bucketsTmp) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Pair *pair : bucket) &#123;</span><br><span class="line">                <span class="built_in">put</span>(pair-&gt;key, pair-&gt;val);</span><br><span class="line">                <span class="comment">// 释放内存</span></span><br><span class="line">                <span class="keyword">delete</span> pair;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印哈希表 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;bucket : buckets) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (Pair *pair : bucket) &#123;</span><br><span class="line">                cout &lt;&lt; pair-&gt;key &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; pair-&gt;val &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;]\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="开放寻址-open-addressing"><a href="#开放寻址-open-addressing" class="headerlink" title="开放寻址 open addressing"></a>开放寻址 open addressing</h3><h4 id="1-线性探测"><a href="#1-线性探测" class="headerlink" title="1.   线性探测"></a>1.   线性探测</h4><p>线性探测采用固定步长的线性搜索来进行探测，其操作方法与普通哈希表有所不同。</p>
<ul>
<li><strong>插入元素</strong>：通过哈希函数计算数组索引，若发现已有元素，从冲突位置向后线性遍历（步长通常为 1 ），直至找到空位，将元素插入其中。</li>
<li><strong>查找元素</strong>：若发现哈希冲突，则使用相同步长向后线性遍历，直到找到对应元素，返回 <code>value</code> 即可；如果遇到空位，说明目标键值对不在哈希表中，返回 None 。</li>
</ul>
<p><img src="https://www.hello-algo.com/chapter_hashing/hash_collision.assets/hash_table_linear_probing.png"></p>
<p>缺陷：</p>
<ul>
<li><strong>不能直接删除元素</strong>。删除元素会在数组内产生一个空位，当查找该空位之后的元素时，该空位可能导致程序误判元素不存在。为此，通常需要借助一个标志位来标记已删除元素。</li>
<li><strong>容易产生聚集</strong>。数组内连续被占用位置越长，这些连续位置发生哈希冲突的可能性越大，进一步促使这一位置的聚堆生长，形成恶性循环，最终导致增删查改操作效率劣化。</li>
</ul>
<p>实现：</p>
<ul>
<li>我们使用一个固定的键值对实例 <code>removed</code> 来标记已删除元素。也就是说，当一个桶内的元素为 None 或 <code>removed</code> 时，说明这个桶是空的，可用于放置键值对。</li>
<li>在线性探测时，我们从当前索引 <code>index</code> 向后遍历；而当越过数组尾部时，需要回到头部继续遍历。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 开放寻址哈希表 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashMapOpenAddressing</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> size;               <span class="comment">// 键值对数量</span></span><br><span class="line">    <span class="type">int</span> capacity;           <span class="comment">// 哈希表容量</span></span><br><span class="line">    <span class="type">double</span> loadThres;       <span class="comment">// 触发扩容的负载因子阈值</span></span><br><span class="line">    <span class="type">int</span> extendRatio;        <span class="comment">// 扩容倍数</span></span><br><span class="line">    vector&lt;Pair *&gt; buckets; <span class="comment">// 桶数组</span></span><br><span class="line">    Pair *removed;          <span class="comment">// 删除标记</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="built_in">HashMapOpenAddressing</span>() &#123;</span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        capacity = <span class="number">4</span>;</span><br><span class="line">        loadThres = <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">        extendRatio = <span class="number">2</span>;</span><br><span class="line">        buckets = <span class="built_in">vector</span>&lt;Pair *&gt;(capacity, <span class="literal">nullptr</span>);</span><br><span class="line">        removed = <span class="keyword">new</span> <span class="built_in">Pair</span>(<span class="number">-1</span>, <span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 哈希函数 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hashFunc</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 负载因子 */</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">loadFactor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(size) / capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 查询操作 */</span></span><br><span class="line">    <span class="function">string <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        <span class="comment">// 线性探测，从 index 开始向后遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">            <span class="comment">// 计算桶索引，越过尾部返回头部</span></span><br><span class="line">            <span class="type">int</span> j = (index + i) % capacity;</span><br><span class="line">            <span class="comment">// 若遇到空桶，说明无此 key ，则返回 nullptr</span></span><br><span class="line">            <span class="keyword">if</span> (buckets[j] == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">// 若遇到指定 key ，则返回对应 val</span></span><br><span class="line">            <span class="keyword">if</span> (buckets[j]-&gt;key == key &amp;&amp; buckets[j] != removed)</span><br><span class="line">                <span class="keyword">return</span> buckets[j]-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, string val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当负载因子超过阈值时，执行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">loadFactor</span>() &gt; loadThres)</span><br><span class="line">            <span class="built_in">extend</span>();</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        <span class="comment">// 线性探测，从 index 开始向后遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">            <span class="comment">// 计算桶索引，越过尾部返回头部</span></span><br><span class="line">            <span class="type">int</span> j = (index + i) % capacity;</span><br><span class="line">            <span class="comment">// 若遇到空桶、或带有删除标记的桶，则将键值对放入该桶</span></span><br><span class="line">            <span class="keyword">if</span> (buckets[j] == <span class="literal">nullptr</span> || buckets[j] == removed) &#123;</span><br><span class="line">                buckets[j] = <span class="keyword">new</span> <span class="built_in">Pair</span>(key, val);</span><br><span class="line">                size += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若遇到指定 key ，则更新对应 val</span></span><br><span class="line">            <span class="keyword">if</span> (buckets[j]-&gt;key == key) &#123;</span><br><span class="line">                buckets[j]-&gt;val = val;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除操作 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">hashFunc</span>(key);</span><br><span class="line">        <span class="comment">// 线性探测，从 index 开始向后遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">            <span class="comment">// 计算桶索引，越过尾部返回头部</span></span><br><span class="line">            <span class="type">int</span> j = (index + i) % capacity;</span><br><span class="line">            <span class="comment">// 若遇到空桶，说明无此 key ，则直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (buckets[j] == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 若遇到指定 key ，则标记删除并返回</span></span><br><span class="line">            <span class="keyword">if</span> (buckets[j]-&gt;key == key) &#123;</span><br><span class="line">                <span class="keyword">delete</span> buckets[j]; <span class="comment">// 释放内存</span></span><br><span class="line">                buckets[j] = removed;</span><br><span class="line">                size -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 扩容哈希表 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 暂存原哈希表</span></span><br><span class="line">        vector&lt;Pair *&gt; bucketsTmp = buckets;</span><br><span class="line">        <span class="comment">// 初始化扩容后的新哈希表</span></span><br><span class="line">        capacity *= extendRatio;</span><br><span class="line">        buckets = <span class="built_in">vector</span>&lt;Pair *&gt;(capacity, <span class="literal">nullptr</span>);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将键值对从原哈希表搬运至新哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (Pair *pair : bucketsTmp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair != <span class="literal">nullptr</span> &amp;&amp; pair != removed) &#123;</span><br><span class="line">                <span class="built_in">put</span>(pair-&gt;key, pair-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打印哈希表 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pair : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                cout &lt;&lt; pair-&gt;key &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; pair-&gt;val &lt;&lt; endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;nullptr&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-多次哈希"><a href="#2-多次哈希" class="headerlink" title="2.   多次哈希"></a>2.   多次哈希</h4><p>顾名思义，多次哈希方法是使用多个哈希函数 f1(x)、f2(x)、f3(x)、… 进行探测。和<code>f1</code>结果相同的可能性很小</p>
<ul>
<li><strong>插入元素</strong>：若哈希函数 f1(x) 出现冲突，则尝试 f2(x) ，以此类推，直到找到空位后插入元素。</li>
<li><strong>查找元素</strong>：在相同的哈希函数顺序下进行查找，直到找到目标元素时返回；或遇到空位或已尝试所有哈希函数，说明哈希表中不存在该元素，则返回 None 。</li>
</ul>
<p>与线性探测相比，多次哈希方法不易产生聚集，但多个哈希函数会增加额外的计算量。</p>
<p><strong>也就是所谓二次探测法</strong></p>
<p>二次探测：找下一个空位置的方法为：<strong>pos &#x3D; ( cur+i^2)% m</strong>。其中：i &#x3D; 1,2,3…， cur是通过散列函数Hash(x)对元素的关键码key 进行计算得到的位置，m是表的大小,pos是空位置。如下图，插入数据“24”，插入位置顺序4–&gt;5–&gt;8</p>
<p><img src="https://pica.zhimg.com/80/v2-fdd3fb240ddaa5d9c4396a9fc10b76ed_1440w.webp?source=1940ef5c"></p>
<p>注意：当表的长度为质数且表负载因子a不超过0.5时，新的表项一定能够插入，而且任何一个位置都不会被探查两次。因此只要表中有一半的空位置，就不会存在表满的问题。在搜索时可以不考虑表装 满的情况，但在插入时必须确保表的负载因子a不超过0.5，如果超出必须考虑增容。</p>
<p>载荷因子（负载因子）</p>
<p>a&#x3D;填入表中的元素个数 &#x2F; 散列表的长度</p>
<p>对于开放定址法，负载因子最好不要超过0.7-0.8.</p>
<h4 id="编程语言的选择"><a href="#编程语言的选择" class="headerlink" title="编程语言的选择"></a>编程语言的选择</h4><p>Java 采用链式地址。自 JDK 1.8 以来，当 HashMap 内数组长度达到 64 且链表长度达到 8 时，链表会被转换为红黑树以提升查找性能。</p>
<p>Python 采用开放寻址。字典 dict 使用伪随机数进行探测。</p>
<p>Golang 采用链式地址。Go 规定每个桶最多存储 8 个键值对，超出容量则连接一个溢出桶；当溢出桶过多时，会执行一次特殊的等量扩容操作，以确保性能。</p>
<h2 id="hash-algorithm？？？？？？"><a href="#hash-algorithm？？？？？？" class="headerlink" title="hash algorithm？？？？？？"></a>hash algorithm？？？？？？</h2><p>哈希算法除了可以用于实现哈希表key索引映射内存索引，还广泛应用于加密信息</p>
<ul>
<li><strong>密码存储</strong>：为了保护用户密码的安全，系统通常不会直接存储用户的明文密码，而是存储密码的哈希值。当用户输入密码时，系统会对输入的密码计算哈希值，然后与存储的哈希值进行比较。如果两者匹配，那么密码就被视为正确。</li>
<li><strong>数据完整性检查</strong>：数据发送方可以计算数据的哈希值并将其一同发送；接收方可以重新计算接收到的数据的哈希值，并与接收到的哈希值进行比较。如果两者匹配，那么数据就被视为完整的。</li>
</ul>
<p>对于密码学的相关应用，为了防止从哈希值推导出原始密码等逆向工程，哈希算法需要具备更高等级的安全特性。</p>
<ul>
<li><strong>抗碰撞性</strong>：极其困难找到两个不同输入的哈希值相同。</li>
<li><strong>雪崩效应</strong>：输入的微小变化应当导致输出的显著且不可预测的变化。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构&amp;算法</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>cpu调度</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8%EF%BC%89/cpu%E8%B0%83%E5%BA%A6/cpu%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>进程进入或离开运行态时发生现场保护&#x2F;恢复；可见cpu调度是有时空开销的<br>1）进程上下文切换<br>进程下cpu：把现场信息（寄存器和程序计数器和虚拟内存静态映像）暂存入进程PCB<br>进程上cpu：os为CPU 预设好 CPU 寄存器和程序计数器（以及恢复现场，cpu从断点处开始运行指令）<br>2）线程上下文切换</p>
<p>3）中断上下文切换。</p>
<h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><p>1）CPU利用率 &#x3D; $1-\frac{空闲CPU时间}{总CPU时间}$</p>
<p>2）系统吞吐量 &#x3D; $\frac{完成作业数}{总时间}$<br>单位时间内 CPU 完成进程数，长作业进程会占用较久 CPU 资源，降低吞吐量；短作业进程提升系统吞吐量</p>
<p>3）周转时间 &#x3D; 完成时间 - 到达时间;<br>周转时间是进程运行+阻塞时间+等待时间的总和，一个进程的周转时间越小越好；</p>
<p>4）等待时间 &#x3D; 开始执行时间 - 到达时间<br>进程处于就绪队列的时间，等待越长，进程周转时间越长</p>
<p>5）响应时间 &#x3D; 第一次响应时间 - 到达时间<br>用户提交请求到系统第一次产生响应所花时间；交互式系统中，响应时间是衡量调度算法好坏的主要标准</p>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><p>**非抢占式调度：<strong>进程离开运行态的原因只有主动退出（阻塞&#x2F;运行完成&#x2F;exit调用&#x2F;异常）；优先级指影响就绪队列的排序<br>**<br>抢占式调度</strong>：在时钟信号到达（时间片用尽）发生时钟中断； 然后把CPU 分配给高优先级任务；或当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。</p>
<p>进程的优先级可分为：<br>1）静态优先级：创建进程时已确定优先级，然后整个运行时间优先级不会变化；<br>2）动态优先级：进程优先级动态变化</p>
<p>调度原则<br><em>原则一</em>：** I&#x2F;O 事件致使 CPU 空闲（<strong>eg:等待硬盘的数据返回</strong>）<strong>；调</strong>度程序需从就绪队列中选一个进程运行 **，<strong>提高 CPU 利用率</strong>(要有阻塞机制)</p>
<p><em>原则二</em>：长作业会造成系统吞吐量降低；<strong>调度程序要权衡长任务和短任务进程的运行完成数量</strong>；</p>
<p><em>原则三</em>：应避免等待时间&#x2F;周转时间的比值过小<br>*<br>原则四*：等待时间越短越好，因为是要占据内存资源的<br>*<br>原则五*：<strong>交互式应用的响应时间</strong>越短越好</p>
<h4 id="非抢占式的先来先服务（First-Come-First-Serve-FCFS）"><a href="#非抢占式的先来先服务（First-Come-First-Serve-FCFS）" class="headerlink" title="非抢占式的先来先服务（First Come First Serve, FCFS）"></a>非抢占式的<strong>先来先服务（</strong><em><strong>First Come First Serve, FCFS</strong></em><strong>）</strong></h4><p><img src="/image/image_heWVEjVseb.png"></p>
<p>按就绪队列先后进入顺序调度运行进程（优先级取决于到达时间）：<br>缺点：当长作业先于短作业进入就绪队列；很显然短作业的$\frac{等待时间}{周转时间}$之比会远远大于长作业；对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I&#x2F;O 繁忙型作业的系统</p>
<h4 id="最短作业优先"><a href="#最短作业优先" class="headerlink" title="最短作业优先"></a>最短作业优先</h4><p><img src="/image/image_HDbxla_tfw.png"></p>
<p>预测作业的运行时间并对就绪队列排序，短时长优先，使总体上的等待时间最小<br>缺点：会造成长作业饥饿现象，即短作业一直插队到前面，导致长作业一直被后延甚至不执行</p>
<h4 id="高响应比优先"><a href="#高响应比优先" class="headerlink" title="高响应比优先"></a>高响应比优先</h4><p>就绪队列进程排序依据变为$\frac{周转时间}{作业要求处理时间}&#x3D;\frac{作业要求处理时间+等待时间}{作业要求处理时间}&#x3D;1+\frac{等待时间}{作业要求处理时间}$；要求处理时间越短相应比越大，而等待时间越长排序越前移；解决了最短作业优先的弊端<br>缺点：现实中没有os采用这个理想算法；因为预测执行时间的难度大</p>
<h4 id="时间片轮转（Round-Robin-RR）"><a href="#时间片轮转（Round-Robin-RR）" class="headerlink" title="时间片轮转（Round Robin, RR）"></a><strong>时间片轮转（</strong><em><strong>Round Robin, RR</strong></em><strong>）</strong></h4><p><img src="/image/image_0UAmge-unv.png"></p>
<p>进入时钟中断时，若进程还在运行态，将其push就绪队列并pop就绪队列的下一个进程上cpu；若进程在时间片结束前阻塞&#x2F;结束，则 CPU 立即进行切换；不会产生饥饿，一般来说，时间片设为 <code>20ms~50ms</code> 通常是一个比较合理的折中值<br>缺点：若时间片设的太短会导致cpu频繁进行上下文切换；时间片设的太长会导致短作业进程响应时间变长</p>
<h4 id="最高优先级（-​Highest-Priority-First，HPF"><a href="#最高优先级（-​Highest-Priority-First，HPF" class="headerlink" title="最高优先级（ ​Highest Priority First，HPF"></a><strong>最高优先级（</strong> ​<em><strong>Highest Priority First，HPF</strong></em></h4><p>非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。<br>抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。<br>缺点：可能会导致低优先级进程永远不会运行</p>
<h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><p><img src="/image/image_yGaYgUBHkE.png"></p>
<p>理想的就绪队列排序依据是运行时间长，等待时间短的优先级低；<br><strong>设计多优先级队列</strong>，且<strong>优先级越高的时间片越短</strong>：新进程都会push进最高优先级队列，按先来先服务顺序上cpu,短作业会比较快的完成，而长作业会在时间片用完后push进下一优先级就绪队列，这样就巧妙的对不同运行时长梯度从低到高划分了优先级；</p>
<p><img src="/image/image_FY3DO49AR4.png"></p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程异步</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8%EF%BC%89/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%82%E6%AD%A5/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*编写一个视频播放器软件，那么该软件功能的核心模块有三个：</span></span><br><span class="line"><span class="comment">1.从视频文件当中读取数据；</span></span><br><span class="line"><span class="comment">2.对读取的数据进行解压缩；</span></span><br><span class="line"><span class="comment">3.把解压缩后的视频数据播放出来；*/</span></span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    read();<span class="comment">//读取，io操作</span></span><br><span class="line">    </span><br><span class="line">    decode();<span class="comment">//解码，吃cpu算力</span></span><br><span class="line">    </span><br><span class="line">    play();<span class="comment">//播放</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//假如每秒25帧，每帧数据量100k;cpu0.1s处理2500K，IO0.9秒read2500K;当IO时，cpu为避免空闲，进程阻塞下cpu；为提高cpu利用率；在IO时应调度cpu执行decode</span></span><br><span class="line"><span class="number">1</span>）多进程并行/并发:这种实现方式要实现进程之间通信，共享数据；且创建进程时，分配资源、建立 PCB；终止进程时，回收资源、撤销 PCB；进程切换时，保存当前进程的状态信息；时空开销巨大</span><br><span class="line">main()&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    read();<span class="comment">//读取，io操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    decode();<span class="comment">//解码，吃cpu算力</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    play();<span class="comment">//播放</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）多线程并行/并发：可共享虚拟内存（栈区和寄存器资源各自独立）；创建的独立资源少，内存开销较小，因释放的独立资源少且共享数据不用经过内核，线程时间开销也较小</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>线程的缺点：</p>
<ul>
<li>当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃（这里是针对 C&#x2F;C++ 语言，Java语言中的线程奔溃不会造成进程崩溃，具体分析原因可以看这篇：<a href="https://xiaolincoding.com/os/4_process/thread_crash.html" title="线程崩溃了，进程也会崩溃吗？ (opens new window)">线程崩溃了，进程也会崩溃吗？ (opens new window)</a>）。</li>
</ul>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>进程通信</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8%EF%BC%89/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p>内核空间是所有进程共享的，进程间通信就是：在内核空间中开辟一块缓冲区交换数据；进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走</p>
<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p><img src="/image/image_9Ol8AcludI.png"></p>
<p>Linux把管道实现为一种伪文件；本质是在内核空间中开辟的环形队列buffer；创建时在进程PCB的文件描述符表中注册了读&#x2F;写端描述符，分别是指向队头队尾的指针；且在VFS接口层提供了操作接口；由于是环形队列，其天然是半双工通信；</p>
<p>命名管道通信：<code>fork</code> 创建子进程，则两个进程都有指向队头队尾的 <code>fd[0]</code> 与 <code>fd[1]</code>描述符；为避免读写冲突，规定父子进程各保留一个文件描述符分别指向队头队尾；如果需要双向通信，则应该创建两个管道</p>
<p>匿名管道通信：shell 里执行 <code>A | B</code>命令时，A B进程都是 shell 的子进程,要关闭4各文件描述符</p>
<p><img src="/image/image_VC0mqaPJL8.png"></p>
<p><img src="/image/image_OhKkBj_2hI.png"></p>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>消息队列是在内核空间中维护的链表。发数据时，数据被分成一个个消息体（数据块）。消息体是用户双方约好的消息体自定义数据类型，因此每个消息体都是固定大小的存储块，不像管道那样是无格式的字节流数据。当进程从消息队列中读取消息体后，内核会将该消息体删除。</p>
<p>A 进程向 B 进程发消息时，A 进程将数据放入相应的消息队列，然后就可以继续正常操作了，B 进程在需要时再去读取数据即可。</p>
<p>消息队列的生命周期与内核相关。如果没有释放消息队列或者关闭操作系统，消息队列会一直存在。而前面提到的匿名管道的生命周期则是随着进程的创建而建立，随着进程的结束而销毁。这种模型下，两个进程之间的通信就像平时发送邮件一样，你来一封，我回一封，可以频繁沟通了。</p>
<p>缺点：1）通信不及时2）消息体大小限制3）</p>
<p>消息队列并不适合传输较大的数据，因为在内核中，每个消息体都有一个最大长度的限制，同时所有队列包含的消息体总长度也是有上限的。在 Linux 内核中，有两个宏定义 MSGMAX 和 MSGMNB，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。</p>
<p>在消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销。因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同样地，另一个进程读取内核中的消息数据时，也会发生从内核态拷贝数据到用户态的过程。</p>
<h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><p><strong>拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度</p>
<p><img src="/image/image_ZW365jaNvc.png"></p>
<h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><h1 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h1><h1 id="进程通信posix"><a href="#进程通信posix" class="headerlink" title="进程通信posix"></a>进程通信posix</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>2）运算优先级</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/2%EF%BC%89%E8%BF%90%E7%AE%97%E4%BC%98%E5%85%88%E7%BA%A7/2%EF%BC%89%E8%BF%90%E7%AE%97%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    <content><![CDATA[<p>（() [] -&gt; .） &gt; 单目运算 &gt; 算术运算 &gt; 比较运算 &gt;位运算&gt;逻辑运算&gt; 三目运算&gt; 语法糖（赋值运算） &gt; 逗号运算</p>
<p><img src="/image/image_COL-uMiAHk.png"></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E5%9B%BD%E9%99%85%E5%8C%96/%E5%9B%BD%E9%99%85%E5%8C%96/</url>
    <content><![CDATA[<h1 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h1>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C/%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作"></a>内存操作</h1><p><img src="/image/image_4mmSsJTepg.png"></p>
<p><img src="/image/image_TUpUM0xaHz.png"></p>
<p><img src="/image/image_xotF1TboCO.png"></p>
<p><img src="/image/image_ncHSciS3Nv.png"></p>
<p><img src="/image/image_xUCoA8nag8.png"></p>
<p><img src="/image/image_216lmCiCIC.png"></p>
<p><img src="/image/image_AoiRzI_6es.png"></p>
<p><img src="/image/image_Q1zam2UnVC.png"></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97/%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="数学计算"><a href="#数学计算" class="headerlink" title="数学计算"></a>数学计算</h1>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h1><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><h1 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h1><h1 id="比较-检查"><a href="#比较-检查" class="headerlink" title="比较&#x2F;检查"></a>比较&#x2F;检查</h1><h1 id="查找-统计"><a href="#查找-统计" class="headerlink" title="查找&#x2F;统计"></a>查找&#x2F;统计</h1><h1 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h1><h1 id="逆置"><a href="#逆置" class="headerlink" title="逆置"></a>逆置</h1><h1 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h1><h1 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h1><h1 id="字符串类型转换"><a href="#字符串类型转换" class="headerlink" title="字符串类型转换"></a>字符串类型转换</h1><p><img src="/image/image_hFxZ_Zo6T2.png"></p>
<p><img src="/image/image_9o_7fWWAtq.png"></p>
<p><img src="/image/image_rXRleFRPjO.png"></p>
<p>常用：</p>
<p><img src="/image/image_KucMWDzr4h.png"></p>
<p>printf &#x2F;putchar 输出到控制台显示缓冲区</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);<span class="comment">//格式化输出一个字符串</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%%d\n&quot;</span>);</span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">putchar</span>(c);<span class="comment">//putchar 只有一个参数，就是要输出的 char</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>scanf&#x2F;getchar ：读取标准输入设备输入</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> ch1;</span><br><span class="line"><span class="type">char</span> ch2;</span><br><span class="line"><span class="type">char</span> ch3;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">ch2 = getchar();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\&#x27;ch2 = %ctest\&#x27;\n&quot;</span>, ch2);</span><br><span class="line">getchar(); <span class="comment">//测试此处 getchar()的作用</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入 ch3 的字符：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch3);<span class="comment">//这里第二个参数一定是变量的地址，而不是变量名</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ch3 = %c\n&quot;</span>, ch3);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入 a 的值：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br></pre></td></tr></table></figure>

<p><img src="/image/image_E-k6JA6jx1.png"></p>
<p><img src="/image/image_bydvHIA8rw.png"></p>
<p><img src="/image/image_OgmaBiRCJA.png"></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E6%97%B6%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/%E6%97%B6%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h1 id="时期和时间"><a href="#时期和时间" class="headerlink" title="时期和时间"></a>时期和时间</h1>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/02/08/%E8%BD%AF%E4%BB%B6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%B0%83%E8%AF%95%EF%BC%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%8C%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AE%B9/%E8%B0%83%E8%AF%95%EF%BC%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%8C%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<h1 id="调试，错误处理，查看内容"><a href="#调试，错误处理，查看内容" class="headerlink" title="调试，错误处理，查看内容"></a>调试，错误处理，查看内容</h1>]]></content>
  </entry>
  <entry>
    <title>新页面</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E6%96%B0%E9%A1%B5%E9%9D%A2/%E6%96%B0%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>包</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/%E5%8C%85/%E5%8C%85/</url>
    <content><![CDATA[<p>python内置函数；三方模块</p>
<p><a href="https://docs.python.org/3/library/functions.html" title="Built-in Functions The Python interpreter has a number of functions and types built into it that are always available. They are listed here in alphabetical order.,,,, Built-in Functions,,, A, abs(), aiter(), all(), a... https://docs.python.org/3/library/functions.html">Built-in Functions The Python interpreter has a number of functions and types built into it that are always available. They are listed here in alphabetical order.,,,, Built-in Functions,,, A, abs(), aiter(), all(), a… https://docs.python.org/3/library/functions.html</a></p>
<p><a href="https://pypi.org/" title=" PyPI · The Python Package Index The Python Package Index (PyPI) is a repository of software for the Python programming language. https://pypi.org/"> PyPI · The Python Package Index The Python Package Index (PyPI) is a repository of software for the Python programming language. https://pypi.org/</a></p>
<p>为避免不同人编写模块名冲突；引入按目录来组织模块的方法，称为包（Package）；顶层包名不与别人冲突，那所有模块都不会与别人冲突。<code>abc.py</code>模块的名字就变成了<code>mycompany.abc</code>；<br>包目录下都会有<code>__init__.py</code>模块，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。<code>__init__.py</code>可以是空文件，它的模块名就是<code>mycompany</code>；<br>允许多级层次的包结构；文件<code>www.py</code>的模块名就是<code>mycompany.web.www</code>，两个文件<code>utils.py</code>的模块名分别是<code>mycompany.utils</code>和<code>mycompany.web.utils</code>；<br>模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行<code>import abc</code>，若成功则说明系统存在此模块</p>
<p><img src="/image/image_ztrkAeHx09.png"></p>
<p><img src="/image/image_B0JdWOkpkz.png"></p>
<p>标准模块模板：<br>第1行注释指定解释器路径；可让这个文件直接在Unix&#x2F;Linux&#x2F;Mac上运行<br>第2行注释表示使用标准UTF-8编码<br>第4行表示模块的文档注释，任何模块第一个字符串被视为模块文档注释；<br>第6行使用<code>__author__</code>变量把作者写进去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf<span class="number">-8</span> -*-</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27; a test module &#x27;</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">&#x27;Michael Liao&#x27;</span></span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def test():</span><br><span class="line">    args = sys.argv</span><br><span class="line">    <span class="keyword">if</span> len(args)==<span class="number">1</span>:</span><br><span class="line">        print(<span class="string">&#x27;Hello, world!&#x27;</span>)</span><br><span class="line">    elif len(args)==<span class="number">2</span>:</span><br><span class="line">        print(<span class="string">&#x27;Hello, %s!&#x27;</span> % args[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;Too many arguments!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure>

<p>默认情况下，Python解释器会搜索1)当前目录、2)PYTHONPATH 环境变量指定的路径中查找该模块3）python解释器安装目录；可以使用 <code>sys</code> 模块来查看Python解释器的搜索路径</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.path</span><br><span class="line">[<span class="string">&#x27;&#x27;, &#x27;</span>/Library/Frameworks/Python.framework/Versions/<span class="number">3.6</span>/lib/python36.zip<span class="number">&#x27;</span>, <span class="string">&#x27;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6&#x27;</span>, ..., <span class="string">&#x27;/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages&#x27;</span>]</span><br><span class="line"></span><br><span class="line">运行时添加搜索路径，运行结束后失效</span><br><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.path.append(<span class="string">&#x27;/Users/michael/my_py_scripts&#x27;</span>)</span><br><span class="line"></span><br><span class="line">永久添加则修改环境变量；会自动添加到path</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>流程控制</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>条件判断：<br>省略了（），添加了冒号：；用缩进替代{}；else if缩写为elif</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">6</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;teenager&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;adult&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;kid&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>模式匹配match：即switch</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">score = <span class="string">&#x27;B&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> score:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;score is A.&#x27;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;score is B.&#x27;</span>)</span><br><span class="line">    <span class="keyword">case</span> _: <span class="comment"># _表示匹配到其他任何情况</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;score is ???.&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#匹配多值、匹配一定范围，并且把匹配后的值绑定到变量</span></span><br><span class="line">age = <span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> age:</span><br><span class="line">    <span class="keyword">case</span> x <span class="keyword">if</span> x &lt; <span class="number">10</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;&lt; 10 years old: <span class="subst">&#123;x&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span> | <span class="number">12</span> | <span class="number">13</span> | <span class="number">14</span> | <span class="number">15</span> | <span class="number">16</span> | <span class="number">17</span> | <span class="number">18</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;11~18 years old.&#x27;</span>)</span><br><span class="line">    <span class="keyword">case</span> _:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;not sure.&#x27;</span>)</span><br><span class="line"> <span class="comment">######匹配列表</span></span><br><span class="line"> args = [<span class="string">&#x27;gcc&#x27;</span>, <span class="string">&#x27;hello.c&#x27;</span>, <span class="string">&#x27;world.c&#x27;</span>]</span><br><span class="line"><span class="comment"># args = [&#x27;clean&#x27;]</span></span><br><span class="line"><span class="comment"># args = [&#x27;gcc&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> args:</span><br><span class="line">    <span class="comment"># 如果仅出现gcc，报错:</span></span><br><span class="line">    <span class="keyword">case</span> [<span class="string">&#x27;gcc&#x27;</span>]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;gcc: missing source file(s).&#x27;</span>)</span><br><span class="line">    <span class="comment"># 出现gcc，且至少指定了一个文件:</span></span><br><span class="line">    <span class="keyword">case</span> [<span class="string">&#x27;gcc&#x27;</span>, file1, *files]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;gcc compile: &#x27;</span> + file1 + <span class="string">&#x27;, &#x27;</span> + <span class="string">&#x27;, &#x27;</span>.join(files))</span><br><span class="line">    <span class="keyword">case</span> _:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;invalid command.&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一个<code>case [&#39;gcc&#39;]</code>表示列表仅有<code>&#39;gcc&#39;</code>一个字符串，没有指定文件名，报错；</p>
<p>第二个<code>case [&#39;gcc&#39;, file1, *files]</code>表示列表第一个字符串是<code>&#39;gcc&#39;</code>，第二个字符串绑定到变量<code>file1</code>，后面的任意个字符串绑定到<code>*files</code>（符号<code>*</code>的作用将在<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017261630425888" title="函数的参数">函数的参数</a>中讲解），它实际上表示至少指定一个文件；</p>
<p>集合成员匹配</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kw = &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;city&#x27;</span> <span class="keyword">in</span> kw:</span><br><span class="line">      <span class="comment"># 有city参数</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;job&#x27;</span> <span class="keyword">in</span> kw:</span><br><span class="line">      <span class="comment"># 有job参数</span></span><br><span class="line">      <span class="keyword">pass</span>    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>遍历：<br><code>for x in ...</code>依次从可迭代对象中拿出元素放入<code>x</code>，然后执行缩进块的语句</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">101</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">sum</span> + x</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure>

<p>同时迭代索引和元素：<br>Python内置<code>enumerate</code>函数可以把一个<code>list</code>变成索引-元素对，这样就可以在<code>for</code>循环中同时迭代索引和元素本身：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, value <span class="keyword">in</span> <span class="built_in">enumerate</span>([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i, value)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span> A</span><br><span class="line"><span class="number">1</span> B</span><br><span class="line"><span class="number">2</span> C</span><br></pre></td></tr></table></figure>

<p>遍历列表中向量元素分量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> a1, a2 <span class="keyword">in</span> [(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">9</span>)]:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(a1, a2)</span><br><span class="line">...</span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>字典迭代：<br>对于字典d&#x3D; {‘a’: 1, ‘b’: 2, ‘c’: 3}；值的存储位置由哈希函数映射，遍历顺序并不是abc顺序；默认情况下，<code>dict</code>迭代的是key；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> d:</span><br></pre></td></tr></table></figure>

<p>如果要迭代value，可以用<code>for value in d.values()</code>，<br>如果要同时迭代key和value，可以用<code>for k, v in d.items()</code><br>判断可迭代对象：<br>通过<code>collections.abc</code>模块的<code>Iterable</code>类型判断：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="string">&#x27;abc&#x27;</span>, Iterable) <span class="comment"># str是否可迭代</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], Iterable) <span class="comment"># list是否可迭代</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="number">123</span>, Iterable) <span class="comment"># 整数是否可迭代</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型和运算符（元结构）</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E5%85%83%E7%BB%93%E6%9E%84%EF%BC%89/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E5%85%83%E7%BB%93%E6%9E%84%EF%BC%89/</url>
    <content><![CDATA[<p>生成器generator</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>空型：None</p>
<p>整型：Python允许在数字中间以<code>_</code>分隔，因此<code>10_000_000_000</code>和<code>10000000000</code>完全一样。（对于很大的数，例如<code>10000000000</code>，很难数清楚0的个数）</p>
<p>字符串：Python允许用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的格式表示多行内容（<code>\n</code>写在一行里不好阅读）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;&#x27;&#x27;line1</span></span><br><span class="line"><span class="string"><span class="meta">... </span>line2</span></span><br><span class="line"><span class="string"><span class="meta">... </span>line3&#x27;&#x27;&#x27;</span>)</span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br></pre></td></tr></table></figure>

<p>Python允许用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>内部的字符串默认不转义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;\\\t\\&#x27;</span>)</span><br><span class="line">\       \</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">r&#x27;\\\t\\&#x27;</span>)</span><br><span class="line">\\\t\\</span><br><span class="line"><span class="comment">#############</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">print</span>(<span class="string">r&#x27;&#x27;&#x27;hello,\n</span></span><br><span class="line"><span class="string">world&#x27;&#x27;&#x27;</span>)</span><br><span class="line">hello,\n</span><br><span class="line">world</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>字符串<code>replace()</code>方法:替换字符并创建一个新字符串<code>&#39;Abc&#39;</code>返回</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="string">&#x27;Abc&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="string">&#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure>

<p>列表list：<br>有序集；动态且不限成员类型的数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##定义</span></span><br><span class="line">classmates = [<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>]</span><br><span class="line"><span class="comment">##成员数量</span></span><br><span class="line"><span class="built_in">len</span>(classmates)</span><br><span class="line"><span class="comment">##访问</span></span><br><span class="line">classmates[<span class="number">0</span>]</span><br><span class="line">classmates[-<span class="number">1</span>]</span><br><span class="line">classmates[<span class="number">0</span>][<span class="number">2</span>]</span><br><span class="line"><span class="comment">##添加</span></span><br><span class="line">classmates.append(<span class="string">&#x27;Adam&#x27;</span>)</span><br><span class="line">classmates.insert(<span class="number">1</span>, <span class="string">&#x27;Jack&#x27;</span>)</span><br><span class="line"><span class="comment">##删除</span></span><br><span class="line">classmates.pop()</span><br><span class="line">classmates.pop(<span class="number">1</span>)</span><br><span class="line"><span class="comment">##排序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>元组tuple:<br>初始化后不能修改的有序集（不能修改指变量指向的对象不变）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##定义</span></span><br><span class="line">classmates = (<span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Tracy&#x27;</span>)</span><br><span class="line"><span class="comment">##()既可表示tuple，又可表示数学公式中的小括号，产生歧义；so仅一个元素的元组要加，</span></span><br><span class="line">t = (<span class="number">1</span>)</span><br><span class="line">t = (<span class="number">1</span>,)</span><br><span class="line"><span class="comment">##访问方式同list</span></span><br><span class="line"><span class="comment">##可变的tuple；t[2]指向的对象不变；但t[2][x]可变</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>][<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">&#x27;Y&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, [<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>字典dict：其他语言中也称为map（hash map）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">##定义</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">&#x27;Michael&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;Bob&#x27;</span>: <span class="number">75</span>, <span class="string">&#x27;Tracy&#x27;</span>: <span class="number">85</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Michael&#x27;</span>]</span><br><span class="line"><span class="number">95</span></span><br><span class="line"><span class="comment">##赋值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Michael&#x27;</span>] = <span class="number">90</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">&#x27;Michael&#x27;</span>]</span><br><span class="line"><span class="number">90</span></span><br><span class="line"><span class="comment">##如果key不存在，访问就会报错；访问时经常通过get()方法，如果key不存在，返回None或自己指定的value</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">&#x27;Thomas&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.get(<span class="string">&#x27;Thomas&#x27;</span>, -<span class="number">1</span>)</span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="comment">##删除</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.pop(<span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line"><span class="number">75</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">&#x27;Michael&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;Tracy&#x27;</span>: <span class="number">85</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>要保证hash算法输出持续一致，输入的key对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：</p>
<p>set:<br>无序集；传入参数<code>[1,1,2, 2,3, 3]</code>是一个有序集list，重复元素在set中自动被过滤而显示的<code>&#123;1, 2, 3&#125;</code>，显示顺序也不表示set是有序的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">##添加add(key)方法可以添加元素到set中，可以重复添加，但不会有效果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="comment">##删除</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.remove(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">##交</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="built_in">set</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 &amp; s2</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">##并</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 | s2</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>对于大量数据的遍历，若数据分量存在递推关系（可由列表生成式生成）；则可只存储递推算法，遍历时再生成分量；以时间换空间；<br>由于列表生成式只能表示$a_n&#x3D;f(b_n)$类型的递推式；对于生成器表达式不能表示的递推关系用generator函数实现遍历(函数定义中包含yield关键字，则此函数是generator函数)；</p>
<p>generator函数在每次调用<code>next()</code>时执行，遇到<code>yield</code>语句返回，再次执行时从上次返回的<code>yield</code>语句处继续执行;yield打印的就是分量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>]   <span class="comment">##a_n=n^2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))  <span class="comment">##改成圆括号的列表生成式</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator <span class="built_in">object</span> &lt;genexpr&gt; at <span class="number">0x1022ef630</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#####generator保存递推算法，每次调用next(g)，就计算出下一个元素的值，直到没有更多的元素时，抛出StopIteration的错误</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">next</span>(g)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###一般不会如上边那样遍历</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> g:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(n)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">####generator函数:斐波那契数列a_&#123;n+1&#125;=a_&#123;n&#125;+a_&#123;n-1&#125;；yield生成递推分量，注意要设置循环递推退出条件，否则就会生成无限序列</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span>  </span><br><span class="line"><span class="comment">####测试</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = fibonacci(<span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f</span><br><span class="line">&lt;generator <span class="built_in">object</span> fibonacci at <span class="number">0x104feaaa0</span>&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;g =fibonacci(<span class="number">1</span>)</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">next</span>(g)</span><br><span class="line"><span class="number">0</span></span><br><span class="line">&gt;&gt;&gt;<span class="built_in">next</span>(g)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> n <span class="keyword">in</span> fibonacci(<span class="number">5</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(n)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#####for循环调用generator时，发现拿不到generator的return语句的返回值。如果想要拿到返回值，必须捕获StopIteration错误，返回值包含在StopIteration的value中</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = fibonacci(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>        x = <span class="built_in">next</span>(g)</span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;g:&#x27;</span>, x)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:    <span class="comment">###py3.3后生成器迭代异常可带返回值</span></span><br><span class="line"><span class="meta">... </span>        <span class="built_in">print</span>(<span class="string">&#x27;Generator return value:&#x27;</span>, e.value)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">break</span></span><br><span class="line">...</span><br><span class="line">g: <span class="number">1</span></span><br><span class="line">g: <span class="number">1</span></span><br><span class="line">g: <span class="number">2</span></span><br><span class="line">Generator <span class="keyword">return</span> value: done</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器(iterator):可被<code>next()</code>函数调用并不断返回下一个值：<code>tuple</code>、<code>set</code>（定义了__next()__）；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">自定义迭代器：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Color</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.index = -<span class="number">1</span></span><br><span class="line">        self.colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;green&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        self.index = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        self.index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.index &gt;= <span class="built_in">len</span>(self.colors):</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">return</span> self.colors[self.index]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可迭代对象（<code>Iterable</code>）：可直接作用于<code>for</code>循环：<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>,<code>generator</code>(需要定义了__iter__)；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">因为<span class="keyword">for</span>遍历等价于：</span><br><span class="line"></span><br><span class="line">it = <span class="built_in">iter</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x = <span class="built_in">next</span>(it)</span><br><span class="line">        <span class="comment">#pass代码块</span></span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="comment"># 遇到StopIteration就退出循环</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">##-&gt;显然，迭代器是可遍历的；且可迭代对象要遍历必须要定义__iter()__并调用返回一个实现了 __next__()迭代器</span></span><br></pre></td></tr></table></figure>

<h2 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h2><p>静态语言编译时确定变量类型（故需事先声明类型），如果赋值的时候类型不匹配，就会报错；<br>动态语言运行时确定数据类型（根据定义值）；<br>1）Python的整数没有大小限制<br>2）Python的浮点数也没有大小限制，但是超出一定范围就直接表示为<code>inf</code>（无限大）</p>
<h2 id="声明关键字"><a href="#声明关键字" class="headerlink" title="声明关键字"></a>声明关键字</h2><p>私有变量&#x2F;方法：<strong>x<br>特殊变量&#x2F;方法：</strong> xxx__</p>
<h1 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h1><p>逻辑运算：<code>and，or，not</code><br>整数除法（向下取整,C里面一样）：&#x2F;&#x2F;<br>浮点数除法（不同于C）：&#x2F;<br>切片操作符：取有序对(可迭代对象)的一部分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">L[a:b]<span class="comment">#切片索引a到b-1</span></span><br><span class="line">L[:b]<span class="comment">#切片索引0到b-1</span></span><br><span class="line">L[a:]<span class="comment">#切片索引a+1到-0</span></span><br><span class="line">L[:]<span class="comment">#切片索引0到-0，复制</span></span><br><span class="line">L[::c]<span class="comment">#从0到-0每C个取首个</span></span><br><span class="line">_______________________________L可以是列表，元组，字符</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>][a:b:c]</span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)[a:b:c]</span><br><span class="line"><span class="string">&#x27;加油！&#x27;</span>[a:b:c]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>列表生成式list(range(a, b))<br>range(a,b)生成a到b-1的序列；list()打包成列表;元组生成式类似</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">------------生成自然数序列</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------生成自然数下标序列[1x1, 2x2, 3x3, ..., 10x10]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line"><span class="meta">... </span>   L.append(x * x)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br><span class="line">----------语法糖，x下标分量的式子是x*x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------筛出下标x为偶数的部分</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">16</span>, <span class="number">36</span>, <span class="number">64</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------生成全排列</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">&#x27;ABC&#x27;</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">&#x27;XYZ&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;AX&#x27;</span>, <span class="string">&#x27;AY&#x27;</span>, <span class="string">&#x27;AZ&#x27;</span>, <span class="string">&#x27;BX&#x27;</span>, <span class="string">&#x27;BY&#x27;</span>, <span class="string">&#x27;BZ&#x27;</span>, <span class="string">&#x27;CX&#x27;</span>, <span class="string">&#x27;CY&#x27;</span>, <span class="string">&#x27;CZ&#x27;</span>]</span><br><span class="line"></span><br><span class="line">----------分量表达式包含条件语句</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> -x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">[-<span class="number">1</span>, <span class="number">2</span>, -<span class="number">3</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">6</span>, -<span class="number">7</span>, <span class="number">8</span>, -<span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------列出当前目录下的所有文件和目录名</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os <span class="comment"># 导入os模块，模块的概念后面讲到</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[d <span class="keyword">for</span> d <span class="keyword">in</span> os.listdir(<span class="string">&#x27;.&#x27;</span>)] <span class="comment"># os.listdir可以列出文件和目录</span></span><br><span class="line">[<span class="string">&#x27;.emacs.d&#x27;</span>, <span class="string">&#x27;.ssh&#x27;</span>, <span class="string">&#x27;.Trash&#x27;</span>, <span class="string">&#x27;Adlm&#x27;</span>, <span class="string">&#x27;Applications&#x27;</span>, <span class="string">&#x27;Desktop&#x27;</span>, <span class="string">&#x27;Documents&#x27;</span>, <span class="string">&#x27;Downloads&#x27;</span>, <span class="string">&#x27;Library&#x27;</span>, <span class="string">&#x27;Movies&#x27;</span>, <span class="string">&#x27;Music&#x27;</span>, <span class="string">&#x27;Pictures&#x27;</span>, <span class="string">&#x27;Public&#x27;</span>, <span class="string">&#x27;VirtualBox VMs&#x27;</span>, <span class="string">&#x27;Workspace&#x27;</span>, <span class="string">&#x27;XCode&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017075323632896" title="https://www.liaoxuefeng.com/wiki/1016959663602400/1017075323632896">https://www.liaoxuefeng.com/wiki/1016959663602400/1017075323632896</a>？？？？？？？？编码</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>用户自定义数据类型&amp;函数</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&amp;%E5%87%BD%E6%95%B0/%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&amp;%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">abs</span> <span class="comment"># 变量a指向abs函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a(-<span class="number">1</span>) <span class="comment"># 所以也可以通过a调用abs函数</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>定义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">pass</span><span class="comment">#占位符</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##若无return语句，函数执行完毕后返回None。return None简写为return</span></span><br><span class="line"><span class="comment">##return a,b可返回多个值;可用多个对象接收；也可用单个对象接收元组(a,b)</span></span><br></pre></td></tr></table></figure>

<p><strong>参数类型检查</strong>用内置函数<code>isinstance()</code>实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_abs</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(x, (<span class="built_in">int</span>, <span class="built_in">float</span>)):</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">&#x27;bad operand type&#x27;</span>)<span class="comment">##抛出错误</span></span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure>

<p>参数为列表L&#x3D;[]类似于指针传参；通过L改变的是外部变量</p>
<h2 id="可变参数（tuple参数）"><a href="#可变参数（tuple参数）" class="headerlink" title="可变参数（tuple参数）"></a>可变参数（tuple参数）</h2><p>定义可变参数和定义list&#x2F;tuple参数相比，<em>numbers表示允许传入任意参数，这些参数在函数调用时自动组装为一个tuple;</em> numbers也表示把numbers列表&#x2F;元组变成可变参数传入（所以可变参数可传入集合）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">*numbers</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> + n * n</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line"><span class="comment">##调用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc()</span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>calc(*nums)<span class="comment">#*nums表示把nums这个list的所有元素作为可变参数传进去</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="关键字参数（字典参数）"><a href="#关键字参数（字典参数）" class="headerlink" title="关键字参数（字典参数）"></a>关键字参数（字典参数）</h2><p><strong>kw表示允许传入任意多形如key&#x3D;value的参数，这些参数在函数调用时自动组装为一个dict&#x3D;{‘key’&#x3D;value,…..};</strong> kw也表示把kw字典变成字典参数传入（所以可变参数可传入字典）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, **kw</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;name:&#x27;</span>, name, <span class="string">&#x27;age:&#x27;</span>, age, <span class="string">&#x27;other:&#x27;</span>, kw)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">35</span>, city=<span class="string">&#x27;Beijing&#x27;</span>)</span><br><span class="line">name: Bob age: <span class="number">35</span> other: &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Adam&#x27;</span>, <span class="number">45</span>, gender=<span class="string">&#x27;M&#x27;</span>, job=<span class="string">&#x27;Engineer&#x27;</span>)</span><br><span class="line">name: Adam age: <span class="number">45</span> other: &#123;<span class="string">&#x27;gender&#x27;</span>: <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kw= &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, **kw)</span><br><span class="line">name: Jack age: <span class="number">24</span> other: &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>限制传入关键字参数的key值；<code>*</code>,后面的参数被视为可传入的key</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, *, city, job</span>):</span><br><span class="line">    <span class="built_in">print</span>(name, age, city, job)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, city=<span class="string">&#x27;Beijing&#x27;</span>, job=<span class="string">&#x27;Engineer&#x27;</span>)</span><br><span class="line">Jack <span class="number">24</span> Beijing Engineer</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, *args, city, job</span>):</span><br><span class="line">    <span class="built_in">print</span>(name, age, args, city, job)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">person(zeins,<span class="number">12</span>,<span class="string">&#x27;zhuhai&#x27;</span>,<span class="string">&#x27;yanguo&#x27;</span>,city=<span class="string">&#x27;zhuhai&#x27;</span>,job=<span class="string">&#x27;engineer&#x27;</span>)</span><br><span class="line">&gt;&gt;&gt;zeins <span class="number">12</span> (<span class="string">&#x27;zhuhai&#x27;</span>,<span class="string">&#x27;yanguo&#x27;</span>) &#123;city:<span class="string">&#x27;zhuhai&#x27;</span>,job:<span class="string">&#x27;engineer&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数</p>
<h2 id="尾递归优化"><a href="#尾递归优化" class="headerlink" title="*尾递归优化"></a>*尾递归优化</h2><p>创始人声称Python标准解释器不会针对尾递归做优化；所以做优化得上魔法？让函数知道调用前计算已经完成，不必暂存数据</p>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p><strong>面向对象是传递数据给对象并操作数据</strong>；<br>1)复用性：<br>1.类是对象的模板，抽象出了对象共同性质，在实例化复用代码的同时互不干扰；<br>2.继承，虚函数<br>2）安全性：封装了成员，增加了访问限制；隐藏了算法实现，数据变得不透明，且可防止不期望的修改和访问<br>3）拓展性：多态</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    city = Newyork   <span class="comment">##固有并继承的类属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):   <span class="comment">##实例属性，取决于实例定义的值</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (self.name, self.score))</span><br><span class="line">        </span><br><span class="line">bart = Student(<span class="string">&#x27;Bart Simpson&#x27;</span>, <span class="number">59</span>) <span class="comment">##实例化：传递数据</span></span><br><span class="line"></span><br><span class="line">bart.print_score()             <span class="comment">##调用开放方法：操作数据</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>访问限制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):</span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__score = score</span><br><span class="line">        <span class="comment">##下面方法使数据从不可读不可写-&gt;可读不可写</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_name</span>(<span class="params">self</span>):</span><br><span class="line">      <span class="keyword">return</span> self.__name</span><br><span class="line"><span class="comment">##下面方法使数据从不可读不可写-&gt;不可读可写；为了做参数检测</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_score</span>(<span class="params">self, score</span>):</span><br><span class="line">      <span class="keyword">if</span> <span class="number">0</span> &lt;= score &lt;= <span class="number">100</span>:</span><br><span class="line">        self.__score = score</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&#x27;bad score&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##仍能通过实例名._Student__name访问，全靠自觉；</span></span><br><span class="line"><span class="comment">##通过实例名.__name=a;修改，实则是创建了一个新数据</span></span><br></pre></td></tr></table></figure>

<p>继承：复用父类代码<br>多态:<br>1）子类中同名方法覆盖父类同名方法<br>2）调用继承树中同名方法，定义的形参可以一致为父类指针；实际调用哪个同名方法取决于传入实参（对象实例指针）；继承树规模继续增大也不需修改调用函数，拓展性好</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Father is running...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Father</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Son is running...&#x27;</span>)</span><br><span class="line">  ________</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_twice</span>(<span class="params">Father</span>):</span><br><span class="line">  Father.run()</span><br><span class="line">  Father.run()</span><br><span class="line">  </span><br><span class="line">&gt;&gt;&gt;run_twice(Son())</span><br><span class="line">&gt;&gt;&gt;Son <span class="keyword">is</span> running...</span><br><span class="line">&gt;&gt;&gt;Son <span class="keyword">is</span> running...</span><br></pre></td></tr></table></figure>

<p>类属性&amp;实例属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    city = Newyork   <span class="comment">##固有并继承的类属性；且对所有实例开放</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):   <span class="comment">##实例属性，取决于实例定义的值</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="comment">##访问类属性；若有同名实例属性，优先访问实例属性        </span></span><br><span class="line">bart = Student(<span class="string">&#x27;Bart Simpson&#x27;</span>) <span class="comment">##实例化：传递数据</span></span><br><span class="line"><span class="built_in">print</span>(bart.city)</span><br><span class="line">&gt;&gt;&gt;Newyork</span><br><span class="line"><span class="comment">##为避免类属性被同名实例属性覆盖，如此访问</span></span><br><span class="line"><span class="built_in">print</span>(Student.city)</span><br><span class="line">&gt;&gt;&gt;Newyork</span><br><span class="line"></span><br><span class="line"><span class="comment">###实例属性亦可类外绑定</span></span><br><span class="line">bart.score =<span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>类外定义类方法&amp;实例方法（已声明实例独有方法）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">set_age</span>(<span class="params">self,age</span>): <span class="comment">##类外定义方法</span></span><br><span class="line">  self.age = age</span><br><span class="line"></span><br><span class="line"><span class="comment">##声明为实例s的方法  </span></span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> MethodType</span><br><span class="line">s.set_age = MethodType(set_age,s)</span><br><span class="line"><span class="comment">##测试</span></span><br><span class="line">s.set_age(<span class="number">25</span>)  </span><br><span class="line">&gt;&gt;&gt;s.age</span><br><span class="line"><span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##声明为类方法，声明后所有实例均可调用</span></span><br><span class="line">Student.set_score = set_score</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>限定属性：<br><code>__slots__</code>变量限制该class实例能添加的属性；<code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类不起作用；除非在子类中也定义<code>__slots__</code>，则子类实例允许定义的属性就是自身<code>__slots__</code>加上父类的<code>__slots__</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    __slots__ = (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>) <span class="comment"># 用tuple定义允许绑定的属性名称</span></span><br></pre></td></tr></table></figure>

<p>获取对象信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">###使用type()判断对象类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="string">&#x27;str&#x27;</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="literal">None</span>)</span><br><span class="line">&lt;<span class="built_in">type</span>(<span class="literal">None</span>) <span class="string">&#x27;NoneType&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="built_in">abs</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;builtin_function_or_method&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(a)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Animal&#x27;</span>&gt;</span><br><span class="line"><span class="comment">##由于type()返回的是types类名，用作参数检查时</span></span><br><span class="line"><span class="number">1</span>）</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="string">&#x27;abc&#x27;</span>)==<span class="built_in">type</span>(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> types</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(fn)==types.FunctionType</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="built_in">abs</span>)==types.BuiltinFunctionType</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="keyword">lambda</span> x: x)==types.LambdaType</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>((x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)))==types.GeneratorType</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#####判断自定义的class的类型，使用isinstance()，因为type（）只能判断是个类而不知道具体类名；以及上述type()能判断的都能判断</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="string">&#x27;a&#x27;</span>, <span class="built_in">str</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="number">123</span>, <span class="built_in">int</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="string">b&#x27;a&#x27;</span>, <span class="built_in">bytes</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="comment">##设置能判断类型之一</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (<span class="built_in">list</span>, <span class="built_in">tuple</span>))</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="built_in">list</span>, <span class="built_in">tuple</span>))</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###isinstance()判断一个对象是否是Iterable, Iterator对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable, Iterator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>([], Iterable)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###获得一个对象的所有属性和方法，可以使用dir()，它返回一个包含字符串的list</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">dir</span>(<span class="string">&#x27;ABC&#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;__add__&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>,..., <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;capitalize&#x27;</span>, <span class="string">&#x27;casefold&#x27;</span>,..., <span class="string">&#x27;zfill&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#### getattr()获得属性</span></span><br><span class="line"><span class="comment">#### setattr()设置属性</span></span><br><span class="line"><span class="comment">### hasattr()判断是否有属性</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(obj, <span class="string">&#x27;y&#x27;</span>) <span class="comment"># 有属性&#x27;y&#x27;吗？</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">setattr</span>(obj, <span class="string">&#x27;y&#x27;</span>, <span class="number">19</span>) <span class="comment"># 设置一个属性&#x27;y&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hasattr</span>(obj, <span class="string">&#x27;y&#x27;</span>) <span class="comment"># 有属性&#x27;y&#x27;吗？</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(obj, <span class="string">&#x27;y&#x27;</span>) <span class="comment"># 获取属性&#x27;y&#x27;</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(obj, <span class="string">&#x27;z&#x27;</span>, <span class="number">404</span>) <span class="comment"># 获取属性&#x27;z&#x27;，如果不存在，返回默认值404</span></span><br><span class="line"><span class="number">404</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">####getattr()也可获取方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">getattr</span>(obj, <span class="string">&#x27;power&#x27;</span>) <span class="comment"># 获取属性&#x27;power&#x27;，显示是method </span></span><br><span class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject <span class="built_in">object</span> at <span class="number">0x10077a6a0</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fn = <span class="built_in">getattr</span>(obj, <span class="string">&#x27;power&#x27;</span>) <span class="comment"># 获取属性&#x27;power&#x27;并赋值到变量fn</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fn <span class="comment"># fn指向obj.power</span></span><br><span class="line">&lt;bound method MyObject.power of &lt;__main__.MyObject <span class="built_in">object</span> at <span class="number">0x10077a6a0</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fn() <span class="comment"># 调用fn()与调用obj.power()是一样的</span></span><br><span class="line"><span class="number">81</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>编码</title>
    <url>/2024/02/07/%E8%BD%AF%E4%BB%B6/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%EF%BC%9F%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/%E7%BC%96%E7%A0%81/%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h1 id="二进制编码："><a href="#二进制编码：" class="headerlink" title="二进制编码："></a>二进制编码：</h1><p>服务于二进制运算</p>
<ul>
<li><strong>原码</strong>：最高符号位， 0 正1负，但负数原码不能直接进行+运算（ex:</li>
</ul>
<p><img src="/image/image_vcdNOUEaSQ.png"></p>
<p>负数（设-x）+模值&#x3D;-x+1000 0000&#x3D;(111 1111-x)+1→取反+1</p>
<p><img src="/image/image_IZAqORboxR.png"></p>
<ul>
<li><strong>反码</strong>：正数反码与原码相同，负数反码&#x3D;原码除符号位外其他位取反</li>
<li><strong>补码</strong>：正数的补码与原码相同，负数补码是在其反码基础上加 1&#x20;</li>
</ul>
<h1 id="浮点数编码："><a href="#浮点数编码：" class="headerlink" title="浮点数编码："></a>浮点数编码：</h1><p><img src="/image/image_hChHlnsW1N.png"></p>
<p><img src="/image/image_kiXib6beUU.png"></p>
<p><img src="/image/image_FDz6Z_nBpd.png"></p>
<p><img src="/image/image_ATPqqXrznc.png"></p>
<p><img src="/image/image_GF1ETl0qXf.png"></p>
<h1 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h1><p>字符数据的存储（编码）方式。字符集规定<strong>字符和二进制数之间的一一对应关系</strong>。有了字符集后，计算机可通过查表完成二进制数到字符的转换。</p>
<h2 id="ASCII-字符集（英文）"><a href="#ASCII-字符集（英文）" class="headerlink" title="ASCII 字符集（英文）"></a>ASCII 字符集（英文）</h2><p>「ASCII 码」用 7 位二进制数表示一个字符，<strong>128 个不同的字符包括英文字母</strong>、数字 0 ~ 9、一些标点符号，以及一些控制字符（如换行符和制表符）。</p>
<p><img src="https://www.hello-algo.com/chapter_data_structure/character_encoding.assets/ascii_table.png"></p>
<h2 id="GBK-字符集（中文）"><a href="#GBK-字符集（中文）" class="headerlink" title="GBK 字符集（中文）"></a>GBK 字符集（中文）</h2><p>汉字约有近十万个，日常使用的有几千个。「GB2312」字符集收录了 6763 个汉字，基本满足了汉字的计算机处理需要。</p>
<p>然而，GB2312 无法处理部分的罕见字和繁体字。「GBK」字符集是在 GB2312 的基础上扩展得到的，它共收录了 21886 个汉字。在 GBK 的编码方案中，ASCII 字符使用一个字节表示，汉字使用两个字节表示。</p>
<h2 id="Unicode-字符集"><a href="#Unicode-字符集" class="headerlink" title="Unicode 字符集"></a>Unicode 字符集</h2><p>「Unicode」全称为“统一字符编码”。致力于将全球范围内的字符纳入到统一的字符集之中，提供一种通用的字符集来处理和显示各种语言文字，减少因为编码标准不同而产生的乱码问题。</p>
<p>Unicode 字符集标准给每个字符分配一个编号（称为“码点”），<strong>但并没有规定在计算机中如何存储这些字符码点</strong>。当多种长度的 Unicode 码点同时出现在同一个文本中时，系统如何解析字符？例如给定一个长度为 2 字节的编码，系统如何确认它是一个 2 字节的字符还是两个 1 字节的字符？</p>
<p><strong>等长数组存储字符：</strong> 以下英文字符占1 字节，中文字符占用 2 字节。通过将英文字符高位填 0 ，将“Hello 算法”中的所有字符都编码为 2 字节长度。这样系统就可以每隔 2 字节解析一个字符，恢复短语内容；很显然用等长数组存储字符非常浪费内存空间</p>
<p><img src="https://www.hello-algo.com/chapter_data_structure/character_encoding.assets/unicode_hello_algo.png"></p>
<h3 id="UTF-8-编码"><a href="#UTF-8-编码" class="headerlink" title="UTF-8 编码"></a>UTF-8 编码</h3><p>目前，UTF-8 已成为国际上使用最广泛的 Unicode <strong>变长编码</strong>方法。使用 1 到 4 字节表示一个字符，根据字符的复杂性而变。ASCII 字符需 1 字节，拉丁字母和希腊字母需2 字节，常用中文字符需 3 字节，其他一些生僻字符需4 字节</p>
<p>UTF-8 的编码规则：</p>
<ul>
<li>长为 1 字节的字符，最高位为 0、其余 7 位用于设置 Unicode 码点。<strong>UTF-8 编码可兼容 ASCII 码</strong>；可使用 UTF-8 来解析年代久远的 ASCII 码文本。</li>
<li>&#x20;n字节字符（ n&gt;1），首字节高n位设为 1、第 n+1 位设置为 0 ；系统可通过读取最高位 1 的个数来解析出字符的字节长度；<br>从第二个字节开始，高 2 位都为 10 ；其余位用于填充字符Unicode 码点；这个 10 能够起到校验符的作用。假设系统从一个错误的字节开始解析文本，字节头部的 10 能够帮助系统快速的判断出异常。<br>之所以将 10 当作非首字节校验符，是因为在 UTF-8 编码规则下，首字符最高两位不可能是 10 。假设一个字符的最高两位是 10 ，说明该字符的长度为 1 ，对应 ASCII 码。而 ASCII 码的最高位应该是 0 ，与假设矛盾。</li>
</ul>
<p><img src="https://www.hello-algo.com/chapter_data_structure/character_encoding.assets/utf-8_hello_algo.png"></p>
<h3 id="UTF-16-编码"><a href="#UTF-16-编码" class="headerlink" title="UTF-16 编码"></a><strong>UTF-16 编码</strong></h3><ul>
<li>用 2 或 4 个字节表示一个字符。所有的 ASCII 字符和常用的非英文字符，都用 2 个字节表示；少数字符需要用到 4 个字节表示。对于 2 字节的字符，UTF-16 编码与 Unicode 码点相等。</li>
</ul>
<h3 id="UTF-32-编码："><a href="#UTF-32-编码：" class="headerlink" title="UTF-32 编码："></a><strong>UTF-32 编码</strong>：</h3><ul>
<li>每个字符都使用 4 个字节。这意味着 UTF-32 会比 UTF-8 和 UTF-16 更占空间，特别是对 ASCII 字符占比较高的文本。</li>
</ul>
<p>从存储空间的角度看，** UTF-8 表示英文字符非常高效**，因为它仅需 1 个字节；<strong>UTF-16 编码某些非英文字符（例如中文）会更加高效</strong>，因为它只需要 2 个字节，而 UTF-8 可能需要 3 个字节。</p>
<p>从兼容性的角度看，UTF-8 的通用性最佳，许多工具和库都优先支持 UTF-8 。</p>
<h2 id="编程语言的字符编码"><a href="#编程语言的字符编码" class="headerlink" title="编程语言的字符编码"></a>编程语言的字符编码</h2><p>以往大多数编程语言，字符串都采用 UTF-16 或 UTF-32 这类等长编码。可将字符串看作数组处理，有以下优点：</p>
<h3 id=""><a href="#" class="headerlink" title="??????"></a>??????</h3><ul>
<li><strong>随机访问</strong>: UTF-16 编码的字符串进行随机访问很容易。UTF-8 是一种变长编码，要找到第 i 个字符，我们需要从字符串的开始处遍历到第 i个字符，这需要 O(n) 的时间。</li>
<li><strong>字符计数</strong>: 与随机访问类似，计算 UTF-16 字符串的长度也是 O(1) 的操作。计算 UTF-8 编码的字符串的长度需遍历整个字符串。</li>
<li><strong>字符串操作</strong>: 在 UTF-16 编码的字符串中，很多字符串操作（如分割、连接、插入、删除等）都更容易进行。在 UTF-8 编码的字符串上进行这些操作通常需要额外的计算，以确保不会产生无效的 UTF-8 编码。</li>
<li>Java 的 <code>String</code> 类型使用 UTF-16 编码，每个字符占用 2 字节。这是因为 Java 语言设计之初，人们认为 16 位足以表示所有可能的字符。后来 Unicode 规范扩展到了超过 16 位，所以 Java 中的字符现在可能由一对 16 位的值（称为“代理对”）表示。</li>
<li>JavaScript 和 TypeScript 的字符串使用 UTF-16 编码的原因与 Java 类似</li>
<li>C# 使用 UTF-16 编码，主要因为 .NET 平台是由 Microsoft 设计的，而 Microsoft 的很多技术，包括 Windows 操作系统，都广泛地使用 UTF-16 编码。</li>
</ul>
<p>由于以上编程语言对字符数量的低估，它们不得不采取“代理对”的方式来表示超过 16 位长度的 Unicode 字符。这是一个不得已为之的无奈之举。一方面，包含代理对的字符串中，一个字符可能占用 2 字节或 4 字节，从而丧失了等长编码的优势。另一方面，处理代理对需要增加额外代码，这增加了编程的复杂性和 Debug 难度。</p>
<p>出于以上原因，部分编程语言提出了一些不同的编码方案。</p>
<p>？？？好像可以ide指定字符串中字符的存储方式</p>
<ul>
<li>Python 3 使用一种灵活的字符串表示，存储的字符长度取决于字符串中最大的 Unicode 码点。对于全部是 ASCII 字符的字符串，每个字符占用 1 个字节；如果字符串中包含的字符超出了 ASCII 范围，但全部在基本多语言平面（BMP）内，每个字符占用 2 个字节；如果字符串中有超出 BMP 的字符，那么每个字符占用 4 个字节。</li>
<li>Go 语言的 <code>string</code> 类型在内部使用 UTF-8 编码。Go 语言还提供了 <code>rune</code> 类型，它用于表示单个 Unicode 码点。</li>
<li>Rust 语言的 str 和 String 类型在内部使用 UTF-8 编码。Rust 也提供了 char 类型，用于表示单个 Unicode 码点。</li>
</ul>
<p>以上讨论的都是字符串在编程语言中的存储方式，<strong>这和字符串如何在文件中存储或在网络中传输是两个不同的问题</strong>。在文件存储或网络传输中，我们通常会将字符串编码为 UTF-8 格式，以达到最优的兼容性和空间效率。</p>
]]></content>
      <categories>
        <category>汇编？机器指令</category>
      </categories>
      <tags>
        <tag>汇编？机器指令</tag>
      </tags>
  </entry>
</search>
